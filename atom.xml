<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Threewood</title>
  <icon>https://www.gravatar.com/avatar/5caa616332f0990c42d7331b4a6161a9</icon>
  
  <link href="https://threewood1.top/atom.xml" rel="self"/>
  
  <link href="https://threewood1.top/"/>
  <updated>2024-11-05T09:23:40.635Z</updated>
  <id>https://threewood1.top/</id>
  
  <author>
    <name>三木</name>
    <email>959335709@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka常见面试问题</title>
    <link href="https://threewood1.top/post/fd7940ad.html"/>
    <id>https://threewood1.top/post/fd7940ad.html</id>
    <published>2024-11-05T09:20:17.000Z</published>
    <updated>2024-11-05T09:23:40.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka是什么？有哪些应用场景？"><a href="#Kafka是什么？有哪些应用场景？" class="headerlink" title="Kafka是什么？有哪些应用场景？"></a>Kafka是什么？有哪些应用场景？</h2><p>Kafka 是一个分布式流式处理平台。</p><p><strong>流式平台具有三个关键功能：</strong></p><ol><li>消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li><li>容错的持久方式存储记录消息流：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li><li>流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ol><p><strong>Kafka 主要有两大应用场景：</strong></p><ol><li>消息队列：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li>数据处理： 构建实时的流数据处理程序来转换或处理数据流。</li></ol><h2 id="kafka的核心概念"><a href="#kafka的核心概念" class="headerlink" title="kafka的核心概念"></a>kafka的核心概念</h2><h3 id="什么是Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是Producer、Consumer、Broker、Topic、Partition？"></a>什么是Producer、Consumer、Broker、Topic、Partition？</h3><p><strong>Producer（生产者）</strong> : 产生消息的一方。</p><p><strong>Consumer（消费者）</strong> : 消费消息的一方。</p><p><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</p><p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p><p><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</p><p><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</p><h3 id="Kafka的多副本机制？"><a href="#Kafka的多副本机制？" class="headerlink" title="Kafka的多副本机制？"></a>Kafka的多副本机制？</h3><p>还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader，但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p><h3 id="Kafka的多分区（Partition）以及多副本（Replica）机制有哪些好处？"><a href="#Kafka的多分区（Partition）以及多副本（Replica）机制有哪些好处？" class="headerlink" title="Kafka的多分区（Partition）以及多副本（Replica）机制有哪些好处？"></a>Kafka的多分区（Partition）以及多副本（Replica）机制有哪些好处？</h3><ul><li>Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition 可以指定对应的 Replica 数，这也极大地提高了消息存储的安全性，提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ul><p><img src="/post/fd7940ad/KafkaQA%5C1729651949030-7672037a-8662-4c44-af3e-559005ff5856.png"></p><h2 id="Kafka相比其他消息队列的优势"><a href="#Kafka相比其他消息队列的优势" class="headerlink" title="Kafka相比其他消息队列的优势"></a>Kafka相比其他消息队列的优势</h2><p><img src="/post/fd7940ad/KafkaQA%5C1729650403587-0ca5d0a4-42d7-4905-9411-9b3158e57efa.png"></p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>号称大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。</p><p>Apache Kafka它最初由LinkedIn公司基于独特的设计实现为一个分布式的提交日志系统( a distributed commit log)，之后成为Apache项目的一部分。目前已经被LinkedIn，Uber, Twitter, Netflix等大公司所采纳。</p><p><strong>优点</strong></p><ul><li>性能卓越，单机写入TPS约在百万条&#x2F;秒，最大的优点，就是吞吐量高。</li><li>时效性：ms级</li><li>可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li><li>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;</li><li>有优秀的第三方Kafka Web管理界面Kafka-Manager；</li><li>在日志领域比较成熟，被多家公司和多个开源项目使用；</li><li>功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</li></ul><p><strong>缺点：</strong></p><ul><li>Kafka单机超过64个队列&#x2F;分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</li><li>使用短轮询方式，实时性取决于轮询间隔时间；</li><li>消费失败不支持重试；</li><li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li><li>社区更新较慢；</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p><strong>RabbitMQ优点：</strong></p><ul><li>由于erlang语言的特性，mq 性能较好，高并发；</li><li>吞吐量到万级，MQ功能比较完备</li><li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；</li><li>开源提供的管理界面非常棒，用起来很好用</li><li>社区活跃度高；</li></ul><p><strong>RabbitMQ缺点：</strong></p><ul><li>erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。</li><li>RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。</li><li>需要学习比较复杂的接口和协议，学习和维护成本较高。</li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ出自 阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p><p><strong>RocketMQ优点：</strong></p><ul><li>单机吞吐量：十万级</li><li>可用性：非常高，分布式架构</li><li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li><li>功能支持：MQ功能较为完善，还是分布式的，扩展性好</li><li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li><li>源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控</li></ul><p><strong>RocketMQ缺点：</strong></p><ul><li>支持的客户端语言不多，目前是java及c++，其中c++不成熟；</li><li>社区活跃度一般</li><li>没有在 mq 核心中去实现JMS等接口，有些系统要迁移需要修改大量代码</li></ul><h2 id="kafka消息队列的两种模式"><a href="#kafka消息队列的两种模式" class="headerlink" title="kafka消息队列的两种模式"></a>kafka消息队列的两种模式</h2><h3 id="点对点模式（一对一）"><a href="#点对点模式（一对一）" class="headerlink" title="点对点模式（一对一）"></a>点对点模式（一对一）</h3><p>1）模式特点</p><p>消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，queue中不再存储该条消息，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者消费。</p><p>2）数据拉取方式：消费者主动拉取。</p><p>3）模式缺点：消息不能被重复消费。</p><p><img src="/post/fd7940ad/KafkaQA%5C1729648839824-9b6442ef-81fb-4eb0-8323-a7aaca5687f8.png"></p><h3 id="发布订阅模式（一对多）"><a href="#发布订阅模式（一对多）" class="headerlink" title="发布订阅模式（一对多）"></a>发布订阅模式（一对多）</h3><p>1）模式特点</p><p>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p><p>2）数据拉取方式：消费者主动拉取、消费者被动接受（类似微信公众号）</p><p>3）模式缺点：当数据拉取方式为消费者被动接受时，消费者的消费速度可能跟不上生产者的生产速度。</p><p><img src="/post/fd7940ad/KafkaQA%5C1729649071351-bdb6e5c3-17c9-49b7-86e9-73b8a025e786.png"></p><h2 id="Kafka的高可用机制"><a href="#Kafka的高可用机制" class="headerlink" title="Kafka的高可用机制"></a>Kafka的高可用机制</h2><h3 id="如何保证宕机时数据不丢失？"><a href="#如何保证宕机时数据不丢失？" class="headerlink" title="如何保证宕机时数据不丢失？"></a>如何保证宕机时数据不丢失？</h3><p>如果要想理解这个acks参数的含义，首先就得搞明白kafka的高可用架构原理。</p><p>比如下面的图里就是表明了对于每一个Topic，我们都可以设置他包含几个Partition，每个Partition负责存储这个Topic一部分的数据。</p><p>然后Kafka的Broker集群中，每台机器上都存储了一些Partition，也就存放了Topic的一部分数据，这样就实现了Topic的数据分布式存储在一个Broker集群上。</p><p><img src="/post/fd7940ad/KafkaQA%5C1729649742793-c5943a94-8f34-4d7d-9896-3660dd9503db.png"></p><h3 id="多副本冗余的高可用机制"><a href="#多副本冗余的高可用机制" class="headerlink" title="多副本冗余的高可用机制"></a>多副本冗余的高可用机制</h3><p>在kafka集群中，每个Partition都有多个副本，其中一个副本叫做leader，其他的副本叫做follower，如下图。</p><p><img src="/post/fd7940ad/KafkaQA%5C1729650564985-3bd91397-4cea-4cf8-816a-3c5f8b45b5ae.png"></p><p>如上图所示，假设一个Topic拆分为了3个Partition，分别是Partition0，Partiton1，Partition2，此时每个Partition都有2个副本。</p><p>比如Partition0有一个副本是Leader，另外一个副本是Follower，Leader和Follower两个副本是分布在不同机器上的。</p><p>这样的多副本冗余机制，可以保证任何一台机器挂掉，都不会导致数据彻底丢失，因为起码还是有副本在别的机器上的。</p><h3 id="多副本之间数据如何同步？"><a href="#多副本之间数据如何同步？" class="headerlink" title="多副本之间数据如何同步？"></a>多副本之间数据如何同步？</h3><p>接着我们就来看看多个副本之间数据是如何同步的？其实任何一个Partition，只有Leader是对外提供读写服务的。</p><p>也就是说，如果有一个客户端往一个Partition写入数据，此时一般就是写入这个Partition的Leader副本。</p><p>然后Leader副本接收到数据之后，Follower副本会不停的给他发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。如下图所示：</p><p><img src="/post/fd7940ad/KafkaQA%5C1729651234299-6864ee00-b6bf-4085-8bfc-b422d1784d3c.png"></p><h3 id="ISR到底指的是什么东西？"><a href="#ISR到底指的是什么东西？" class="headerlink" title="ISR到底指的是什么东西？"></a>ISR到底指的是什么东西？</h3><p>既然大家已经知道了Partiton的多副本同步数据的机制了，那么就可以来看看ISR是什么了。</p><p>ISR全称是“<strong>In-Sync Replicas</strong>”，也就是保持同步的副本，他的含义就是，<strong>跟Leader始终保持同步的Follower有哪些</strong>。</p><p>大家可以想一下 ，如果说某个Follower所在的Broker因为JVM FullGC之类的问题，导致自己卡顿了，无法及时从Leader拉取同步数据，那么是不是会导致Follower的数据比Leader要落后很多？</p><p>所以这个时候，就意味着Follower已经跟Leader不再处于同步的关系了。但是只要Follower一直及时从Leader同步数据，就可以保证他们是处于同步的关系的。</p><p>所以每个Partition都有一个ISR，这个ISR里一定会有Leader自己，因为Leader肯定数据是最新的，然后就是那些跟Leader保持同步的Follower，也会在ISR里。</p><h3 id="acks参数的含义"><a href="#acks参数的含义" class="headerlink" title="acks参数的含义"></a>acks参数的含义</h3><p>首先这个acks参数，是在KafkaProducer，也就是生产者客户端里设置的。也就是说，你往kafka写数据的时候，就可以来设置这个acks参数。然后这个参数实际上有三种常见的值可以设置，分别是：0、1 和 all。</p><h4 id="acks参数设置为0"><a href="#acks参数设置为0" class="headerlink" title="acks参数设置为0"></a>acks参数设置为0</h4><p>这种方式意思就是我的KafkaProducer在客户端，只要把消息发送出去，不管那条数据有没有在哪怕Partition Leader上落到磁盘，我就不管他了，直接就认为这个消息发送成功了。</p><p>如果你采用这种设置的话，那么你必须注意的一点是，可能你发送出去的消息还在半路。结果呢，Partition Leader所在Broker就直接挂了，然后结果你的客户端还认为消息发送成功了，此时就会导致这条消息就丢失了。</p><h4 id="acks参数设置为1"><a href="#acks参数设置为1" class="headerlink" title="acks参数设置为1"></a>acks参数设置为1</h4><p>这种方式意思就是说只要Partition Leader接收到消息而且写入本地磁盘了，就认为成功了，不管他其他的Follower有没有同步过去这条消息了。这种设置是<strong>kafka默认的设置</strong>，也就是说，你要是不管acks这个参数，只要Partition Leader写成功就算成功。</p><p>但是这里有一个问题，万一Partition Leader刚刚接收到消息，Follower还没来得及同步过去，结果Leader所在的broker宕机了，此时也会导致这条消息丢失，因为人家客户端已经认为发送成功了。</p><h4 id="acks参数设置为all"><a href="#acks参数设置为all" class="headerlink" title="acks参数设置为all"></a>acks参数设置为all</h4><p>这种方式意思就是说，Partition Leader接收到消息之后，还必须要求ISR列表里跟Leader保持同步的那些Follower都要把消息同步过去，才能认为这条消息是写入成功了。</p><p>如果说Partition Leader刚接收到了消息，但是结果Follower没有收到消息，此时Leader宕机了，那么客户端会感知到这个消息没发送成功，他会重试再次发送消息过去。</p><p>此时可能Partition 2的Follower变成Leader了，此时ISR列表里只有最新的这个Follower转变成的Leader了，那么只要这个新的Leader接收消息就算成功了。</p><h2 id="Kafka如何保证消息有序"><a href="#Kafka如何保证消息有序" class="headerlink" title="Kafka如何保证消息有序"></a>Kafka如何保证消息有序</h2><ol><li>1 个 Topic 只对应一个 Partition。</li><li>（推荐）发送消息的时候指定 key&#x2F;Partition。</li></ol><p> Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表&#x2F;对象的 id 来作为 key 。</p><h2 id="Kafka如何确保消息不丢失"><a href="#Kafka如何确保消息不丢失" class="headerlink" title="Kafka如何确保消息不丢失"></a>Kafka如何确保消息不丢失</h2><h3 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h3><p>生产者(Producer) 调用send方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>通过回调函数异步获取send方法的调用结果来检查消息是否发送成功。如果消息发送失败的话，我们检查失败的原因之后重新发送即可，这里可以使用Producer的<code>retries</code>（重试次数）设置一个合理的值，一般是3。此外，也要考虑重试的时间间隔。</p><h3 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h3><p>。。。</p><h3 id="Kafka丢失消息"><a href="#Kafka丢失消息" class="headerlink" title="Kafka丢失消息"></a>Kafka丢失消息</h3><p>答案就是Kafka高可用机制中的<strong>acks含义</strong></p><h2 id="Kafka消息是采用Pull模式，还是Push模式？"><a href="#Kafka消息是采用Pull模式，还是Push模式？" class="headerlink" title="Kafka消息是采用Pull模式，还是Push模式？"></a>Kafka消息是采用Pull模式，还是Push模式？</h2><p>在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。</p><p>Pull模式的另外一个<strong>好处</strong>是consumer可以自主决定是否批量的从broker拉取数据。Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。</p><p>Pull有个<strong>缺点</strong>是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达（当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发）</p><h2 id="如何保证消息不重复消费"><a href="#如何保证消息不重复消费" class="headerlink" title="如何保证消息不重复消费"></a>如何保证消息不重复消费</h2><p><strong>Kafka 出现消息重复消费的原因：</strong></p><ul><li>服务端侧已经消费的数据没有成功提交 消费位移offset（根本原因）。</li><li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li></ul><p><strong>解决方案：</strong></p><ul><li><p>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p></li><li><p>将 <code>**enable.auto.commit**</code> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交 offset 合适？</strong></p></li><li><p>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</p></li><li><p>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</p></li></ul><h2 id="消息积压怎么处理"><a href="#消息积压怎么处理" class="headerlink" title="消息积压怎么处理"></a>消息积压怎么处理</h2><p>这种是由只能操作临时扩容，以更快的速度去消费数据。</p><ol><li>增加多个消费者，加速消费；</li><li>新建topic引流，将消息引导别的程序。</li></ol>]]></content>
    
    
    <summary type="html">Kafka常见面试问题</summary>
    
    
    
    <category term="Java" scheme="https://threewood1.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="Interviews" scheme="https://threewood1.top/tags/Interviews/"/>
    
    <category term="Kafka" scheme="https://threewood1.top/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Springboot项目登录拦截的三种方式</title>
    <link href="https://threewood1.top/post/51af033.html"/>
    <id>https://threewood1.top/post/51af033.html</id>
    <published>2024-09-16T12:01:00.000Z</published>
    <updated>2024-09-16T12:50:29.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a><strong>什么是分布式锁</strong></h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在系统中，我们经常需要在处理用户请求之前和之后执行一些行为，例如检测用户的权限，或者将请求的信息记录到日志中。当然不仅仅这些，所以需要一种机制，拦截用户的请求，在请求的前后添加处理逻辑。</p><p>本文就以登录拦截为主，介绍三种方式实现登录拦截。</p><h1 id="方案一（过滤器）"><a href="#方案一（过滤器）" class="headerlink" title="方案一（过滤器）"></a>方案一（过滤器）</h1><p><strong>过滤器（Filter）</strong>是对数据进行过滤，预处理。开发人员可以对客户端提交的数据进行过滤处理，比如敏感词，也可以对服务端返回的数据进行处理。还有就是可以验证用户的登录情况，权限验证，对静态资源进行访问控制，没有登录或者是没有权限时是不能让用户直接访问这些资源的。类似的过滤器还有很多的功能，比如说编码，压缩服务端给客户端返回的各种数据等等。</p><p>使用过滤器实现登录拦截要先实现一个过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CURRENT_USER</span> <span class="operator">=</span> <span class="string">&quot;current_user&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//配置白名单</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;Pattern&gt; patterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Pattern&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码块，在虚拟机加载类的时候就会加载执行，而且只执行一次</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">patterns.add(Pattern.compile(<span class="string">&quot;/index&quot;</span>));</span><br><span class="line">patterns.add(Pattern.compile(<span class="string">&quot;/login&quot;</span>));</span><br><span class="line">patterns.add(Pattern.compile(<span class="string">&quot;/register&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">        ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">        ServletResponse servletResponse,</span></span><br><span class="line"><span class="params">        FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"><span class="type">HttpServletResponseWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpServletResponseWrapper</span>(httpResponse);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> httpRequest.getRequestURI().substring(httpRequest.getContextPath().length());</span><br><span class="line"><span class="keyword">if</span> (isInclude(url)) &#123;</span><br><span class="line"><span class="comment">//在白名单中的url,放行访问</span></span><br><span class="line">filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SessionUtils.getSessionAttribute(CURRENT_USER) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//若为登录状态 放行访问</span></span><br><span class="line">filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则默认访问index接口</span></span><br><span class="line">wrapper.sendRedirect(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前请求是否在白名单</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInclude</span><span class="params">(String url)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Pattern pattern : patterns) &#123;</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(url);</span><br><span class="line"><span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后注册过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean <span class="title function_">someFilterRegistration</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">FilterRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">registration.setFilter(myFilter());</span><br><span class="line"><span class="comment">//拦截/*的访问 多级匹配（springboot 过滤器/*以及匹配 /**多级匹配）</span></span><br><span class="line">registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">registration.setName(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;myFilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Filter <span class="title function_">myFilter</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyFilter</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案二（拦截器）"><a href="#方案二（拦截器）" class="headerlink" title="方案二（拦截器）"></a>方案二（拦截器）</h1><p><strong>拦截器（Interceptor）</strong>是SpringMVC提供的一种拦截机制，基于AOP动态代理实现，用于请求的预处理和后处理。在SpringMVC中定义一个拦截器有两种方法：第一种是实现<code>HandlerInterceptor</code>接口，或者继承实现了<code>HandlerInterceptor</code>接口的类（例如：<code>HandlerInterceptorAdapter</code>）；第二种方法时实现Spring的<code>WebRequestInterceptor</code>接口，或者继承实现了<code>WebRequestInterceptor</code>接口的类。这些拦截器都是在Handler的执行周期内进行拦截操作的。下面主要介绍第一种方法。</p><p>首先我们要实现<code>HandlerInterceptor</code>接口定义登录校验的方法。在实现这个接口之前我们要先看看这个接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        Object handler,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                 HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                 Object handler,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>HandlerInterceptor</code>接口中有三个要实现的方法，分别是<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>。</p><ul><li><p><code>preHandle()</code>：这个方法将在请求处理之前进行调用。注意：如果该方法的返回值为<code>false</code> ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行。</p></li><li><p><code>postHandle()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 有意思的是：<code>postHandle()</code>方法被调用的顺序跟 <code>preHandle()</code> 是相反的，先声明的拦截器 <code>preHandle()</code>方法先执行，而<code>postHandle()</code>方法反而会后执行。</p></li><li><p><code>afterCompletion()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行。</p></li></ul><p>而我们如果要实现登录拦截，就需要重写<code>preHandle()</code>方法，然后在其中实现登录拦截的逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterception</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(Constant.TOKEN_HEADER_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            returnNoLogin(response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从redis中拿token对应user</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(Constant.REDIS_USER_PREFIX + token);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            returnNoLogin(response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// token续期</span></span><br><span class="line">        redisTemplate.expire(Constant.REDIS_USER_PREFIX + token, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回未登录的错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response ServletResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">returnNoLogin</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">// 设置返回401 和响应编码</span></span><br><span class="line">        response.setStatus(<span class="number">401</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;Application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 构造返回响应体</span></span><br><span class="line">        Result&lt;String&gt; result = Result.&lt;String&gt;builder()</span><br><span class="line">                .code(HttpStatus.UNAUTHORIZED.value())</span><br><span class="line">                .errorMsg(<span class="string">&quot;未登陆，请先登陆&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> JSONUtil.toJsonStr(result);</span><br><span class="line">        outputStream.write(resultString.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置WebMvcConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginProperties loginProperties;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterception loginInterception;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginInterception)</span><br><span class="line">                .addPathPatterns(loginProperties.getInterceptorIncludeUrl())</span><br><span class="line">                .excludePathPatterns(loginProperties.getInterceptorExcludeUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案三（AOP-自定义注解）"><a href="#方案三（AOP-自定义注解）" class="headerlink" title="方案三（AOP+自定义注解）"></a>方案三（AOP+自定义注解）</h1><p>通过自定义注解和AOP也可以实现登录拦截的功能</p><p>首先自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局拦截器注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GlobalInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">checkLogin</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验管理员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">checkAdmin</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写自定义注解的切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局操作切面类</span></span><br><span class="line"><span class="comment"> * 功能：实现登录拦截</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;globalOperationAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//说明当前对象是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalOperationAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalOperationAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用@Before注解定义了一个前置通知，这意味着在任何标有@GlobalInterceptor注解的方法执行前，都会先执行interceptorDo方法。</span></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.easychat.annotation.GlobalInterceptor)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interceptorDo</span><span class="params">(JoinPoint joinPoint)</span> &#123;  <span class="comment">//通过JoinPoint获取当前连接点的信息，进一步通过MethodSignature获取到目标方法。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">            <span class="comment">//获取目标方法上的GlobalInterceptor注解实例，如果不存在该注解，则直接返回，不进行后续的拦截逻辑。</span></span><br><span class="line">            <span class="type">GlobalInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> method.getAnnotation(GlobalInterceptor.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == interceptor) &#123; <span class="comment">//没有@GlobalInterceptor注解，放行</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//校验登录  根据GlobalInterceptor注解的checkLogin和checkAdmin属性决定是否需要执行登录校验。</span></span><br><span class="line">            <span class="keyword">if</span> (interceptor.checkLogin() || interceptor.checkAdmin()) &#123;</span><br><span class="line">                checkLogin(interceptor.checkAdmin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;全局拦截器异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;全局拦截器异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ResponseCodeEnum.CODE_500);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//身份认证</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkLogin</span><span class="params">(Boolean checkAdmin)</span> &#123;</span><br><span class="line">        <span class="comment">//通过RequestContextHolder.getRequestAttributes()获取当前线程的请求属性，然后强制转换为ServletRequestAttributes，</span></span><br><span class="line">        <span class="comment">//进而得到HttpServletRequest request对象。这一步骤是为了从请求中获取HTTP头部信息。</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="type">TokenUserInfoDto</span> <span class="variable">tokenUserInfoDto</span> <span class="operator">=</span> (TokenUserInfoDto) redisUtils.get(Constants.REDIS_KEY_WS_TOKEN + token);</span><br><span class="line">        <span class="keyword">if</span> (tokenUserInfoDto == <span class="literal">null</span>) &#123; <span class="comment">//通过token没找到对应的tokenUserInfoDto</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ResponseCodeEnum.CODE_901);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkAdmin &amp;&amp; !tokenUserInfoDto.getAdmin()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ResponseCodeEnum.CODE_404);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在需要登录拦截的Controller方法上使用<code>@GlobalInterceptor</code>注解即可实现登录拦截。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是本文关节登录拦截的三种实现方式，而这三种方式的执行顺序是 Filter &gt; Interceptor &gt; AOP 。而且拦截器和过滤器的区别可参见<a href="https://cloud.tencent.com/developer/article/2142914">面试突击90：过滤器和拦截器有什么区别？-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>Reference：</strong></p><p><a href="https://blog.csdn.net/chengchengxn/article/details/88619575">java过滤器实现登录拦截处理_java 服务端屏蔽某个接口-CSDN博客</a></p><p><a href="https://blog.csdn.net/cj151525/article/details/131375435">SpringBoot自定义注解—AOP方式和拦截器方式实现_自定义注解aop拦截-CSDN博客</a></p><p><a href="https://blog.csdn.net/HLH_2021/article/details/119491890">Springboot实现登录拦截的三种方式_springboot登录拦截-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">登录拦截的实现方式</summary>
    
    
    
    <category term="SprintBoot" scheme="https://threewood1.top/categories/SprintBoot/"/>
    
    
    <category term="Interceptor" scheme="https://threewood1.top/tags/Interceptor/"/>
    
    <category term="Filter" scheme="https://threewood1.top/tags/Filter/"/>
    
    <category term="AOP" scheme="https://threewood1.top/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁的方法和常见问题</title>
    <link href="https://threewood1.top/post/dcc6e30d.html"/>
    <id>https://threewood1.top/post/dcc6e30d.html</id>
    <published>2024-09-13T02:07:00.000Z</published>
    <updated>2024-09-16T07:05:44.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a><strong>什么是分布式锁</strong></h1><p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。这篇文章将介绍Redis实现分布式锁的一些方式。</p><p><strong>分布式锁的特征</strong></p><p><img src="/post/dcc6e30d/img1.png"></p><h1 id="分布式锁的实现方法"><a href="#分布式锁的实现方法" class="headerlink" title="分布式锁的实现方法"></a>分布式锁的实现方法</h1><h2 id="1-SETNX-EXPIRE命令"><a href="#1-SETNX-EXPIRE命令" class="headerlink" title="1. SETNX + EXPIRE命令"></a>1. SETNX + EXPIRE命令</h2><p>第一种方案是我们最能想到的，也是最容易实现的，即通过<code>setnx</code> +<code>expire</code> 命令。先使用<code>setnx</code> 来获取并尝试上锁，如果成功获取到锁，再用<code>expire</code> 命令给锁设置一个过期时间，防止发生死锁的情况。</p><blockquote><p>SETNX 是SET IF NOT EXISTS的简写。日常命令格式是SETNX key value，如果 key不存在，则SETNX成功返回1，如果这个key已经存在了，则返回0。</p></blockquote><p>假设某电商网站的某商品做秒杀活动，key可以设置为key_resource_id,value设置任意值，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.setnx(key_resource_id,lock_value) == <span class="number">1</span>)&#123; <span class="comment">//加锁</span></span><br><span class="line">    expire(key_resource_id，<span class="number">100</span>); <span class="comment">//设置过期时间</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务请求</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key_resource_id); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方案中，<code>setnx</code>和<code>expire</code>两个命令分开了，<strong>「不是原子操作」</strong>。如果执行完<code>setnx</code>加锁，正要执行<code>expire</code>设置过期时间时，进程crash或者要重启维护了，那么这个锁就“长生不老”了，<strong>「别的线程永远获取不到锁啦」</strong>。</p><h2 id="2-SETNX-value-系统时间-过期时间"><a href="#2-SETNX-value-系统时间-过期时间" class="headerlink" title="2. SETNX + value(系统时间+过期时间)"></a>2. SETNX + value(系统时间+过期时间)</h2><p>为了解决第一种方法中可能出现的问题<strong>「获取锁的进程发生异常导致锁无法释放」</strong>。我们可以想到这种方式，即将过期时间放到<code>setnx</code>的value中，如果别的进程加锁失败，则可以检查value中的过期时间和当前时间。加锁代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">expires</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime; <span class="comment">//系统时间+设置的过期时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">expiresStr</span> <span class="operator">=</span> String.valueOf(expires);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line"><span class="keyword">if</span> (jedis.setnx(key_resource_id, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果锁已经存在，获取锁的过期时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">currentValueStr</span> <span class="operator">=</span> jedis.get(key_resource_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span></span><br><span class="line"><span class="keyword">if</span> (currentValueStr != <span class="literal">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">     <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldValueStr</span> <span class="operator">=</span> jedis.getSet(key_resource_id, expiresStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="literal">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">         <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//其他情况，均返回加锁失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这个方法把过期时间放在<code>value</code>中，移除了单独设置过期时间的<code>expire</code>操作，从而解决了第一种方式SETNX + EXPIRE不是原子性的弊端。但是这个方法也有一定的缺点：</p><ul><li>过期时间是客户端自己生成的（ <code>System.currentTimeMillis()</code> 是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步。</li><li>如果锁过期的时候，并发多个客户端同时请求过来，都执行 <code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖。</li><li>该锁没有保存持有者的唯一标识，可能被别的客户端释放&#x2F;解锁。</li></ul><h2 id="3-使用Lua脚本"><a href="#3-使用Lua脚本" class="headerlink" title="3. 使用Lua脚本"></a>3. 使用Lua脚本</h2><p>实际上，对于第1种方法（SETNX和EXPIRE命令），我们可以使用Lua脚本来保证原子性。lua脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>加锁的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lua_scripts</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">            <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line"><span class="comment">//判断是否成功</span></span><br><span class="line"><span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure><p>使用这种方式，那么<code>value</code>可以存放锁持有者的唯一标识，这可以防止锁被别的进程释放。</p><h2 id="4-SET的扩展命令（SET-EX-PX-NX）"><a href="#4-SET的扩展命令（SET-EX-PX-NX）" class="headerlink" title="4. SET的扩展命令（SET EX PX NX）"></a>4. SET的扩展命令（SET EX PX NX）</h2><p>除了使用，使用Lua脚本，保证<code>SETNX + EXPIRE</code>两条指令的原子性，我们还可以巧用Redis的SET指令扩展参数！（<code>SET key value[EX seconds][PX milliseconds][NX|XX]</code>），它也是<strong>原子性</strong>的！</p><blockquote><p>SET key value[EX seconds] [PX milliseconds] [NX|XX]</p><p>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。<br>EX seconds :设定key的过期时间，时间单位是秒。<br>PX milliseconds: 设定key的过期时间，单位为毫秒<br>XX: 仅当key存在时设置值</p></blockquote><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.set(key_resource_id, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>)&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key_resource_id); <span class="comment">//释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方法可能存在两个问题：</p><ul><li>问题一：<strong>「锁过期释放了，业务还没执行完」</strong>。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。</li><li>问题二：<strong>「锁被别的线程误删」</strong>。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。</li></ul><h2 id="5-SET-EX-PX-NX-校验唯一随机值-再删除"><a href="#5-SET-EX-PX-NX-校验唯一随机值-再删除" class="headerlink" title="5. SET EX PX NX  + 校验唯一随机值,再删除"></a>5. SET EX PX NX  + 校验唯一随机值,再删除</h2><p>对于方法4可能被误删的问题，我们可以给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下，不就OK了嘛。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.set(key_resource_id, uni_request_id, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>) &#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//判断是不是当前线程加的锁,是才释放</span></span><br><span class="line">       <span class="keyword">if</span> (uni_request_id.equals(jedis.get(key_resource_id))) &#123;</span><br><span class="line">        jedis.del(lockKey); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<strong>「判断是不是当前线程加的锁」</strong>和<strong>「释放锁」</strong>不是一个原子操作。如果调用jedis.del()释放锁的时候，可能这把锁已经不属于当前客户端，会解除他人加的锁。</p><p>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="6-Redisson框架"><a href="#6-Redisson框架" class="headerlink" title="6. Redisson框架"></a>6. Redisson框架</h2><p>方法5虽然解决了方法4中<strong>「锁被别的线程误删」</strong>的情况，但是仍然存在<strong>「锁过期释放了，业务还没执行完」</strong>的情况，此时就不得不请出我们强大的Redisson框架了。</p><p>Redisson的底层原理如下：</p><p><img src="/post/dcc6e30d/img2.png"></p><p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了<strong>「锁过期释放，业务没执行完」</strong>问题。</p><p>并且，由于看门狗的续期是在客户端执行的，所以如果线程1宕机了，续期的线程就不能工作了，也就不能续期，那么锁到期后就会自动被删除。</p><h2 id="7-多机实现的分布式锁Redlock-Redisson"><a href="#7-多机实现的分布式锁Redlock-Redisson" class="headerlink" title="7. 多机实现的分布式锁Redlock+Redisson"></a>7. 多机实现的分布式锁Redlock+Redisson</h2><p>前面的方法都是基于单机版的讨论，有些时候，Redis是集群部署的。</p><p><img src="/post/dcc6e30d/img3.png"></p><p><strong>Redis集群可能存在的问题：</strong>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p><p>这时候就要用到Redis专门为分布式锁提出的RedLock算法。其核心思想如下：</p><blockquote><p>搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p></blockquote><p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p><p><img src="/post/dcc6e30d/img4.png"></p><p>RedLock的实现步骤如下：</p><ol><li><p>获取当前时间，以毫秒为单位。</p></li><li><p>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</p></li><li><p>客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N&#x2F;2+1，这里是5&#x2F;2+1&#x3D;3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+40ms+50ms）</p></li></ol><p>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</p><p>如果获取锁失败（没有在至少N&#x2F;2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</p><p>换句话说：</p><blockquote><ul><li>按顺序向5个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li><li>如果获取锁失败，解锁！</li></ul></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完了这么多种分布式锁的实现方式，发现每种方式都不是完美的。所以在实际开发中，要根据具体的场景来选用具体的方法，比如单机redis的话使用方法6可以满足大部分需求，在多机redis场景中使用Redlock可以有效解决redis集群里数据不一致的情况。无论哪种方法都不可能完全保证没有问题，引用一句老话，“技术不够，人工来凑！”</p><p><strong>Reference：</strong></p><p><a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">Redis实现分布式锁的7种方案 - why414 - 博客园 (cnblogs.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/2280021">Redis分布式锁的实现方式及底层原理-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce">浅析 Redis 分布式锁解决方案_语言 &amp; 开发_Qunar技术沙龙_InfoQ精选文章</a></p><p><a href="https://juejin.cn/post/6844904082860146695#heading-3">细说Redis分布式锁🔒不知道会不会落灰太严重，被保洁阿姨扔掉了。 连敲带画码出此文，有一些细节，对redis锁不清晰 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">Redis实现分布式锁和常见问题</summary>
    
    
    
    <category term="Redis" scheme="https://threewood1.top/categories/Redis/"/>
    
    
    <category term="Interviews" scheme="https://threewood1.top/tags/Interviews/"/>
    
    <category term="Redis" scheme="https://threewood1.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis常见面试问题</title>
    <link href="https://threewood1.top/post/729cb619.html"/>
    <id>https://threewood1.top/post/729cb619.html</id>
    <published>2024-08-22T07:38:17.000Z</published>
    <updated>2024-09-16T06:44:26.061Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>什么是Redis，具有哪些特点？</strong></p><p>Redis是一个基于内存的数据库，读写速度非常快，通常被用作缓存、消息队列、分布式锁和键值存储数据库。它还支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等，Redis还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。</p></li><li><p><strong>MySQL和Redis的区别？*</strong>*</p><ol><li><strong>存储方式</strong>：redis基于键值对，支持多种数据结构；而MySQL是一种关系型数据库，使用表来组织数据。</li><li><strong>持久化</strong>：redis将数据存在内存中，通过持久化机制将数据写入磁盘；MySQL通常将数据存储在磁盘上。</li><li><strong>复杂查询支持</strong>：redis不使用SQL，而是使用自己的命令集，不支持复杂的查询；MySQL使用SQL语言，可以进行复杂的查询操作。</li><li><strong>应用场景</strong>：redis以高性能能低延迟为目标，适用于读多写少的应用场景；MySQL适用于需要复杂查询、事务处理和大规模数据存储的应用场景。</li></ol></li><li><p><strong>Redis有什么优缺点？为什么用Redis查询会比较快？</strong></p><p><strong>优点：</strong>Redis是一个基于<strong>内存</strong>的数据库，读写速度非常快，通常被用作<strong>缓存、消息队列、分布式锁和键值存储数据库</strong>。常支持多种数据类型，如<strong>字符串、哈希表、列表、集合、有序集合</strong>等，Redis还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。</p><p><strong>缺点：</strong>1.<strong>内存限制</strong>，redis将数据存储在内存中，因此它受到物理内存大小限制；2.<strong>单线程模型</strong>，redis使用单线程处理客户端请求，这限制了他在高并发场景下的吞吐量；3.redis不支持SQL数据库那样的<strong>复杂查询</strong>操作。</p><p>redis查询速度快的原因：</p><ol><li><strong>基于内存</strong>：内存的本身的读写速度很快，这是redis速度快的主要原因；</li><li><strong>高效的数据结构</strong>：redis专门设计了STRING、LIST、HASH等高效数据结构，依赖各种数据结构提升了读写的效率；</li><li><strong>单线程</strong>：单线程操作避免了多线程资源竞争和上下文切换带来的性能损失；</li><li><strong>I&#x2F;O多路复用</strong>：采用I&#x2F;O多路复用同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。</li></ol></li><li><p><strong>Redis是单线程的还是多线程的，为什么？***</strong></p><p>Redis是<strong>单线程</strong>的，原因如下：</p><ol><li>CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。</li><li>单线程容易实现，并且单线程避免了多线程的资源竞争和上下文切换的开销。</li></ol></li><li><p><strong>Redis的数据类型？有哪些使用场景？</strong></p><p><img src="/post/729cb619/image-20240324152122376.png"></p><p>Redis常见的数据类型有：String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、Zset（有序集合）</p><ul><li>字符串：存储字符串数据，也可以存储整数、浮点数，是最基本的数据类型，常用于缓存对象、常规计数、分布式锁、共享Session信息等；</li><li>哈希表：存储字段和值的映射，常用于缓存对象、购物车等；</li><li>列表：存储有序的字符串元素，常用于消息队列（有两个问题：1. ⽣产者需要自行实现全局唯⼀ ID；2. 不能以消费组形式消费数据）；</li><li>集合：存储无序不重复的字符串元素，常用于聚合运算场景（并集、交集、差集），如点赞、共同关注、抽奖活动；</li><li>有序集合：类似于集合，但是可以根据元素所关联的分数进行排序，常用于排序场景，如排行榜。</li></ul><p>随着Redis版本更新，又更新了这些数据类型：</p><ul><li>BitMap：存储位的数据结构，可以处理一些位运算操作，比如签到、登录状态等；</li><li>HyperLogLog：用于基数估算的数据结构，用于统计元素的唯⼀数量，如海量数据基数统计的场景；</li><li>GEO：存储地理位置信息的数据结构；</li><li>Stream：专门为消息队列设计的数据类型。</li></ul></li><li><p><strong>Redis持久化机制有哪些？</strong></p><ul><li>AOF日志：每次执行一条写操作指令，就把该指令以追加的方式写入到一个文件里；</li><li>RDB快照：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li>混合持久化方式：集成了前两种的优点。（AOF优点是服务器宕机时<strong>丢失数据少</strong>，但是数据恢复不够快；RDB的优点是<strong>数据恢复快</strong>，但是保存快照的频率不好把握，频率高会影响新能，频率低会丢失的数据较多。）</li></ul></li><li><p><strong>混合持久化如何实现的？</strong></p><p><strong>混合持久化工作在 AOF 日志重写过程</strong>。在 AOF 重写日志时，fork出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的AOF 文件。文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p><p>总结：首先将内存的数据以RDB的方式写入到AOF文件，而后续主线程的写操作命令会被记录到重写缓冲区，重写缓冲区里的增量命令会以AOF 方式写入到 AOF 文件，最后前半部分是RDB格式的全量数据、后半部分是AOF格式的增量数据的AOF文件再持久化到磁盘上。</p></li><li><p><strong>AOF的三种写回策略？</strong></p><p>Always、Everysec和No，这三种策略的可靠性是从高到低，而性能是从低到高。</p><p><strong>Always</strong>是每次写操作命令执行完后，同步将AOF日志数据写回磁盘；<strong>Always</strong>每次写操作命令执行完后，先将命令写入到AOF文件的内核缓冲区，然后每隔一秒将缓冲区的内容写回磁盘；<strong>No</strong>就是不控制写回磁盘的时机。每次写操作命令执行完后，先将写操作命令写入到AOF文件的内核缓冲区，再由操作系统决定何时将缓冲区的内容写回磁盘。</p></li><li><p><strong>Redis集群模式有哪些&#x2F;Redis有哪些部署方案？哨兵模式的功能？</strong></p><ul><li><strong>主从复制</strong>：将一个Redis实例的数据复制到其他实例，其中一个是主节点（master），其余是从节点（slave）。主节点将写操作传播到所有从节点。</li><li><strong>哨兵（Sentinel）</strong>：监控Redis实例的状态，发现主节点故障时，自动进行故障转移。</li><li><strong>切片集群（Cluster）</strong>：将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖。</li></ul><p>Redis哨兵用于监控Redis实例的状态，发现主节点的故障并自动进行故障转移。</p><ul><li>监控：监控Redis主服务器和从服务器的状态，包括连接状态、是否能够执行命令、是否有持久性问题等。</li><li>故障转移：当哨兵（sentinel）发现主服务器不可用时（例如宕机），它会通过一定的选举机制选择一个从服务器升级为新的主服务器。</li><li>通知：哨兵（sentinel）在选举完新的主服务器后，通知其他从服务器将其切换到新的主服务器。</li></ul></li><li><p><strong>哨兵的工作原理？</strong></p></li></ol><ul><li><p><strong>判断节点是否存活</strong>：每个哨兵定期向Redis服务器发送PING命令，以检测服务器是否处于活跃状态。若哨兵在连续一定次数未收到服务器的响应，就认为该服务器主观下线。然后哨兵就会从从节点中选择一个作为主节点。</p></li><li><p><strong>选出新主节点</strong>：在发现主服务器下线后，哨兵们会协调选举一个新的主服务器。这个过程中，哨兵会考虑每个可用的从服务器，选择个作为新的主服务器，并将其他从服务器配置为复制新的主服务器。</p><p>具体过程：</p><ul><li><strong>选择候选从服务器</strong>：哨兵会从可用的从服务器中选择一组候选服务器，通常选择复制偏移量 (replicationoffset) 最大的从服务器。</li><li><strong>计算投票</strong>：每个哨兵为每个候选从服务器投票。投票的考量因素包括从服务器的复制偏移量、连接质量、优先级等。</li><li><strong>达成共识</strong>：哨兵们根据投票结果达成共识，选择一个从服务器作为新的主服务器。这通常需要获得多数哨兵的同意。</li></ul></li><li><p><strong>更新配置信息</strong>：一旦新的主服务器被选出，哨兵会更新 Redis 集群的配置信息，包括将新的主服务器的地址和端口通知给其他哨兵和客户端。</p></li><li><p><strong>通知客户端</strong>：哨兵会向客户端发送通知，告知客户端新的主服务器的位置，以便客户端能够重新连接。</p></li></ul><ol start="11"><li><p><strong>Redis过期删除策略有哪些？</strong></p><ul><li><strong>定时删除</strong>：设置key的过期时间，当时间到达时，自动执行key的删除操作。</li><li><strong>惰性删除</strong>：每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</li><li><strong>定期删除</strong>：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</li></ul><p>Redis选择 <strong>惰性删除 + 定期删除</strong> 这两种策略配合使用。</p></li><li><p><strong>缓存雪崩、击穿、穿透和解决办法</strong></p><ul><li><p><strong>缓存雪崩</strong>：指的是在某个时间点，缓存中大量数据同时失效，导致请求直接访问数据库或其他后端系统，增加了系统的负载。</p><p>原因：大量数据的过期时间相近或者Redis服务器故障宕机。</p><p>解决方法：对于第一种情况可以均匀设置过期时间、加互斥锁、后台更新缓存（让缓存“永久有效”，并将更新缓存的⼯作交由后台线程定时更新）等策略；对于第二种情况可以采用服务熔断或请求限流机制，还有构建Redis缓存高可用集群等方法。</p></li><li><p><strong>缓存击穿</strong>：指的是有大量请求查询一个缓存中不存在但数据库中存在的数据时，这些请求直接访问到数据库，增加数据库的负载。典型的场景就是一个热点数据过期被删除，但此时又有大量请求访问这个数据。</p><p>解决方法：缓存击穿是缓存雪崩的一个<strong>子集</strong>，可以采用互斥锁和后台更新缓存等策略。</p></li><li><p><strong>缓存穿透</strong>：指的是查询一个缓存和数据库都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。</p><p>原因：恶意攻击、业务误操作，缓存和数据库中的数据都被删除了。</p><p>解决方法：限制非法请求、对查询的数据，在缓存中设置空值、使用布隆过滤器过滤恶意请求。</p></li></ul><p><img src="/post/729cb619/image-20240326095110638.png" alt="image-20240326095110638"></p></li><li><p><strong>如何保证数据库和缓存的一致性？</strong></p><p><strong>Cache Aside</strong></p><ul><li><p><strong>原理:</strong> 先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据，更新数据的时候先把数据持久化到数据库，然后再让缓存失效。</p></li><li><p><strong>问题:</strong> 假如有两个操作一个更新一个查询，第一个操作先更新数据库，还没来及删除数据库，查询操作可能拿到的就是旧的数据，更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性;还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效,然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。</p></li><li><p><strong>可行性:</strong> 出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并目在写操作之后更新，概率比较低。</p></li></ul><p><strong>Read&#x2F;Write Through</strong></p><ul><li><p><strong>原理:</strong> Read&#x2F;Write Through原理是把更新数据库(Repository) 的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。</p></li><li><p><strong>Read Through:</strong> 就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。</p></li><li><p><strong>Write Through</strong>: 当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库 (这是一个同步操作)</p></li></ul><p><strong>Write Behind</strong></p><ul><li><p><strong>原理:</strong> 在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I&#x2F;O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。</p></li><li><p><strong>第二步失效问题:</strong> 这种可能性极小，缓存删除只是标记一下无效的软删除，可以看作不耗时间。如果会出问题，一般程序在写数据库那里就没有完成: 故意在写完数据库后，休眠很长时间再来删除缓存。</p></li></ul></li></ol><p><strong>先更新数据库，再删除缓存</strong></p><p><strong>先更新数据库，再删缓存</strong>这种情况不存在并发问题么？</p><p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><p>（1）缓存刚好失效</p><p>（2）请求A查询数据库，得一个旧值</p><p>（3）请求B将新值写入数据库</p><p>（4）请求B删除缓存</p><p>（5）请求A将查到的旧值写入缓存</p><p>ok，如果发生上述情况，确实是会发生脏数据。</p><p>然而，发生这种情况的概率又有多少呢？</p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，<strong>数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</strong></p><p><strong>先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！</strong></p><p>所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请<strong>先更新数据库，再删缓存!</strong></p>]]></content>
    
    
    <summary type="html">Redis常见面试问题</summary>
    
    
    
    <category term="Redis" scheme="https://threewood1.top/categories/Redis/"/>
    
    
    <category term="Interviews" scheme="https://threewood1.top/tags/Interviews/"/>
    
    <category term="Redis" scheme="https://threewood1.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>面试八股</title>
    <link href="https://threewood1.top/post/f4c4d599.html"/>
    <id>https://threewood1.top/post/f4c4d599.html</id>
    <published>2024-07-09T05:18:17.000Z</published>
    <updated>2024-11-05T09:17:47.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="Day1√"><a href="#Day1√" class="headerlink" title="Day1√"></a>Day1√</h3><p><strong>String、StringBuffer、StringBuilder的区别？</strong>**</p><p>这三者的区别主要集中在不可变性、线程安全和性能方面。</p><ol><li>String是<strong>不可变且线程安全</strong>的，因为String类型的字符串一旦创建就不可修改，因此，String类型的字符串是线程安全的，可以由多个线程同时调用，但是一旦对它有修改操作则会创建新的字符串对象，这会影响性能；</li><li>StringBuffer是<strong>可变且线程安全</strong>的，它在修改时是在同一对象上进行的，不会创建新的对象；因为StringBuffer的方法是<strong>同步</strong>的，所以它在使用时是线程安全的。由此可见StringBuffer适用于<strong>多线程</strong>环境，在单线程环境中使用会产生额外的性能开销；</li><li>StringBuilder是<strong>可变但线程不安全</strong>的，它的方法没有同步，因此线程不安全，适用于<strong>单线程</strong>环境的字符串操作。</li></ol><p>总之，String适用于不经常修改字符串的情况，StringBuffer和StringBuilder适用于经常修改的情况，并且要根据是否需要线程安全以及性能考量来选择。</p><p><strong>接口和抽象类的区别？</strong></p><p><strong>相同点：都不能直接被实例化，需要继承或实现后才能使用</strong></p><p><strong>不同点：</strong></p><ol><li><p>从<strong>定义</strong>上说：接⼝是⼀种抽象类型，它定义了⼀组方法（方法签名）但没有实现任何⽅法的具体代码。接口中的方法默认是抽象的，且接口中只能包含常量（static final变量）和抽象方法。抽象类是⼀个类，可以包含抽象方法和具体方法。抽象类中的抽象方法是没有实现的方法，而具体方法则包含实现代码。</p></li><li><p><strong>定义的关键字不同</strong>：定义的关键字不同(abstract&#x2F;Interface)，子类继承或实现的关键字也不同(extends&#x2F;implements)。</p></li><li><p><strong>类型扩展不同</strong>：抽象类是单继承，而接口是多实现。</p></li><li><p><strong>构造器</strong>：接口没有构造器，抽象类可以有构造器，当子类实例化时，会调用父类的构造器。</p></li><li><p><strong>访问修饰符</strong>：接口中的方法默认是public abstract，变量默认是public static final；抽象类中的抽象方法默认是protected，并且不能被private修饰。</p></li><li><p><strong>设计目的</strong>：</p><p><strong>接口用于定义规范</strong>，强调“行为”或“能力”。</p><p><strong>抽象类用于代码复用</strong>，提供通用的实现或基础功能，并且可以包含方法的具体实现。</p></li></ol><p><strong>Java常见的异常类有哪些？</strong>**</p><p>Java的异常类主要分为两大类：Error 和 Exception。Error表示程序无法处理的异常，通常是由JVM或底层系统引起的，如<strong>内存溢出</strong>或<strong>系统错误</strong>，而Exception则表示程序可以处理的异常，通常由程序员编写的代码引起的，并且可以通过异常处理机制捕获和处理。</p><p>Exception又分为两种主要类型：</p><ol><li><strong>Checked Exception（受检异常）</strong>：是指在<strong>编译时</strong>必须进行处理的异常。如果有一个方法抛出这类异常，则要么在方法类使用<strong>try-catch块</strong>捕获，要么在方法签名中使用<strong>throws关键字</strong>声明该异常。常见的Checked Exception包括<strong>IOException、SQLException</strong>、ClassNotFoundException、InterruptException等。</li><li><strong>Unchecked Exception（非受检异常，也称运行时异常）</strong>：是指在编译时不需要进行处理的异常，他们通常是由<strong>程序的逻辑错误</strong>引起的。例如<strong>NullPointerException</strong>、<strong>ArrayIndexOutOfBoundsException</strong>等。</li></ol><h3 id="Day2√"><a href="#Day2√" class="headerlink" title="Day2√"></a>Day2√</h3><p><strong>说一说Java面向对象三大特性？</strong>***</p><ol><li><strong>封装</strong>：指隐藏对象的内部细节，封装将对象内部状态（字段、属性）隐藏起来，并通过定义公共的方法（接口）来操作对象，外部代码只需要知道如何使用这些方法而无需了解内部实现，提高了代码的<strong>安全性</strong>和<strong>可维护性</strong>。</li><li><strong>继承</strong>：是一种通过已有的类（父类）创建新类（子类）的方式。子类可以继承父类的属性和方法，并且可以通过重写父类的方法来改变或扩展其行为，提高了代码的<strong>可重用性</strong>和<strong>可扩展性</strong>。</li><li><strong>多态</strong>：是指相同的操作或方法可以在不同的对象上产生不同的行为，通过方法的<strong>重载</strong>和<strong>重写</strong>来实现，提高了代码的<strong>灵活性</strong>。</li></ol><p><strong>说一说你对Java多态的理解？</strong>**</p><p>多态有两种形式：编译时多态和运行时多态。</p><ol><li><strong>编译时多态</strong>也称为静态多态，是通过方法的<strong>重载</strong>实现。编译器在编译时根据方法的签名（方法名和参数列表）来选择调用合适的方法。</li><li><strong>运行时多态</strong>也称为动态多态，是通过方法的<strong>重写</strong>实现。在运行时，通过对象的实际类型来确定调用的方法。</li></ol><p><strong>重写和重载的区别？</strong>**</p><p>重写和重载都是实现多态的方式，其中，<strong>重写是运行时多态，重载是编译时多态</strong>。</p><ol><li>重写发生在子类和父类之间，重写要求子类重写的方法与父类被重写的方法具有相同的参数列表（即参数类型、数量、顺序相同）和相同的返回类型。</li><li>重载是指在一个类中定义多个同名方法，这些方法的参数列表不同，返回类型可以相同也可以不相同。</li></ol><h3 id="Day3√"><a href="#Day3√" class="headerlink" title="Day3√"></a>Day3√</h3><p><strong>static和final的作用？</strong>**</p><ol><li><strong>static</strong>用于声明<strong>静态成员</strong>，即<strong>静态变量和方法</strong>。其中静态变量属于类而不属于实例对象，所有实例对象都共享相同的静态变量。静态方法也一样，属于类，可以通过类名直接调用而不需要创建类的实例。</li><li><strong>final</strong>用于修饰<strong>不可改变的变量、方法和类</strong>。对于变量，一旦赋值后就不可修改；对于方法，表示不可被子类重写；对于类，表示该类不能被继承。</li></ol><p><strong>java 中 &#x3D;&#x3D; 和 equals() 的区别？</strong>**</p><ol><li><strong>“&#x3D;&#x3D;”运算符</strong>是比较两个对象的引用（内存地址），即检查它们是否指向相同的内存地址。</li><li>**equals()**通常用于比较两个对象的内容。默认情况下equals()也是比较对象的引用，但是很多类都重写了这个方法以比较对象的内容。</li></ol><p><strong>为什么重写equals()时也要重写hashcode()方法？</strong>***</p><p>因为原始的equals()是比较两个对象的引用，但是我们经常用它比较两个对象是否一样，所以通常需要重写equals()。hashcode()方法返回的是对象的<strong>哈希码值</strong>，用于确定对象在哈希表中的<strong>存储位置</strong>。在集合类中，如果两个对象被认为是相等的，那么它们的哈希码应该相同。但是哈希码相等的两个对象不一定相等。遵守以下规定：</p><ol><li><strong>两个对象是相等的，即equals()返回为true，那么它们的哈希码也一定相同；</strong></li><li><strong>两个对象的哈希码相同，但这两个对象不一定相等。</strong></li></ol><h3 id="Day4√"><a href="#Day4√" class="headerlink" title="Day4√"></a>Day4√</h3><p><strong>Java的集合类有哪些，哪些是线程安全的，哪些是线程不安全的？</strong>***</p><p>Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection又派生出Set、List、Queue这三个子接口。所有Java集合类都是Set、List、Queue、Map这四个接口的实现类。其中，</p><p><strong>List接口</strong>：有序集合，允许重复元素。常见实现类有<strong>ArrayList、LinkedList、Vector</strong>等；</p><p><strong>Set接口</strong>：不允许重复元素的集合。常见实现类有<strong>HashSet、LinkedHashSet、TreeSet</strong>等；</p><p><strong>Queue接口</strong>：表示队列的数据结构。常见的实现类有<strong>LinckedList、PriorityQueue</strong>等；</p><p><strong>Map接口</strong>：表示键值对的集合。常见实现类有<strong>HashMap、LinkedHashMap、TreeMap、Hashtable</strong>等。</p><p><strong>线程安全的集合</strong>包括Vector、Hashtable、ConcurrentHashMap、Collections.synchronizedList、Collections.synchronizedSet 、Collections.synchronizedMap<strong>。</strong></p><p><strong>ArrayList 和 Array 有什么区别？</strong>***</p><ol><li><strong>大小和自动扩容</strong></li></ol><ul><li>Array数组在创建时必须指定大小，且大小是固定的。一旦数组被创建，其大小不能更改；</li><li>ArrayList是动态数组实现的，它的大小可以动态增长或缩小。在不断添加元素时，ArrayList 会自动进行扩容。</li></ul><ol start="2"><li><strong>支持泛型</strong></li></ol><ul><li>Array数组可以存储任何类型的元素，但不支持泛型；</li><li>ArrayList支持泛型，也可以指定存储的元素类型。</li></ul><ol start="3"><li><strong>存储对象</strong></li></ol><ul><li>Array数组可以直接存储基本类型数据，也可以存储对象；</li><li>ArrayList中只能存储对象。对于基本类型数据，需要使用其对应的包装类。</li></ul><ol start="4"><li><strong>集合功能</strong></li></ol><ul><li>Array数组是一个简单的数据结构，不提供额外的方法来对元素进行增删查改操作；</li><li>ArrayList是集合框架的一部分，提供了丰富的方法，如添加、删除、查找等。</li></ul><p><strong>ArrayList 和 LinkedList 的区别是什么?</strong>***</p><ol><li><strong>内部数据结构</strong></li></ol><ul><li>ArrayList基于动态数组实现；</li><li>LinkedList基于双向链表实现。</li></ul><ol start="2"><li><strong>遍历性能</strong></li></ol><ul><li>ArrayList支持快速的随机访问和遍历，因为可以直接通过索引访问元素；</li><li>LinkedList随机访问性能较差，因为必须从链表的头部或尾部开始遍历寻找目标索引。</li></ul><ol start="3"><li><strong>插入和删除</strong></li></ol><ul><li>ArrayList在末尾进行插入和删除操作是高效的，但在中间或开头插入和删除需要移动元素，性能较差。</li><li>LinkedList插入和删除元素的性能相对较好，特别是在链表中间或头尾插入和删除元素时。</li></ul><ol start="4"><li><strong>使用场景</strong></li></ol><ul><li>ArrayList适用于需要频繁随机访问元素，而对插入和删除操作要求不那么严格的场景。</li><li>LinkedList适用于需要频繁插入和删除操作，而对随机访问的需求较少的场景。</li></ul><p><strong>ArrayList的扩容机制？</strong>***</p><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。(不是原数组，而是新数组然后给予数组对象地址)。</p><p>默认情况下，<strong>新的容量会是原容量的1.5倍</strong>。新容量&#x3D;旧容量右移一位(相当于除于2)在加上旧容量</p><p>ArrayList 的底层是用动态数组来实现的。我们初始化一个ArrayList 集合并且没有指定容量时，其实它是个空数组，只有当我们添加第一个元素时，会<strong>初始化容量为10</strong>。当添加第11个元素时，便开始可以扩容了，新数组大小是旧数组的1.5倍，然后将旧数组的元素copy到新数组中，最后将ArrayList内部指向旧数组的引用更新为指向新数组的引用。</p><h3 id="Day5√"><a href="#Day5√" class="headerlink" title="Day5√"></a>Day5√</h3><p><strong>Java中的HashMap了解吗？HashMap 的底层实现是什么？</strong>***</p><p>在Java中，HashMap是Map接口的实现类，其数据是以键值对的形式存储，Key只允许有一个null值，value可以有多个null值；是线程不安全的。</p><p>在JDK1.8之前HashMap底层是由<strong>数组+链表</strong>的形式构成的；JDK1.8之后，底层是由<strong>数组+链表&#x2F;红黑树</strong>构成的。</p><p><strong>解决 Hash 冲突的方法有哪些？HashMap 是如何解决 hash 冲突的？</strong>***</p><p>解决hash冲突一般有<strong>开放定址法、链地址法、再哈希法、建立公共溢出区，</strong>其中HashMap使用链地址法解决哈希冲突。具体如下：</p><ol><li><strong>开放定址法：</strong>遇到hash冲突时，去寻找一个新的且空闲的哈希地址。寻找新的位置有以下几种方法：</li></ol><ol><li><p><strong>线性探测</strong>：当发生冲突时，线性地检查下一个槽位直到找到空闲地位置。（问题：会出现元素堆积现象）</p></li><li><p><strong>二次探测：</strong>与线性探测法不同的是每次增加的步长为平方数，以减少聚集现象。</p></li><li><p><strong>双重哈希：</strong>第一个哈希函数计算原始哈希值，使用第二个哈希函数来计算增量步长。发生冲突时，使用第一个哈希函数计算得到的值加上第二个哈希函数得到的步长来计算下一个探测位置。</p></li><li><p><strong>随机探测：</strong>使用随机的方式选择下一个探测位置。</p></li></ol><blockquote><p>二次探测的计算公式：<font style="color:rgb(44, 44, 54);">(</font><em><font style="color:rgb(44, 44, 54);">h</font></em><font style="color:rgb(44, 44, 54);">1(</font><em><font style="color:rgb(44, 44, 54);">key</font></em><font style="color:rgb(44, 44, 54);">)+</font><em><font style="color:rgb(44, 44, 54);">i</font></em><font style="color:rgb(44, 44, 54);">⋅</font><em><font style="color:rgb(44, 44, 54);">i</font></em><font style="color:rgb(44, 44, 54);">) mod </font><em><font style="color:rgb(44, 44, 54);">M</font></em></p><p>双重哈希的计算公式：<font style="color:rgb(44, 44, 54);">(</font><em><font style="color:rgb(44, 44, 54);">h</font></em><font style="color:rgb(44, 44, 54);">1(</font><em><font style="color:rgb(44, 44, 54);">key</font></em><font style="color:rgb(44, 44, 54);">)+</font><em><font style="color:rgb(44, 44, 54);">i</font></em><font style="color:rgb(44, 44, 54);">⋅</font><em><font style="color:rgb(44, 44, 54);">h</font></em><font style="color:rgb(44, 44, 54);">2(</font><em><font style="color:rgb(44, 44, 54);">key</font></em><font style="color:rgb(44, 44, 54);">)) mod </font><em><font style="color:rgb(44, 44, 54);">M</font></em><font style="color:rgb(44, 44, 54);">，其中</font><em><font style="color:rgb(44, 44, 54);">M</font></em><font style="color:rgb(44, 44, 54);"> 是哈希表的大小，</font><em><font style="color:rgb(44, 44, 54);">i</font></em><font style="color:rgb(44, 44, 54);"> 是冲突次数。</font></p></blockquote><ol start="2"><li><strong>再哈希法：</strong>构造多个不同的哈希函数，当发生冲突时就是用第二个、第三个。。。直到不发生冲突为止。</li><li><strong>链地址法：</strong>将所有哈希地址相同的元素都连接在一条链表中。</li><li><strong>建立公共溢出区：</strong>将哈希表分为基本表和溢出表，将发生哈希冲突的元素都放在溢出表中。</li></ol><p><strong>HashMap 的 put 方法流程？</strong>***</p><p>首先使用键所在类的hashCode()方法计算键的哈希码，然后对该哈希码进行扰动处理以减少哈希冲突的可能性。然后使用哈希码和当前哈希表的长度计算键值应该放入的位置。如果该位置为空，那么就创建一个新的键值对节点将元素放在此处。如果不为空，就需要遍历该位置上的链表，检查要插入的键是否已经存在。如果要插入的键存在，就修改键对应的值；如果要插入的键不存在，就在链表的末尾添加新的键值对节点。</p><p><strong>HashMap的扩容机制？</strong>***</p><p>HashMap的扩容机制在jdk1.8的前后有些许不同。</p><p>** jdk1.8 之前要满足以下两个条件：**</p><ol><li>存放新值的时候当前已有的元素个数必须大于等于一个阈值，该阈值等于当前table的容量 * 负载因子，初始化时table的长度为16，负载因子为0.75，那么阈值就是12。</li><li>存放新值的时候发生哈希碰撞。</li></ol><p>特点：先判断扩容，再添加（扩容使用头插法）</p><p><strong>jdk1.8之后满足以下条件之一：</strong></p><ol><li>当前存储的数量大于等于阈值。</li><li>当某个链表长度 &gt;&#x3D; 8，但是数组的长度 &lt; 64时。</li></ol><p>特点：先添加，再判断扩容（扩容使用尾插法）</p><p><strong>扩容之后对table的调整：</strong></p><p>扩容会创建一个新的数组，长度为原来的<strong>两倍</strong>。然后重新计算元素的位置并插入。</p><blockquote><p>链表与红黑树相互转换的条件：</p><p>链表转红黑树：某个链表长度 &gt; 8，且HashMap的数组长度 &gt;&#x3D; 64。</p><p>红黑树转链表：1. 扩容resize()时，红黑树拆分成的树的节点数 &lt;&#x3D; 6 个，则退化成链表。2. 删除元素remove()时，如果红黑树根节点root为空，或者root的左&#x2F;右子树为空，root.left.left为空，都会发生红黑树退化成链表。</p></blockquote><h3 id="Day6√"><a href="#Day6√" class="headerlink" title="Day6√"></a>Day6√</h3><p><strong>HashMap 为什么是线程不安全的？如何实现线程安全？</strong>***</p><p>主要原因是它的操作不是原子的，在多线程环境下，可能出现数据不一致的情况。</p><p>实现线程安全的HashMap，有以下几种方式：</p><ol><li><font style="color:rgb(51, 51, 51);">使用Hashtable代替Hashmap。</font></li><li><font style="color:rgb(51, 51, 51);">使用Map map &#x3D; </font><strong><font style="color:rgb(51, 51, 51);">Collections.synchronizedMap</font></strong><font style="color:rgb(51, 51, 51);">(new HashMap());</font></li><li><strong><font style="color:rgb(51, 51, 51);">使用ConcurrentHashmap。</font></strong></li></ol><p>​<font style="color:rgb(51, 51, 51);">在jdk1.8之前使用的是分段锁，它将哈希表分成多个段，每个段都有自己的锁。</font></p><p>​<font style="color:rgb(51, 51, 51);">在jdk1.8之后，ConcurrentHashMap通过CAS+synchronized实现线程安全，相比分段锁，锁的粒度更小。</font></p><ol start="4"><li><font style="color:rgb(51, 51, 51);">使用</font><strong><font style="color:rgb(51, 51, 51);">ReentrantLock</font></strong><font style="color:rgb(51, 51, 51);">锁来保证线程安全。</font></li></ol><p><strong>concurrentHashMap 如何保证线程安全？</strong>**</p><p><font style="color:rgb(51, 51, 51);">在jdk1.8之前使用的是</font><strong><font style="color:rgb(51, 51, 51);">分段锁</font></strong><font style="color:rgb(51, 51, 51);">，它将哈希表分成多个段（Segment数组），每个段都由一个ReetrantLock保护，默认Segment数组长度为16，这意味着最多可以支持16个线程并发写。</font></p><p><font style="color:rgb(51, 51, 51);">在jdk1.8之后，ConcurrentHashMap通过</font><strong><font style="color:rgb(51, 51, 51);">Node + CAS + synchronized</font></strong><font style="color:rgb(51, 51, 51);">实现线程安全，synchronized 只锁定当前链表或红黑树的首节点，相比分段锁，锁的粒度更小。</font></p><p><strong>HashMap和ConcurrentHashMap的区别？</strong>**</p><ol><li>HashMap不是线程安全的，而ConcurrentHashMap是线程安全的；</li><li>HashMap适用于单线程环境，不需要考虑同步操作；ConcurrentHashMap适用于多线程环境。</li></ol><h3 id="Day7√"><a href="#Day7√" class="headerlink" title="Day7√"></a>Day7√</h3><p><strong>HashSet 和 HashMap 的区别？</strong>**</p><ol><li><strong>实现接口：</strong>HashSet实现Set接口，HashMap实现Map接口；</li><li><strong>存储类型：</strong>HashSet存储无序不重复的元素，HashMap存储无序不重复的键值对；</li><li><strong>实现方式：</strong>HashSet底层使用HashMap实现，HashSet中的每个元素之际上都是HashMap的一个键，每个键映射的值为一个Object类型的静态对象，名为<code>PRESENT</code>。</li></ol><p><strong>HashMap 和 HashTable 的区别？</strong>**</p><ol><li><strong>线程安全：</strong>HashMap线程不安全。Hashtable是线程安全的，因为它在每个方法上添加 synchronized 关键字保证每个操作都是同步的。</li><li><strong>是否支持 null：</strong>HashMap允许一个键和任意数量的值为为null<strong>。</strong>而Hashtable不允许键或值为null。</li><li><strong>性能：</strong>HashMap因为没有同步开销，在单线程环境中性能更好。尽管Hashtable是同步的，但由于实现的效率低下，它在多线程环境下性能也可能比HashMap底。</li><li><strong>继承关系：</strong>HashMap继承自AbstractMap类，而Hashtable继承自Dictionary类，但它们都实现了Map接口。</li><li><strong>初始容量和扩容大小：</strong>HashMap初始容量为16，每次扩容都为原来的2倍；Hashtable初始容量为11，每次扩容都为原来的2倍+1。</li><li>迭代器：HashMap使用Iterator迭代器，Hashtable使用Enumerator迭代器，后者在迭代时如果Hashtable被修改，会抛出ConcurrentModificationException异常。</li></ol><p><strong>浅拷贝和深拷贝的区别？</strong>**</p><ul><li><strong>浅拷贝</strong>是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。</li><li><strong><font style="color:rgb(1, 1, 1);">深拷贝</font></strong><font style="color:rgb(1, 1, 1);">是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</font></li></ul><h3 id="Day8√"><a href="#Day8√" class="headerlink" title="Day8√"></a>Day8√</h3><p><strong>Java创建线程的方式？</strong>***</p><p><a href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！ (qq.com)</a></p><ol><li><strong>继承自Thread类：</strong>创建一个新的类，该类继承Thread类，然后重写run()方法定义要执行的任务，最后调用start()方法启动线程。</li><li><strong>实现Runnable接口：</strong>创建一个新的类，该类实现Runnable接口，然后重写run()方法，最后创建Thread对象时传递Runnable实例，并调用start()方法。</li><li><strong>实现Callable接口：</strong>创建一个新的类，该类实现 Callable 接口，实现 call()方法以定义线程要执行的任务，使用 ExecutorService 和 Future 来获取任务的结果。</li><li><strong>使用ExecutorService线程池</strong></li><li><strong>使用CompletableFuture类</strong></li></ol><p><strong>总结：这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。严格来说，Java 就只有一种方式可以创建线程，那就是通过new Thread().start()创建。不管是哪种方式，最终还是依赖于new Thread().start()。</strong></p><p><strong>线程 start 和 run 的区别？</strong>**</p><ul><li>start()方法用于启动一个新线程，并且会在新线程中执行run()方法的代码。</li><li>run()方法只是普通的方法调用，不会启动新线程，而是直接在当前线程中执行 run() 方法的内容。</li></ul><p><strong>sleep()和wait()的区别？</strong></p><ol><li><strong>所属类和调用方式</strong><br>wait()方法属于Object类，需要在synchronized块或方法中调用。<br>sleep()方法属于Thread类，可以在任何地方调用。</li><li><strong>对锁的处理机制</strong><br>wait()方法会释放锁，让出CPU资源，并且线程进入等待状态，直到被其他线程唤醒。<br>sleep()方法不会释放锁，线程会一直占用CPU资源，只是暂停执行一段时间。</li><li><strong>唤醒机制</strong><br>wait()方法需要被notify()或notifyAll()方法唤醒。<br>sleep()方法会自动苏醒，不需要其他线程唤醒。</li><li><strong>用途</strong><br>wait()方法通常用于线程间通信和协作，例如生产者-消费者模型。<br>sleep()方法通常用于让线程暂停执行一段时间，例如模拟延迟操作。</li><li><strong>异常处理</strong><br>wait()方法和sleep() 方法都可能会抛出InterruptedException异常，需要捕获或声明。</li><li><strong>总结</strong><br>wait()方法和sleep()方法都让线程暂停执行，但wait()方法会释放锁，sleep()方法不会释放锁。<br>wait()方法需要被notify()或notifyAll()方法唤醒，sleep()方法会自动苏醒。<br>wait()方法通常用于线程间通信和协作，sleep()方法通常用于让线程暂停执行一段时间。</li></ol><h3 id="Day9√"><a href="#Day9√" class="headerlink" title="Day9√"></a>Day9√</h3><p><strong>线程间的通信方式有些？</strong>***</p><p>线程间的通信方式主要有两种，分别是<strong>共享变量</strong>和<strong>消息传递</strong>。详细如下：</p><ol><li><strong>共享变量</strong>：通过共享变量（volatile修饰的变量），多个线程可以访问和修改同一个对象的状态。这种方法要求保证对共享变量的访问是线程安全的，通常通过同步（synchronized）代码块或方法来实现。</li><li><strong>消息传递</strong>：通过Object类的wait()、notify()、notifyAll()方法实现等待&#x2F;通知机制。这些方法必须在同步代码块或方法中调用，以确保对共享资源的访问是线程安全的。</li><li><strong>ReentrantLock和Condition</strong>：ReenTrantLock锁的实现原理虽然和synchronized不同，但是它和synchronized一样都是<strong>通过建立线程间的互斥访问临界区</strong>，来保证线程安全，实现线程间的通信。相比于synchronized使用Object类的三个方法来实现线程的阻塞和运行两个状态的切换，ReentrantLock使用Condition阻塞队列的await()、signal()、signalAll()三个方法来实现线程阻塞和运行两个状态的切换，进而实现线程间的通信。</li></ol><p><strong>你知道Java中有哪些锁吗？</strong>***</p><p><a href="https://www.cnblogs.com/coderacademy/p/18093724"><strong>阿里二面：Java中锁的分类有哪些？你能说全吗？ - 码农Academy - 博客园 (cnblogs.com)</strong></a></p><p><img src="/post/f4c4d599/1723792877398-faa03987-3963-45c0-bdfc-7138e6a1ac04.jpeg"></p><ol><li><strong>基于锁的获取与释放方式可以分为显示锁和隐式锁</strong></li></ol><ul><li>隐式锁：是通过synchronized关键字实现的一种线程同步机制。当一个线程进入被synchronized修饰的方法或代码块时，它会自动获得对象级别的锁，退出该方法或代码块时则会自动释放这把锁。</li><li>显示锁：显式锁是由 java.util.concurrent.locks.Lock 接口及其诸多实现类提供的同步机制，相较于通过synchronized关键字实现的隐式锁机制，显式锁提供了更为多样化的锁操作选项，包括但不限于支持线程在等待锁时可被中断、根据先后顺序分配锁资源的公平锁与非*<em><strong>公平锁机制，以及能够设定锁获取等待时间的定时锁功能。</strong>常见的显示锁有ReentrantLock、ReentrantReadWriteLock、StampedLock等。</em>*</li></ul><ol start="2"><li><strong>基于对资源的访问权限可以分为独占锁和共享锁</strong></li></ol><ul><li>独占锁：又称为<strong>排他锁或写锁</strong>，它确保在任一时刻最多只有一个线程可以获得锁并对受保护的资源进行访问或修改。独占锁可以通过synchronized关键字或ReentrantLock实现。</li><li>共享锁：也成为<strong>读锁</strong>，允许多个线程同时读取共享资源，但不允许任何线程修改资源。可通过读写锁（ReadWriteLock）中的读锁实现。</li></ul><ol start="3"><li><strong>基于锁的占有权是否可重入分为可重入锁和非可重入锁</strong></li></ol><ul><li>可重入锁：又称为<strong>递归锁</strong>，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁，从而避免了在递归调用或嵌套同步块中产生的死锁风险。其中synchronized实现的隐式锁和ReentrantLock都是可重入锁。</li><li>不可重入锁：与可重入锁相反。</li></ul><ol start="4"><li><strong>基于锁的公平性可以分为公平锁和非公平锁</strong></li></ol><ul><li>公平锁：在多线程环境中，锁的分配遵循“先请求先服务”的原则，即按照线程请求锁的顺序分配锁资源。公平锁可以有效避免某个线程长期得不到锁而导致的饥饿现象。在实现时可以通过向ReentrantLock中传入true参数获得。</li><li>非公平锁：与公平锁相反，不遵循“先请求先服务”的原则。非公平锁在某些场景下可以提高系统的并发性能，因为它允许刚释放锁的线程或者其他新到达的线程立刻获取锁，而不是强制排队等待，避免了线程切换的开销和等待时间。在实现时可以通过向ReentrantLock中传入false参数获得。</li></ul><ol start="5"><li><strong>基于对共享资源的访问方式可以分为悲观锁和乐观锁</strong></li></ol><ul><li>悲观锁：悲观锁认为在多线程环境下对共享资源的访问极有可能发生冲突，因此在访问资源之前，先尝试获取锁并锁定资源，直到该线程完成对资源的访问并释放锁，其他线程才能继续访问。</li><li>乐观锁：乐观锁认为在访问数据时，不会有其他线程来修改该数据。因此，乐观锁在操作数据的时候不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。乐观锁通过CAS算法实现。</li></ul><p>因此，悲观锁适合写操作较多且读操作较少的并发场景，乐观锁适用于读多写少的场景或者并发较少的场景。</p><ol start="6"><li><strong>基于锁的升级以及优化可分为偏向锁、轻量级锁和重量级锁</strong></li></ol><ul><li>偏向锁：偏向锁是指⼀段同步代码⼀直被⼀个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li><li>轻量级锁：轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁：重量级锁是指当锁为轻量级锁的时候，另⼀个线程虽然是自旋，但自旋不会⼀直持续下去，当自旋⼀定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><ol start="7"><li><strong>自旋锁：</strong>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，该线程不会进入阻塞状态，而是不断循环检查锁是否已经被释放，直到获取到锁为止。</li><li><strong>分段锁：</strong>是一种将数据或资源划分为多个段（segments），并对每个段分配单独锁的锁机制，可以减少锁的粒度从而减少锁冲突。在jdk1.8之前的ConcurrentHashMap就是使用分段锁来保证自身的线程安全。</li></ol><hr><h3 id="Day10√"><a href="#Day10√" class="headerlink" title="Day10√"></a>Day10√</h3><p><strong>说说你对 synchronized 的理解？</strong>***</p><p>synchronized关键字是Java中的一种同步锁，主要用于多线程环境下保证线程的安全性。当一个方法或一个代码块被synchronized修饰时，它被称为<strong>同步方法</strong>或<strong>同步代码块</strong>。这意味着每次只有一个线程可以进入该方法或代码块，其他线程必须等待，直到当前线程执行完毕并释放锁。synchronized具有<strong>原子性、可见性、有序性和可重入性</strong>。</p><p><strong>synchronized 和 Lock 的区别是什么？</strong>**</p><p>synchronized和Lock都是Java中用于实现线程同步的机制，都可以保证线程安全。它们的区别主要如下：</p><ol><li><strong>来源不同：</strong>synchronized是Java内置的一个关键字，而Lock是一个接口，它下面有很多实现类，例如ReentrantLock就是它的一个实现类。</li><li><strong>用法和获取方式不同：</strong></li></ol><ul><li><p><strong>synchronized</strong>可以写在需要同步的对象、方法或者是特定代的码块中，是隐式获取锁。主要有两种用法，一种是把synchronized修饰在方法上，一种是把synchronized修饰在代码块上。</p></li><li><p><strong>Lock</strong>控制锁的粒度是通过lock()方法和unlock()方法来实现的，是显示地获取锁，这两个方法之间地代码是线程安全的。</p><p>由此可见，Lock比synchronized在使用上相对来说要更加灵活一些。Lock可以自主地去决定什么时候加锁，什么时候释放锁。只需要调用lock()和unlock()这两个方法就可以了。需要注意的是，为了避免死锁，一般我们<strong>unlock()方法写在finally块中</strong>，而synchronized 只有代码块执行结束或者代码抛出异常时才会释放锁。</p></li></ul><ol start="3"><li><strong>性能区别：</strong>在低并发情况下，synchronized 的性能优于 Lock，因为 Lock 需要显式地获取和释放锁，而 synchronized 是在 JVM 层面实现的；在高并发的情况下，Lock 的性能要远远优于 synchronized，因为 Lock 可以更好地支持高并发和读写分离的场景。</li><li><strong>使用场景不同：</strong>synchronized和Lock在一般情况下没有什么区别，但是在非常复杂的同步应用中，建议使用Lock。因为synchronized只提供了非公平锁的实现，而Lock提供了公平所和非公平锁的机制。</li></ol><blockquote><p><strong>公平锁</strong>是指线程竞争锁资源的时候，如果已经有其他线程正在排队或者等待锁释放，那么当前竞争锁的线程是无法去插队的。</p><p><strong>非公平锁</strong>就是不管是否线程再排队等待锁，它都会去尝试竞争一次锁。</p></blockquote><p><strong>synchronized 和 ReentrantLock 的区别是什么？</strong>**</p><p>在Java中，synchronized（内置锁）和 ReentrantLock（可重入锁）是两种常用的锁。它们的区别如下：</p><ol><li>用法和获取方式不同：同上</li><li>锁的类型不同：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。</li><li>使用场景：同上</li><li>锁的灵活性：ReentrantLock相对于Synchronized提供了更多的功能。例如，可以设置超时时间，以避免线程无限期地等待锁；可以判断锁是否被其他线程持有，从而进行相应的处理；还可以使用Condition类实现线程等待&#x2F;通知机制，以支持更复杂的并发控制。</li></ol><h3 id="Day11√"><a href="#Day11√" class="headerlink" title="Day11√"></a>Day11√</h3><p><strong>volatile 关键字的作用有哪些？</strong>***</p><p>volatile 是 Java 中的一个关键字，用于修饰变量，它的主要作用是保证变量在多线程环境下的<strong>可见性</strong>和<strong>禁止指令重排序</strong>，但它不保证原子性。</p><ul><li><strong>可见性</strong>：指当一个线程修改了一个被volatile关键字修饰的变量时，其他线程能立即看到修改的值。</li><li><strong>禁止指令重排序：</strong>指确保对volatile变量的读写操作不会被编译器或处理器随意重新排序，从而确保了程序执行的有序性。</li><li><strong>不保证原子性：</strong>volatile不保证操作的原子性。synchronized可以同时保证可见性和原子性。</li></ul><blockquote><ol><li>可见性（Visibility）</li></ol><ul><li>在多线程环境中，线程通常会将变量的值从主内存复制到自己的工作内存（CPU 缓存）中进行操作。如果一个线程修改了变量的值，但其他线程仍然从自己的工作内存中读取该变量的旧值，就会导致数据不一致的问题。</li><li>当一个变量被声明为 volatile 时，Java 内存模型确保该变量的所有读操作都会直接从主内存中读取，而写操作会直接写入主内存。因此，volatile 变量对所有线程都是可见的。</li></ul><ol start="2"><li>有序性（Ordering）</li></ol><ul><li>Java 内存模型允许编译器和处理器对指令进行重排序，以优化性能。但这种重排序可能导致线程间的执行顺序不一致，从而引发潜在的并发问题。</li><li>使用 volatile 修饰的变量可以禁止指令重排序。具体来说，Java 在 volatile 变量的读&#x2F;写操作时会插入内存屏障（Memory Barrier），从而保证在 volatile 变量的操作前后的代码执行顺序不会被重排序。</li></ul></blockquote><p><strong>volatile 与 synchronized 的对比？</strong>**</p><ol><li><strong>机制与用途</strong></li></ol><ul><li>synchronized：它是Java的一个关键字，用于提供线程间的同步机制。当一个线程进入一个由synchronized修饰的代码块或方法时，它会获取一个监视器锁（monitor lock），这保证了同一时间只有一个线程可以执行这段代码。其主要用途是确保数据的一致性和线程安全性。</li><li>volatile：这是Java的一个关键字，用于修饰变量。volatile的主要作用是确保变量在多线程环境中的<strong>可见性和有序性</strong>，即当一个线程修改了一个volatile变量的值，其他线程能够立即看到这个修改。此外，它还可以<strong>防止指令重排序</strong>。但是，volatile并<strong>不能保证复合操作的原子性</strong>。</li></ul><ol start="2"><li><strong>原子性：</strong></li></ol><ul><li>synchronized：它可以保证被其修饰的代码块的原子性，即这段代码在执行过程中不会被其他线程打断。</li><li>volatile：只能保证单个读写操作的原子性，对于复合操作（如自增、自减等）则无法保证原子性。</li></ul><ol start="3"><li><strong>互斥性：</strong>synchronized：提供了互斥性，即同一时间只有一个线程可以执行被其修饰的代码块或方法。volatile：不提供互斥性，只是确保变量的可见性。</li><li><strong>性能：</strong>volatile通常比synchronized更轻量级，因为它不涉及锁的获取和释放。但是，这也意味着它提供的同步级别较低。</li></ol><p><strong>JDK8新特性？</strong>***</p><ol><li><strong>Lambda表达式：</strong>Lambda表达式是一个匿名函数，Java8允许把函数作为参数传递进方法中。</li><li><strong>Stream API：</strong>提供了一种处理集合数据流的方式，支持并行操作和链式调用，简化了集合数据的过滤、映射、排序等操作。它可以提高代码的可读性和简洁性。</li><li><strong>函数式接口：</strong>包含一个抽象方法的接口，可以使用<code>@FunctionalInterface</code>注解来明确表示它是一个函数式接口，这样就可以用lambda表达式或方法引用来实现。</li><li><strong>默认方法：</strong>在接口中允许定义具有具体实现的方法，从而解决了接口演化时向后兼容的问题。</li><li><strong>Optional类：</strong>用于防止空指针异常，提供了更好的空值处理方式，避免了NullPointerException。</li><li><strong>新的日期和时间API：</strong>包括<code>java.time</code>包，提供了一系列全新的日期、时间、时区以及持续时间的API，替代了旧的<code>java.util.Date</code>和<code>Calendar</code>类。</li></ol><h3 id="Day12√"><a href="#Day12√" class="headerlink" title="Day12√"></a>Day12√</h3><p><strong>什么是线程池？为什么需要线程池？</strong>**</p><p><strong>线程池（Thread Pool）</strong> 是一种管理和重用线程的机制，用于提高多线程应用程序的性能和效率。线程池在程序启动时创建一定数量的线程，将它们放入池中，并在需要时重复使用这些线程，而不是为每个任务都创建新线程。这有助于减少线程创建和销毁的开销，提高资源利用率，并且可以更好地控制并发线程数量。 </p><ul><li><strong>降低资源消耗：</strong>通过重复利用已创建的线程<strong>减少线程创建和销毁造成的消耗</strong>。</li><li><strong>提高响应速度：</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性：</strong>线程池可以限制并发线程的数量，防止系统过载，提高系统稳定性。</li></ul><p><strong>常见的几种线程池：</strong></p><ol><li><strong>FixedThreadPool：固定大小的线程池</strong>，可控制线程最大并发数，超过核心线程数的任务将会进入队列排队等待执行，<strong>通常用于负载较重且稳定的场景</strong>。</li><li><strong>CacheThreadPoll： 可根据实际情况调整线程数量的线程池。</strong>线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</li><li><strong>SingleThreadExecutor：单线程的线程池</strong>，只有一个工作线程，保证所有任务按照提交顺序执行，常用于执行串行化任务或者需要顺序执行的任务。</li><li><strong>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池</strong>。</li></ol><p><strong>说一说线程池有哪些常用参数？</strong>**</p><ol><li><strong>corePoolSize（核心线程数）：线程池维护的最小线程数量，核心线程创建后不会被回收</strong>（注意：设置allowCoreThreadTimeout&#x3D;true后，空闲的核心线程超过存活时间也会被回收）。大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收。</li><li><strong>maximumPoolSize（线程池最大线程数）：线程池允许创建的最大线程数量</strong>。当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。</li><li><strong>keepAliveTime（空闲线程存活时间）：当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收。</strong>可被回收的线程：设置allowCoreThreadTimeout&#x3D;true的核心线程；大于核心线程数的线程（非核心线程）。</li><li><strong>unit（空闲线程存活时间单位）：keepAliveTime的时间单位。</strong></li><li><strong>workQueue（工作队列）：存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在工作队列，任务调度时再从队列中取出任务。</strong>它仅仅用来存放被execute()方法提交的Runnable任务。工作队列实现了BlockingQueue接口，常见的工作队列有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue。</li><li><strong>threadFactory（线程工厂）：创建线程的工厂，可以设定线程名、线程编号等。</strong></li><li><strong>handler（拒绝策略）：当线程池线程数已满，并且工作队列达到限制，新提交的任务使用拒绝策略处理。可以自定义拒绝策略，拒绝策略需要实现RejectedExecutionHandler接口。</strong></li></ol><p><strong>线程池的拒绝策略？</strong></p><p>若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><ol><li><strong>AbortPolicy</strong></li></ol><p>第1种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException的RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p><ol start="2"><li><strong>DiscardPolicy</strong></li></ol><p>第2种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p><ol start="3"><li><strong>DiscardOldestPolicy</strong></li></ol><p>第3种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</p><ol start="4"><li><strong>CallerRunsPolicy</strong></li></ol><p>第4种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p><p>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</p><p>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</p><p><strong>BIO、NIO、AIO 的区别？</strong>**</p><ol><li><strong>BIO：</strong>同步阻塞 I&#x2F;O 模型中，当一个线程执行 I&#x2F;O 操作时，它会被阻塞直到 I&#x2F;O 操作完成。这会导致线程无法执行其他任务。</li></ol><p><strong>适用场景：</strong>适用于连接次数比较少、并发不高的场景，例如传统的 Socket 编程。</p><ol start="2"><li><strong>NIO：</strong>同步非阻塞 I&#x2F;O 模型中，一个线程执行一个 I&#x2F;O 操作时不会等待，而是继续执行其他任务，线程需要通过轮询（polling）或者选择器（Selector）来检查哪些连接已经准备好进行 I&#x2F;O 操作。核心组件包括通道（Channel）、缓冲区（Buffer）和选择器（Selector）</li></ol><p><strong>适用场景：</strong>适用于高并发、连接次数比较多的场景。</p><blockquote><ul><li>Channel(通道)：通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</li><li>Buffer(缓冲区)：Buffer是一个对象，它包含一些要写入或者要读出的数据。在面向流的I&#x2F;O中，可以将数据写入或者将数据直接读到Stream对象中。</li><li>Selector(选择器)：选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</li></ul></blockquote><ol start="3"><li><strong>AIO：</strong>异步非阻塞 I&#x2F;O 模型是在 NIO 上进一步发展的， 提供了异步操作的能力。在进行 I&#x2F;O 操作时，可以注册一个回调函数，当IO操作完成时，系统会调用回调函数通知应用程序。</li></ol><p><strong>适用场景：</strong>适用于处理大量并发连接的场景，并且希望充分利用系统资源。</p><blockquote><p> <strong>举例：类比烧开水</strong></p><ul><li>BIO相当于在烧一壶开水，我一直在这一壶水面前等待水烧开，只有水烧开了我才能去做别的事情。</li><li>NIO相当于我烧一排开水，我不断的检查有没有开水烧开，等到所有开水烧开我才能去别的事情。</li><li>AIO相当于我把开水交给另一个人去烧开，然后我去做别的事情了，当水烧开了这个人会就会过来通知我水已经烧开了。</li></ul></blockquote><h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><p><strong>Java内存区域？</strong>**</p><p><strong>有哪些垃圾回收算法？</strong>***</p><p><strong>有哪些垃圾回收器？</strong>***</p><h3 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h3><p><strong>介绍一下什么是强引用、软引用、弱引用、虚引用？</strong>**</p><p><a href="https://segmentfault.com/a/1190000042313862"><strong>Java四大引用详解：强引用、软引用、弱引用、虚引用 - BAT架构技术与大厂面试 - SegmentFault 思否</strong></a></p><p>等级： 强 &gt; 软 &gt; 弱 &gt; 虚</p><p><strong>强引用</strong>是Java中声明对象的默认引用方式，也是使用最多的一种方式，请记住不管内存紧张也罢，不足也罢，gc永不回收强引用的对象， 即使 jvm 出现(内存溢出错误)OutOfMemoryError，使程序停止，也不会回收对象来提高内存。</p><p><strong>软引用</strong>是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><p><strong>弱引用</strong>的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><p><strong>虚引用</strong>是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示。</p><blockquote><p> <strong>引用队列</strong>可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p></blockquote><p><strong>类加载机制介绍一下？</strong>**</p><p><strong>双亲委派机制是什么？</strong>**</p><h3 id="Day14-5√"><a href="#Day14-5√" class="headerlink" title="Day14.5√"></a>Day14.5√</h3><p><strong>Spring和SpringBoot的区别？*</strong>*</p><ol><li>Spring</li></ol><p>Spring 是一个全面的 Java 企业级应用程序开发框架，提供了广泛的功能，包括依赖注入、 AOP (面向切面编程)、事务管理等。</p><ol><li>SpringMVC</li></ol><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring <strong>快速构建 MVC 架构的 Web 程序的能力</strong>。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。主要关注于处理 Web 请求、管理用户会话、控制应用程序流程等。</p><ol><li>SpringBoot</li></ol><p>Springboot 是一个微服务框架，延续了 Spring 框架的核心思想IOC和AOP，<strong>简化了应用的开发和部署</strong>。 Spring Boot 是为了简化 Spring 应用的创建、运行、调试、部署等而出现的，提供<strong>约定大于配置</strong>的方式，使用它可以做到专注于 Spring 应用的开发，而无需过多关注 XML 的配置。使得构建独立的、自包含的Spring 应用程序变得更加容易。简而言之， Spring 是一个全面的框架，Spring MVC 是 Spring 框架的一部分，专注于Web应用程序开发，而 Spring Boot 是基于Spring的微服务框架，旨在简化和加速 Spring 应用程序的开发。</p><p><strong>说一说你对Spring AOP的理解？</strong>**</p><p><a href="https://blog.csdn.net/cy973071263/article/details/105429453">【Spring】面试官：谈一谈你对spring AOP的理解_spring 面试中,谈谈你对spring aop的理解-CSDN博客</a></p><p>AOP称为面向切面编程。AOP是一种编程思想，是对面向对象编程（OOP）的一种补充。传统OOP开发中的代码逻辑是自上而下的，而在开发过程会产生一些横切性的问题，例如事务管理、记录日志、权限控制等。这些横切性的问题和主业务逻辑关系不大，但是会散落到代码的各个部分，难以维护。AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。提到了代码的可重用性和可维护性。</p><p><strong>AOP实现</strong>的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和Cglib动态代理。如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</p><blockquote><p>这里顺带总结一下 AOP 关键术语（不理解也没关系，可以继续往下看）：</p><ul><li><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</li><li><strong>切面（Aspect）</strong>：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</li><li><strong>连接点（JoinPoint）</strong>：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</li><li><strong>通知（Advice）</strong>：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。</li><li><strong>切点（Pointcut）</strong>：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 <code>execution(* com.xyz.service..*(..))</code>匹配 <code>com.xyz.service</code> 包及其子包下的类或接口。</li><li><strong>织入（Weaving）</strong>：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（AspectJ）和运行期织入（AspectJ）。</li></ul></blockquote><p><strong>Spring AOP的通知类型有哪些？</strong>**</p><p>Spring AOP有五种通知类型，分别是前置通知<code>Before</code>、返回通知<code>After returning</code>、环绕通知<code>Around</code>、异常通知<code>After throwing</code>、后置通知<code>After</code>。</p><ul><li><strong>前置通知</strong><code>**Before**</code><strong>：</strong>在连接点前面执行但不会影响连接点的执行，除非它引发异常。</li><li><strong>返回通知</strong><code>**After returning**</code><strong>：</strong>在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。</li><li><strong>环绕通知</strong><code>**Around**</code><strong>：****这是最强大的通知类型</strong>。环绕通知可以在方法调用前后完成自定义行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或者抛出异常将执行结束。</li><li><strong>异常通知</strong><code>**After throwing**</code><strong>：</strong>在连接点抛出异常后执行。</li><li><strong>后置通知</strong><code>**After(finally)**</code><strong>：</strong>在连接点执行完成后执行，不管连接点是正常执行完成，还是抛出异常，都会执行通知内容。</li></ul><p><strong>Spring中AOP失效的场景*</strong>*</p><p><a href="https://developer.aliyun.com/article/1453877">Spring的AOP失效场景详解-阿里云开发者社区</a></p><ol><li><strong>非Spring管理的对象</strong>：Spring的AOP只能拦截由Spring容器管理的Bean对象。如果您使用了非受Spring管理的对象，则AOP将无法对其进行拦截。</li><li><strong>同一个Bean内部方法调用</strong>：如果一个Bean内部的方法直接调用同一个Bean内部的另一个方法，AOP将无法拦截这个内部方法调用。因为AOP是基于代理的，只有通过代理对象才能触发AOP拦截。</li><li><strong>静态方法</strong>：Spring的AOP只能拦截非静态方法。如果您尝试拦截静态方法，AOP将无法生效。</li><li><strong>final方法</strong>：AOP无法拦截final方法。final方法是不可重写的，因此AOP无法生成代理对象来拦截这些方法。直接在对象内部调用方法：如果您直接在对象内部调用方法而不通过代理对象，AOP将无法拦截。因此，建议始终通过代理对象调用方法以确保AOP的生效。</li><li><strong>异步方法</strong>：对于使用Spring的异步特性（如@Async注解）的方法，AOP拦截器可能无法正常工作。这是因为异步方法在运行时会创建新的线程或使用线程池，AOP拦截器无法跟踪到这些新线程中的方法调用。</li></ol><p><strong>说一说你对 Spring中IOC的理解？</strong>***</p><p>IOC称为控制反转。IOC是一种设计思想，是指在开发中将设计好的对象交给容器管理，而不是传统的在对象内部直接控制，这样会大大降低代码的耦合性。有了IOC容器后，我们把创建和查找依赖对象的控制权交给容器，容器初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象进行依赖注入（DI）。</p><p><strong>你会如何实现一个IOC容器？*</strong>*</p><ol><li>先准备一个容器对象，map结构；</li><li>进行配置文件的读取，或注解的解析操作,将需要创建的bean封装为BeanDefinition对象存储在容器中；</li><li>容器将封装好的 beanDefiniotn 对象,通过反射进行实例化操作；</li><li>通过依赖注入注入给类中的对应属性值进行设置，完成整个对象的创建，变成一个完成的bean对象，存储在某个map结构中；</li><li>通过容器对象来获取对象，进行对象的获取和逻辑处理工作；</li><li>提供销毁操作，当对象不用，或者容器关闭的时候，将无用的对象进行销毁。</li></ol><p><strong>依赖注入的三种方式</strong>***</p><p><a href="https://developer.baidu.com/article/details/3254022">Spring基础——深入理解依赖注入的三种方式-百度开发者中心 (baidu.com)</a></p><ol><li><strong>构造函数注入</strong></li></ol><p>构造函数注入是通过在类的构造函数中声明依赖项来实现的。当Spring容器创建对象时，它会使用构造函数参数来注入依赖项。这种方式被认为是最佳实践，因为它可以确保依赖项在对象创建时就被初始化，并且对象在整个生命周期中始终保持不变。</p><p><font style="color:rgb(25, 26, 36);">优点：</font></p><ul><li>确保依赖项在对象创建时就被初始化。</li><li><font style="color:rgb(25, 26, 36);">可以设置依赖项为final，确保它们不会被修改。</font></li><li><font style="color:rgb(25, 26, 36);">支持不可变对象。</font></li></ul><p><font style="color:rgb(25, 26, 36);">缺点：</font></p><ul><li><font style="color:rgb(25, 26, 36);">如果类有很多依赖项，构造函数可能会变得很长且难以阅读。</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyRepository repository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Setter方法注入</strong></li></ol><p>Setter方法注入是通过在类中提供setter方法来注入依赖项的。Spring容器会调用这些setter方法来设置依赖项的值。这种方式更加灵活，因为可以在对象创建后的任何时候注入依赖项。</p><p><font style="color:rgb(25, 26, 36);">优点：</font></p><ul><li><font style="color:rgb(25, 26, 36);">可以在对象创建后的任何时候注入依赖项。</font></li><li><font style="color:rgb(25, 26, 36);">可以重新配置已存在的对象。</font></li></ul><p><font style="color:rgb(25, 26, 36);">缺点：</font></p><ul><li><font style="color:rgb(25, 26, 36);">可能导致对象状态的不确定性，因为依赖项可以在任何时候被更改。</font></li><li><font style="color:rgb(25, 26, 36);">不支持不可变对象。</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRepository</span><span class="params">(MyRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>字段(Field)注入</strong></li></ol><p>字段注入是通过在类的字段上使用注解来实现的。Spring容器会自动注入依赖项到这些字段中。这种方式相对简单，但通常不是最佳实践，因为它可能会导致代码难以阅读和维护。</p><p><font style="color:rgb(25, 26, 36);">优点：</font></p><ul><li><font style="color:rgb(25, 26, 36);">代码简单明了，易于实现。</font></li></ul><p><font style="color:rgb(25, 26, 36);">缺点：</font></p><ul><li><font style="color:rgb(25, 26, 36);">不支持不可变对象。</font></li><li><font style="color:rgb(25, 26, 36);">可能导致代码难以阅读和维护。</font></li><li><font style="color:rgb(25, 26, 36);">依赖项的生命周期可能不明确。</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository repository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Resource和@Autowired的区别是什么？</strong>**</p><p><strong>共同点：</strong><code>@Autowired</code>和<code>@Resource</code>都是 Spring&#x2F;Spring Boot 项目中，用来进行依赖注入的注解。在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</p><p><strong>区别：</strong></p><ol><li><strong>来源不同</strong>：@Resource是Java定义的注解，来自于 JSR-250 （Java 250 规范提案）；而@Autowired注解是Spring框架提供的。</li><li><strong>依赖查找的顺序不同</strong>：@Resource注解默认按照名称进行匹配查找，如果找不到，则按照类型进行匹配。而@Autowired注解默认是按照类型进行匹配，如果出现多个类型一致的实例对象，则需要指定名称。</li><li><strong>支持参数不同</strong>：@Autowired 只支持设置一个 required 的参数，required属性表示是否必须注入该属性；@Resource 支持包括 name 和 type 等 7 个参数。</li><li><strong>依赖注入的用法不同</strong>：@Autowired 既支持构造方法注入，又支持 Field 注入和 Setter 注入，而 @Resource 只支持 Field 注入和 Setter 注入。</li></ol><h3 id="Day15√"><a href="#Day15√" class="headerlink" title="Day15√"></a>Day15√</h3><p><strong>Bean的作用域？</strong>**</p><p>在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。目前Spring Bean的作用域主要有六种。</p><table><thead><tr><th><strong><font style="color:#000000;">Scope</font></strong></th><th><strong><font style="color:#000000;">Description</font></strong></th></tr></thead><tbody><tr><td>singleton</td><td>（默认的）在Spring IoC容器中，一个bean定义对应只会有唯一的一个bean实例，bean以单例方式存在。</td></tr><tr><td>prototype</td><td>一个bean定义可以有多个bean实例。每次从容器中调用bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td></tr><tr><td>request</td><td>一个bean定义对应于单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个bean实例，且该实例仅在这个HTTP请求的生命周期里有效。该作用域仅适用于WebApplicationContext环境。</td></tr><tr><td>session</td><td>一个bean定义对应于单个HTTP Session的生命周期。也就是说，每个HTTP Session都有一个bean实例，且该实例仅在这个HTTP Session的生命周期里有效。该作用域仅适用于WebApplicationContext环境。</td></tr><tr><td>application</td><td>一个bean定义对应于单个ServletContext的生命周期。该作用域仅适用于WebApplicationContext环境。</td></tr><tr><td>websocket</td><td>一个bean 定义对应于单个websocket 的生命周期。该作用域仅适用于WebApplicationContext环境。</td></tr></tbody></table><p><strong>Bean的生命周期？</strong>**</p><p>在 Java 中，Bean 就是一个由 Spring IOC 容器初始化、管理和维护的普通Java对象。通过 Spring 容器，我们可以方便的创建和获取这些对象，并且可以配置它们的行为与属性。它的生命周期如下：</p><ol><li><strong>创建 Bean 的实例：实例化一个 Bean 对象。</strong>Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</li><li><strong>Bean 属性赋值&#x2F;填充：为 Bean 设置相关属性和依赖</strong>，例如<code>@Autowired</code>等注解注入的对象、<code>@Value</code>注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li><li><strong>Bean 初始化：</strong></li></ol><ul><li>如果 Bean 实现了<code>BeanNameAware</code>接口，调用<code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了<code>BeanClassLoaderAware</code>接口，调用<code>setBeanClassLoader()</code>方法，传入<code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了<code>BeanFactoryAware</code>接口，调用<code>setBeanFactory()</code>方法，传入<code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他<code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessBeforeInitialization()</code>方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含<code>init-method</code>属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessAfterInitialization()</code>方法。</li></ul><ol start="4"><li><strong>销毁 Bean：</strong>销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。</li></ol><ul><li>如果 Bean 实现了<code>DisposableBean</code>接口，执行<code>destroy()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含<code>destroy-method</code>属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code>注解标记 Bean 销毁之前执行的方法。</li></ul><p><img src="/post/f4c4d599/1724750996737-f9b18f2b-36d0-49fb-afa6-0ca1d40dc58a.png"></p><p><strong>Spring循环依赖是怎么解决的？*</strong>*</p><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">Spring常见面试题总结 | JavaGuide</a></p><p><strong>定义：循环依赖</strong>是指 Bean 对象循环引用，是两个或多个 Bean 之间相互持有对方的引用。Spring2.6以前允许出现循环依赖，但是这是一种种糟糕的<strong>设计缺陷</strong>，所以之后的Spring版本不建议出现循环依赖。</p><p><strong>Spring创建Bean的流程：</strong></p><ol><li>先去 <strong>一级缓存</strong> <code>singletonObjects</code> 中获取，存在就返回；</li><li>如果不存在或者对象正在创建中，于是去 <strong>二级缓存</strong> <code>earlySingletonObjects</code> 中获取；</li><li>如果还没有获取到，就去 <strong>三级缓存</strong> <code>singletonFactories</code> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li></ol><p>Spring的三级缓存包括：</p><blockquote><ol><li><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</li><li>二级缓存（earlySingletonObjects）<strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</strong></li><li>三级缓存（singletonFactories）**：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</li></ol></blockquote><p><strong>Spring的解决循环依赖方法：</strong></p><p>Spring框架使用<strong>三级缓存</strong>来解决循环依赖的问题，确保了即使循环依赖的情况存在也能正确创建Bean。也就是说，如果发生了循环依赖的话，就去<strong>三级缓存</strong><code>singletonFactory</code>中拿到三级缓存中存储的<code>ObjectFactory</code>并调用它的<code>getObject()</code>方法来获取这个循环对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p><p><strong>缺点：</strong> 增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）。并且，还有少部分情况是不支持循环依赖的，比如非单例的 bean 和<code>@Async</code>注解的 bean 无法支持循环依赖。</p><p><strong>只用两级缓存够吗？</strong> </p><blockquote><p>在没有 AOP 的情况下，确实可以只使用一级和三级缓存来解决循环依赖问题。但是，当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。</p></blockquote><p><strong>@Lazy注解解决解决循环依赖</strong></p><p><code>@Lazy</code>用来标识类是否需要<strong>懒加载&#x2F;延迟加载</strong>，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。Spring Boot 2.2 新增了全局懒加载属性，开启后全局 bean 被设置为懒加载，需要时再去创建。</p><p><strong>不建议使用全局懒加载！</strong>全局懒加载会让bean第一次使用的时候加载会变慢，并且迟应用程序问题的发现（当 Bean 被初始化时，问题才会出现）。</p><blockquote><p>首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</p><p>由于在 A 上标注了 @Lazy 注解，因此 Spring 会去创建一个 B 的<strong>代理对象</strong>，将这个代理对象注入到 A 中的 B 属性；</p><p>之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</p></blockquote><p><strong>Spring中用到了那些设计模式？</strong>**</p><p><a href="https://blog.csdn.net/qq_33204709/article/details/136465784">Spring(22) Spring中的9种设计模式_spring有些什么设计模式-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhangerqing/article/details/8194653">Java之美-从菜鸟到高手演变之设计模式_java 设计模式 菜鸟-CSDN博客</a></p><ol><li><strong>工厂设计模式：</strong>Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li><strong>代理设计模式：</strong>Spring AOP 就是基于动态代理的实现。为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>单例设计模式：</strong>Spring 中的 Bean 默认都是单例的。确保某一个类只有一个实例。<a href="https://www.cnblogs.com/gozhuyinglong/p/14401630.html">单例模式：5种实现方式 - 码农StayUp - 博客园</a></li><li><strong>模板方法模式：</strong>Spring中jdbcTemplate、hibernateTemplate 等以Template结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式：</strong>我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。<strong>Spring 事件驱动模型就是观察者模式很经典的一个应用。</strong></li><li><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li></ol><h3 id="Day16√"><a href="#Day16√" class="headerlink" title="Day16√"></a>Day16√</h3><p><strong>描述一下 SpringMVC 的执行流程？</strong>**</p><ol><li>客户端发送请求：客户端（浏览器）发送请求到前端控制器（DispatcherServlet），请求被Servlet拦截以后，转发给SpringMVC框架</li><li>DispatcherServlet处理请求：SpingMVC中的DispatcherServlet核心控制器会接收到请求，并转发给HandlerMapping</li><li>HandlerMapping负责解析请求，根据请求信息和配置信息(xml配置，注解)找到对应的Controller类，如果有配置拦截器，会按照顺序执行拦截器里面的PreHandler方法。</li><li>找到匹配的Controller后，会把请求参数传给Controller里面的方法。</li><li>Controller方法执行完后，会返回一个ModeAndView,其中包括视图名称和需要传递给视图的模型数据。</li><li>视图解析器会根据名字找到视图，然后把视图模型填充到视图里面，再渲染成html内容，返回给客户端</li></ol><p><strong>SpringBoot Starter有什么用？如何手写一个Starter？*</strong>*</p><p>[手把手教你手写一个最简单的 Spring Boot Starter - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/353561846#:~:text=%E4%BA%86%E8%A7%A3%E4%BA%86">https://zhuanlan.zhihu.com/p/353561846#:~:text=了解了</a> Starte)</p><p>Spring Boot Starter的作用是简化和加速项目的配置和依赖管理。</p><ul><li>Spring Boot Starter可以理解为一种预配置的模块，它封装了特定功能的依赖项和配置，开发者只需引入相关的Starter依赖，无需手动配置大量的参数和依赖项。</li><li>Starter还管理了相关功能的依赖项，包括其他Starter和第三方库，确保它们能够良好地协同工作，避免版本冲突和依赖问题。</li><li>Spring Boot Starter的设计使得应用可以通过引入不同的Starter来实现模块化的开发。每个Starter都关注一个特定的功能领域，如数据库访问、消息队列、Web开发等。</li><li>开发者可以创建自定义的Starter，以便在项目中共享和重用特定功能的配置和依赖项。</li></ul><p><strong>SpringBoot常用注解？</strong>**</p><p><a href="https://juejin.cn/post/7179038534711967800?searchId=20240115143538F00BA9AA4E6EA715EBA3">肝了一周总结的SpringBoot常用注解大全，一目了然！平时使用SpringBoot开发项目，少不了要使用到它的注解。 - 掘金 (juejin.cn)</a></p><ol><li><strong>@SpringBootApplication：</strong>是Spring Boot的核心注解，主要目的是开启自动配置。这个注解包含了**@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这三个注解。**</li><li><strong>@SpringBootConfiguration：</strong>该注解继承自@Configuration，二者功能基本一致，标注当前类是配置类。</li><li><strong>@EnableAutoConfiguration：</strong>用于启用Spring Boot的自动配置机制，根据项目的依赖和配置自动配置Spring应用程序。</li><li><strong>@ComponentScan：</strong>1）告诉Spring哪个package的用注解标识的类会被Spring自动扫描并且装入IoC容器中。2）自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些Bean加载到IoC容器中。</li><li><strong>@Controller：</strong>用于标识类作为Spring MVC的Controller。</li><li><strong>@RestController：</strong>类似于@Controller，但它是专门用于RESTful web服务的。它包含了@Controller和@ResponseBody。</li><li><strong>@RequestMapping：</strong>用于将HTTP请求映射到controller的处理方法。可以用在类级别和方法级别。</li><li><strong>@Autowired：</strong>用于自动注入Spring容器中的Bean，可以用在构造方法、字段、Setter方法上。</li><li><strong>@Service：</strong>用于标识类作为服务层的Bean。</li><li><strong>@Repository：</strong>用于标识类作为数据访问层的Bean，通常用于与数据库交互。</li><li><strong>@Component：</strong>通用的组件注解，用于标识任何spring托管的Bean。</li><li><strong>@Configuration：</strong>用于定义配置类，类中可能包含一些@Bean注解用于定义Bean。</li><li><strong>@Value：</strong>用于从属性文件或配置中读取值，将值注入到成员变量中。</li><li><strong>@Qualifier：</strong>与@Autowired一起使用，指定注入时使用的Bean名称。</li><li><strong>@ConfigurationProperties：</strong>用于将配置文件中的属性映射到Java Bean。</li><li><strong>@Profile：</strong>用于定义不同环境下的配置，可以标识在类或方法上。</li><li><strong>@Async：</strong>用于将方法标记为异步执行。</li></ol><p><strong>Spring和SpingBoot的区别？</strong>**</p><p>Spring 框架是一个广泛应用于企业级 Java 开发的开源框架，为开发Java应用程序提供了全面的基础架构支持。Spring Boot 则是在 Spring 框架基础上的一种简化配置、快速开发的框架。</p><ul><li><strong><font style="color:#000000;">环境配置不同</font></strong><font style="color:rgb(1, 1, 1);">：</font><strong><font style="color:rgb(1, 1, 1);">Spring的环境配置相对较为繁琐，需要手动进行配置</font></strong><font style="color:rgb(1, 1, 1);">，例如配置数据源、配置日志、配置Servlet等等。而</font><strong><font style="color:rgb(1, 1, 1);">Spring Boot则是提供了一套自动配置机制</font></strong><font style="color:rgb(1, 1, 1);">，</font><strong><font style="color:rgb(1, 1, 1);">通过约定大于配置的方式</font></strong><font style="color:rgb(1, 1, 1);">，可以减少开发者的环境配置工作量，从而快速构建应用程序。</font></li><li><strong><font style="color:#000000;">启动方式不同</font></strong><font style="color:rgb(1, 1, 1);">：</font><strong><font style="color:rgb(1, 1, 1);">Spring的启动方式是通过XML配置文件或Java配置类来配置应用程序，然后通过ApplicationContext来启动应用程序</font></strong><font style="color:rgb(1, 1, 1);">。而</font><strong><font style="color:rgb(1, 1, 1);">Spring Boot则是通过内嵌的Tomcat</font></strong><font style="color:rgb(1, 1, 1);">、Jetty、Undertow等容器，可以直接使用java -jar命令启动应用程序。</font></li><li><strong><font style="color:#000000;">依赖管理不同</font></strong><font style="color:rgb(1, 1, 1);">：</font><strong><font style="color:rgb(1, 1, 1);">在Spring中，需要手动添加各种依赖库</font></strong><font style="color:rgb(1, 1, 1);">，例如Spring MVC、Spring Security等等。而</font><strong><font style="color:rgb(1, 1, 1);">在Spring Boot中，则是通过Spring Boot Starter依赖，可以一次性添加一系列的依赖库</font></strong><font style="color:rgb(1, 1, 1);">，从而简化依赖管理的工作量。</font></li><li><strong><font style="color:#000000;">默认配置不同</font></strong><font style="color:rgb(1, 1, 1);">：Spring Boot为开发者提供了一系列的默认配置，例如日志、数据源等，大多数情况下可以直接使用默认配置来构建应用程序。而在Spring中，需要手动配置这些内容，增加了开发者的工作量。</font></li><li><strong><font style="color:#000000;">微服务支持：</font></strong><font style="color:rgb(1, 1, 1);">Spring 虽然可以用于构建微服务，但需要额外的配置和集成工作。</font><strong><font style="color:rgb(1, 1, 1);">Spring Boot 提供了对微服务架构的内置支持</font></strong><font style="color:rgb(1, 1, 1);">，如服务发现、负载均衡、配置管理等，</font><strong><font style="color:rgb(1, 1, 1);">与Spring Cloud紧密集成，更易于构建微服务应用。</font></strong></li></ul><p><font style="color:rgb(1, 1, 1);">总结：Spring Boot就是Spring的完善和扩展，就是为我们便捷开发，方便测试和部署，提高效率而诞生的框架技术。</font></p><h3 id="Day16-5"><a href="#Day16-5" class="headerlink" title="Day16.5"></a>Day16.5</h3><p><strong>过滤器和拦截器的区别是什么</strong></p><p><a href="https://cloud.tencent.com/developer/article/2142914"><strong>面试突击90：过滤器和拦截器有什么区别？-腾讯云开发者社区-腾讯云 (tencent.com)</strong></a></p><ol><li>出身不同</li></ol><p>过滤器来自于 Servlet，而拦截器来自于 Spring 框架。</p><ol start="2"><li>触发时机不同</li></ol><p>请求的顺序是：请求进入容器&gt;进入过滤器&gt;进入Servlet&gt;进入拦截器&gt;执行控制器（Controller）。所以过滤器和拦截器的执行时机也是不同的，<strong>过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。</strong></p><p><img src="/post/f4c4d599/b9d01a260af697502076b51dfc03162e.png"></p><ol start="3"><li>实现不同</li></ol><p><strong>过滤器是基于方法的回调实现的，而拦截器是基于动态代理（底层是反射）实现的。</strong></p><ol start="4"><li>支持的项目类型不同</li></ol><p>过滤器是 Servlet 规范中定义的，所以<strong>过滤器要依赖 Servlet 容器，它只能用在 Web 项目中；而拦截器是 Spring 中的一个组件，因此拦截器既可以用在 Web 项目中，同时还可以用在 Application 或 Swing 程序中。</strong></p><ol start="5"><li>使用的场景不同</li></ol><ul><li>因为拦截器更接近业务系统，所以<strong>拦截器主要用来实现项目中的业务判断的</strong>，比如：登录判断、权限判断、日志记录等业务。</li><li>而<strong>过滤器通常是用来实现通用功能过滤的</strong>，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Day17√"><a href="#Day17√" class="headerlink" title="Day17√"></a>Day17√</h3><p><strong>一条SQL查询语句是如何执行的？</strong>**</p><p><a href="https://zhuanlan.zhihu.com/p/352806837">一条SQL查询语句是如何执行的？ - 知乎 (zhihu.com)</a></p><ul><li><strong>连接器：</strong>跟客户端建立连接、获取权限、维持和管理连接；</li><li><strong>查询缓存：</strong>查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li><strong>解析 SQL：</strong>通过分析器对 SQL 查询语句进行<strong>词法分析</strong>、<strong>语法分析</strong>，然后构建语法树；</li><li><strong>执行 SQL：</strong>执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将<code>select *</code>中的<code>*</code>符号扩展为表上的所有列；</li><li>优化阶段：基于查询成本的考虑，<strong>优化器</strong>会选择查询成本最小的执行计划；</li><li>执行阶段：<strong>执行器</strong>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</li></ul></li></ul><p><img src="/post/f4c4d599/1725097285837-e04a47a8-9473-4167-ba78-f11741c75cd7.png"></p><p><strong>数据库的事务隔离级别有哪些？</strong>***</p><p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)<strong>的问题，为了解决这些问题，就有了“</strong>隔离级别</strong>”的概念。</p><blockquote><ul><li><strong>脏读(Dity Read)：</strong>指一个事务读取了另一个事务未提交的数据。当一个事务修改了某个数据，但还未提交时，另一个事务读取了这个未提交的数据，如果第一个事务回滚了，那么第二个事务读取到的数据就是无效的。脏读会导致数据的不一致性。</li><li><strong>幻读(Phantom Read)：</strong>指一个事务在读取某个范围的数据时，另一个事务插入了新的数据，导致第一个事务再次读取同样的范围时，发现有新的数据出现。幻读主要发生在并发的插入操作中，会导致第一个事务读取到不一致的数据。</li><li><strong>不可重复读 (Non-repeatable Read)：</strong>指一个事务在读取某个数据后，再次读取同样的数据时，发现数据已经发生了变化。不可重复读主要发生在并发的更新操作中，会导致事务之间读取到不一致的数据。</li></ul></blockquote><ol><li><strong>读未提交(Read Uncommitted)</strong></li></ol><ul><li>允许一个事务读取另一个事务尚未提交的数据修改。</li><li>最低的隔离级别，存在脏读、不可重复读和幻读的问题。</li></ul><ol start="2"><li><strong>读已提交(Read Committed)</strong></li></ol><ul><li>一个事务只能读取已经提交的数据。其他事务的修改在该事务提交之后才可见。</li><li>解决了脏读问题，但仍可能出现不可重复读和幻读。</li></ul><ol start="3"><li><strong>可重复读(Repeatable Read)</strong></li></ol><ul><li>事务执行期间，多次读取同一数据会得到相同的结果，即在事务开始和结束之间，其他事务对数据的修改不可见。</li><li>解决了不可重复读问题，但仍可能出现幻读。</li></ul><ol start="4"><li><strong>序列化(Serializable)</strong></li></ol><ul><li>最高的隔离级别，确保事务之间的并发执行效果与串行执行的效果相同，即不会出现脏读、不可重复读和幻读。</li></ul><p><strong>事务的四大特性有哪些？</strong>***</p><p>事务的四大特性通常被称为 <strong>ACID</strong> 特性</p><ol><li><strong>原子性(Atomicity)：</strong>确保事务的所有操作要么全部执行成功，要么全部失败回滚，不存在部分成功的情况。</li><li><strong>一致性(Consistency)：</strong>事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。</li><li><strong>隔离性(Isolation)：</strong>多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响其他事务的执行。</li><li><strong>持久性(Durability)：</strong>一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持。</li></ol><h3 id="Day18√"><a href="#Day18√" class="headerlink" title="Day18√"></a>Day18√</h3><p><strong>MySQL的执行引擎有哪些？</strong>**</p><p>主要有InnoDB、MyISAM、Memery等引擎：</p><ul><li><code>**InnoDB**</code> 引擎<strong>提供了对事务ACID四大特性的支持，还提供了行级锁和外键约束</strong>。是MySQL默认存储引擎，适用于需要事务支持、高并发性、高写入需求的应用。</li><li><code>**MyISAM**</code> 引擎<strong>使用表级锁，支持全文索引，但不支持事务，也不支持行级锁和外键约束</strong>。MySQL最早提供的存储引擎，适用于以读操作为主的应用。</li><li><code>**Memery**</code> 就是<strong>将数据放在内存中，数据处理速度很快，但是安全性不高</strong>（一旦数据库崩溃，数据就会丢失）。常应用于临时表中。</li><li><code>Merge</code>将多个相同的MyISAM表合并为一个虚表，常应用于日志和数据仓库。</li></ul><p><strong>MySQL索引有哪些种类？</strong></p><ol><li><strong>按数据结构分类：</strong></li></ol><p>B+ tree索引：所有数据存储在叶子节点，复杂度为O(logn)，适合范围查询。</p><p>Hash 索引：适合等值查询，检索效率高，一次到位。</p><p>Full-text 索引：又称为全文索引，MyISAM 和 InnoDB 中都支持使用全文索引，一般在文本类型 char，text，varchar类型上创建。</p><ol><li><strong>按物理存储分类：</strong></li></ol><p>聚簇索引：数据存储与索引一起存放，叶子节点会存储一整行记录，找到索引也就找到了数据。</p><p>非聚簇索引：又称为二级索引，数据存储与索引分开存放，叶子节点不存储数据，存储的是数据主键。</p><ol><li><strong>按字段特性分类：</strong></li></ol><p>主键索引：建立在主键 PRIMARY 字段上的索引，不允许有空值。</p><p>唯一索引：建立在 UNIQUE 字段上的索引，但是允许有空值。</p><p>普通索引：MySQL中基本索引类型，允许空值和重复值。</p><p>前缀索引：是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引。</p><ol><li><strong>按字段个数分类：</strong></li></ol><p>单列索引：建立在单个字段上的索引为单列索引。</p><p>联合索引：建立在多个字段上的索引，使用时遵循最左前缀原则。</p><p><strong>MySQL为什么使用B+树来作索引？B树与B+树的区别？</strong>***</p><ol><li><strong>单点查询：</strong>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就査到，而从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。<strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</strong></li><li><strong>插入和删除效率：</strong>B+ 树有大量的冗余节点（非叶子节点），删除一个数据的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+树的插入也是一样，有冗余节点，插入可能存在节点的分裂(如果节点饱和)，但是最多只涉及树的一条路径。B树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。</li><li><strong>范围查询：</strong>B+ 树所有叶子节点之间用链表连接了起来，有利于范围查询，而 B树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。B+ 树的插入和删除效率更高。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB。</li></ol><p><img src="/post/f4c4d599/1725257864329-f3bf9061-e0f1-493c-be7b-38db4342f5f2.webp"></p><p><strong>说一下索引失效的场景？</strong>**</p><p><a href="https://blog.csdn.net/weixin_46224056/article/details/137597431"><strong>索引失效的10种场景，你知道几个呢？（面试必刷!）_索引失效的场景-CSDN博客</strong></a></p><ul><li><strong>使用左或者左右模糊匹配：</strong>比如<code>LIKE &#39;%abc&#39;</code> 这样的查询会导致索引失效。</li><li><strong>在索引列上使用函数或表达式：</strong>索引列上参与计算，索引失效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(<span class="keyword">column</span>) <span class="operator">=</span> <span class="string">&#x27;VALUE&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>OR 条件：</strong>当查询中使用多个 OR 条件时，如果这些条件不涉及同一列（例如在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列），那么索引会失效。数据库可能会选择全表扫描而不是使用多个索引。</li><li><strong>违背最左匹配原则</strong>，索引失效。</li></ul><blockquote><p>在使用联合索引进行查询时，查询条件需要遵循索引中列的顺序，从左到右进行匹配。</p></blockquote><ul><li><strong>不等号条件：</strong>通常情况下，索引只能用于等值比较。当查询中包含不等号条件(如&gt;, &lt;, between, in)时，索引可能会失效。</li><li><strong>隐式类型转换：</strong>如果查询中的条件涉及到隐式类型转换，例如将字符串与数字比较，索引可能无法被使用。</li></ul><h3 id="Day19√"><a href="#Day19√" class="headerlink" title="Day19√"></a>Day19√</h3><p><strong>MySQL 的日志文件有哪几种？</strong>**</p><ul><li><code>**undo log**</code><strong>（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和MVCC</strong>。</li><li><code>**redo log**</code><strong>（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障后的数据恢复</strong>。</li><li><code>**binlog**</code><strong>（归档日志）</strong>：是 MySQL Server 层生成的一种二进制日志，主要<strong>用于数据备份和主从复制</strong>。<font style="color:rgb(25, 27, 31);">用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句，并以 “事务”的形式保存在磁盘中。</font></li><li><code>**relay log**</code><strong>（中继日志）</strong>：用于<strong>主从复制</strong>场景下，<strong>从服务器通过 I&#x2F;O 线程拷贝主服务器的 <strong><code>**binlog**</code></strong> 后本地生成的日志</strong>，然后从服务器 SQL 线程会读取<code>relay log</code>的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</li></ul><p><strong>什么是慢查询？原因是什么？可以怎么优化？</strong>**</p><p>慢查询是指<strong>数据库查询的执行时间超过指定的超时时间时(long_query_time：默认10秒 )。</strong></p><p><strong>原因：</strong></p><ul><li>查询语句比较复杂：查询涉及多个表，包含复杂的连接和子查询，可能导致执行时间较长。</li><li>查询数据量大：当查询的数据量庞大时，即使查询本身并不复杂，也可能导致较长的执行时间。</li><li>缺少索引：如果查询的表没有合适的索引，需要遍历整张表才能找到结果，查询速度较慢。</li><li>数据库设计不合理：数据库表设计庞大，查询时可能需要较多时间。</li><li>并发冲突：当多个查询同时访问相同的资源时，可能发生并发冲突，导致查询变慢。</li><li>硬件资源不足：如果MVSQL服务器上同时运行了太多的查询，会导致服务器负载过高，从而导致查询变慢</li></ul><p><strong>优化：</strong></p><ol><li><strong>不使用子查询</strong></li><li><strong>分组统计可以禁止排序：</strong>默认情况下，MySQL对所有GROUP BY col1，col2…的字段进⾏排序。如果查询包括GROUP BY，想要避免排序结果的消耗，则可以指定<strong>ORDER BY NULL禁止排序。</strong></li><li><strong>禁止不必要的ORDER BY排序</strong></li><li><strong>尽量不要超过三个表join</strong></li><li>**不要使用 select ***</li><li><strong>排序请尽量使用升序</strong></li><li><strong>尽量使用数字型字段</strong></li><li><strong>避免索引失效</strong></li></ol><p><strong>可以对数据库表做那些优化？</strong>**</p><ol><li><strong>合理使用数据库分表</strong></li></ol><p>对于一些特别大的表，可以考虑将其拆分成多个子表，从而更好地管理数据</p><ol start="2"><li><strong>建立索引</strong></li></ol><p>在经常被查询的列上建立索引，提高查询性能。但是也要注意过多的索引影响插入、更新和删除的性能</p><ol start="3"><li>**避免使用 **<code>select</code></li></ol><p>只选择需要的列而不是使用 <code>SELECT</code></p><ol start="4"><li><strong>选择合适的数据类型：</strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</li></ol><ul><li>尽量使用TINYINT，SMALLINT，MEDIUM INT替代INT类型，如果是非负则加上UNSIGNED</li><li>VARCHAR的长度只分配真正需要的空间</li><li>尽量使用整数或者枚举替代字符串类型，因为数值型数据被处理起来的速度要比文本类型要快得多。</li><li>时间类型尽量使用TIMESTAMP而ETIME</li><li>单表不要放太多字段</li><li>尽量少使用NULL，很难查询优化而且占用额外索引空间</li></ul><ol start="5"><li><strong>尽量把字段设置为NOT NULL</strong></li><li><strong>使用连接(JOIN)来代替子查询(Sub-Queries)</strong></li></ol><p>连接(JOIN)之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p><ol start="7"><li><strong>避免全表扫描</strong></li></ol><p><font style="color:rgb(33, 37, 41);">当表中数据量巨大时，全表扫描会非常耗时。通过使用合适的查询条件来避免全表扫描，可以显著提高查询效率。</font></p><ol start="8"><li><strong>使用查询缓存</strong></li></ol><p><font style="color:rgb(33, 37, 41);">当相同的查询被频繁执行时，使用查询缓存可以避免重复的数据库扫描。</font></p><h3 id="Day20√"><a href="#Day20√" class="headerlink" title="Day20√"></a>Day20√</h3><p><strong>说一说你了解的 MVCC 机制？</strong></p><p>MVCC（Multi-Version Concurrency Control，<strong>多版本并发控制</strong>），用于管理多个事务同时访问和修改数据库的数据，而不会导致数据不一致或冲突。MVCC 的核心思想是每个事务在数据库中看到的数据版本是事务开始时的一个快照，而不是实际的最新版本。这使得多个事务可以并发执行，而不会互相干扰。<strong>使用 MVCC 和锁可以实现事务的隔离性。</strong></p><p><strong>关系型数据库和非关系型数据库的区别？</strong></p><p>关系型数据库（Relational Database）和非关系型数据库（NoSQL Database）是两种主流的数据库系统，它们在<strong>数据存储方式、扩展方式以及事务性支持</strong>等方面存在区别。以下是具体分析：</p><ol><li><strong>数据存储方式</strong></li></ol><ul><li><strong>关系型数据库</strong>：关系型数据库使用表格形式存储数据，每个表格由行和列组成，并具有固定的模式（schema），对数据的结构和关系进行严格定义。</li><li><strong>非关系型数据库</strong>：非关系型数据库采用灵活的数据模型，通常使用键值对、文档、列族或图形等形式组织数据，适合存储半结构化和非结构化数据。</li></ul><ol><li><strong>扩展方式</strong></li></ol><ul><li><strong>关系型数据库</strong>：关系型数据库主要通过纵向扩展，即提升单个服务器的性能来应对需求增长，但最终可能达到扩展的上限。</li><li><strong>非关系型数据库</strong>：非关系型数据库具有良好的横向扩展性，可以通过增加更多服务器节点来分担负载，适应大规模分布式数据存储。</li></ul><ol><li><strong>事务性支持</strong></li></ol><ul><li><strong>关系型数据库</strong>：关系型数据库支持复杂的事务管理，确保数据的完整性和一致性，通过ACID（原子性、一致性、隔离性、持久性）的事务处理机制。</li><li><strong>非关系型数据库</strong>：非关系型数据库虽然也能实现事务操作，但在事务的稳定性方面不如关系型数据库，其优势主要在于高并发和大数据量处理。</li></ul><ol><li><strong>一致性</strong></li></ol><ul><li><strong>关系型数据库</strong>：关系型数据库强调数据完整性和一致性，通过主键和外键等约束，保证数据之间的关系和准确性。</li><li><strong>非关系型数据库</strong>：非关系型数据库更加注重可用性和分布式存储，允许一定程度的数据冗余，适用于对数据一致性要求不高的场景。</li></ul><ol><li><strong>查询语言</strong></li></ol><ul><li><strong>关系型数据库</strong>：关系型数据库使用标准化的SQL语言进行数据查询和管理，便于复杂查询操作。</li><li><strong>非关系型数据库</strong>：非关系型数据库根据数据模型不同，支持多种查询语言如XPath、JavaScript等，更适用于特定场景的数据处理。</li></ul><ol><li><strong>选择方法</strong></li></ol><ul><li><strong>关系型数据库</strong>：关系型数据库适用于需要结构严谨、数据完整性要求高的应用场景，如金融、医疗等行业。</li><li><strong>非关系型数据库</strong>：非关系型数据库适合大规模数据、高并发访问及数据结构多变的场景，如社交媒体、大数据处理。</li></ul><p>针对上述分析，提出以下几点考虑因素：</p><ol><li><strong>安全性</strong>：关系型数据库由于其严格的事务管理和一致性控制，通常提供更高的数据安全性。</li><li><strong>性能需求</strong>：非关系型数据库在处理大规模数据和高并发请求时表现出色，适合需要高性能的应用。</li><li><strong>成本</strong>：非关系型数据库往往有更低的硬件成本，并且很多选项是开源的，降低了部署和维护费用。</li><li><strong>技术栈</strong>：选择与团队技术栈相匹配的数据库类型可以降低学习成本和开发难度。</li><li><strong>未来可扩展性</strong>：预留考虑未来可能增长的数据量和需求变化，选择能够支持长期发展的数据库解决方案。</li></ol><p><strong>MySQL 和 Redis 的区别？</strong>**</p><ol><li><strong>存储方式</strong>：redis基于键值对，支持多种数据结构；而MySQL是一种关系型数据库，使用表来组织数据。</li><li><strong>持久化</strong>：redis将数据存在内存中，通过持久化机制将数据写入磁盘；MySQL通常将数据存储在磁盘上。</li><li><strong>复杂查询支持</strong>：redis不使用SQL，而是使用自己的命令集，不支持复杂的查询；MySQL使用SQL语言，可以进行复杂的查询操作。</li><li><strong>应用场景</strong>：redis以高性能能低延迟为目标，适用于读多写少的应用场景；MySQL适用于需要复杂查询、事务处理和大规模数据存储的应用场景。</li></ol><p><strong>Redis有什么优缺点？为什么用Redis查询会比较快？</strong>**</p><p><strong>优点：</strong>Redis是一个基于<strong>内存</strong>的数据库，读写速度非常快，通常被用作<strong>缓存、消息队列、分布式锁和键值存储数据库</strong>。常支持多种数据类型，如<strong>字符串、哈希表、列表、集合、有序集合</strong>等，Redis还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。</p><p><strong>缺点：</strong>1.<strong>内存限制</strong>，redis将数据存储在内存中，因此它受到物理内存大小限制；2.<strong>单线程模型</strong>，redis使用单线程处理客户端请求，这限制了他在高并发场景下的吞吐量；3.redis不支持SQL数据库那样的<strong>复杂查询</strong>操作。</p><p>redis查询速度快的原因：</p><ol><li><strong>基于内存</strong>：内存的本身的读写速度很快，这是redis速度快的主要原因；</li><li><strong>高效的数据结构</strong>：redis专门设计了STRING、LIST、HASH等高效数据结构，依赖各种数据结构提升了读写的效率；</li><li><strong>单线程</strong>：单线程操作避免了多线程资源竞争和上下文切换带来的性能损失；</li><li><strong>I&#x2F;O多路复用</strong>：采用I&#x2F;O多路复用同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。</li></ol><h3 id="Day21√"><a href="#Day21√" class="headerlink" title="Day21√"></a>Day21√</h3><p><strong>Redis的基本数据类型有那些？有哪些使用场景</strong>***</p><p><img src="/post/f4c4d599/1722415900660-9d12da28-9f81-48d4-8bb2-bda50188e9f6.png"></p><p>Redis是一个基于<strong>内存</strong>的数据库，读写速度非常快，通常被用作<strong>缓存、消息队列、分布式锁和键值存储数据库</strong>。常见的数据类型有<strong>String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、Zset（有序集合）</strong>。</p><ul><li>字符串：存储<strong>字符串</strong>数据，也可以存储<strong>整数、浮点数</strong>，是最基本的数据类型，常用于<strong>缓存对象、常规计数、分布式锁、共享Session信息</strong>等；</li><li>哈希表：存储<strong>字段和值的映射</strong>，常用于<strong>缓存对象、购物车</strong>等；</li><li>列表：存储<strong>有序的字符串元素</strong>，常用于<strong>消息队列</strong>（有两个问题：1. ⽣产者需要自行实现全局唯⼀ ID；2. 不能以消费组形式消费数据）；</li><li>集合：存储<strong>无序不重复的字符串元素</strong>，常用于<strong>聚合运算场景</strong>（<strong>并集、交集、差集</strong>），如<strong>点赞、共同关注、抽奖活动</strong>；</li><li>有序集合：类似于集合，但是可以根据元素所关联的分数进行排序，常用于<strong>排序场景</strong>，如<strong>排行榜</strong>。</li></ul><p>随着Redis版本更新，又更新了这些数据类型：</p><ul><li>BitMap：存储位的数据结构，可以处理一些位运算操作，比如签到、登录状态等；</li><li>HyperLogLog：用于基数估算的数据结构，用于统计元素的唯⼀数量，如海量数据基数统计的场景；</li><li>GEO：存储地理位置信息的数据结构；</li><li>Stream：专门为消息队列设计的数据类型。</li></ul><p><strong>Redis是单线程的还是多线程的，为什么？</strong>***</p><p>Redis是<strong>单线程</strong>的，redis的单线程指的是<strong>网络请求模块使用单线程</strong>进行处理，其他模块仍用多个线程  原因如下：</p><ol><li>CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。</li><li>单线程容易实现，并且单线程避免了多线程的资源竞争和上下文切换的开销。</li></ol><h3 id="day22√"><a href="#day22√" class="headerlink" title="day22√"></a>day22√</h3><p><strong>Redis持久化机制有哪些？</strong>***</p><ol><li><strong>AOF日志</strong>：每次执行一条写操作指令，就把该指令以追加的方式写入到一个文件里；</li><li><strong>RDB快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：工作在AOF日志重写的过程中，集成了前两种的优点。在 AOF 日志重写过程中，Redis 会先将当前内存中的数据以 RDB 的形式写入到 AOF 文件的开头，然后再将后续的写入命令以 AOF 形式追加到文件中。</li></ol><blockquote><p>AOF优点是服务器宕机时<strong>丢失数据少</strong>，但是数据恢复不够快；RDB的优点是<strong>数据恢复快</strong>，但是保存快照的频率不好把握，频率高会影响性能，频率低会丢失的数据较多。</p></blockquote><p><strong>缓存雪崩、击穿、穿透和解决办法？</strong>***</p><p><img src="/post/f4c4d599/1722424007103-690d2433-e03a-4981-a216-b5c648308789.png"></p><ul><li><strong><font style="color:rgb(51, 51, 51);">缓存雪崩</font></strong><font style="color:rgb(51, 51, 51);">：指的是在某个时间点，缓存中大量数据同时失效，导致请求直接访问数据库或其他后端系统，增加了系统的负载。</font></li></ul><p><strong><font style="color:rgb(51, 51, 51);">原因</font></strong><font style="color:rgb(51, 51, 51);">：大量数据的过期时间相近或者Redis服务器故障宕机。</font></p><p><strong><font style="color:rgb(51, 51, 51);">解决方法</font></strong><font style="color:rgb(51, 51, 51);">：对于第一种情况可以</font><strong><font style="color:rgb(51, 51, 51);">均匀设置过期时间</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(51, 51, 51);">加互斥锁</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(51, 51, 51);">后台更新缓存</font></strong><font style="color:rgb(51, 51, 51);">（让缓存“永久有效”，并将更新缓存的⼯作交由后台线程定时更新）等策略；对于第二种情况可以采用</font><strong><font style="color:rgb(51, 51, 51);">服务熔断</font></strong><font style="color:rgb(51, 51, 51);">或</font><strong><font style="color:rgb(51, 51, 51);">请求限流机制</font></strong><font style="color:rgb(51, 51, 51);">，还有</font><strong><font style="color:rgb(51, 51, 51);">构建Redis缓存高可用集群</font></strong><font style="color:rgb(51, 51, 51);">等方法。</font></p><ul><li><strong><font style="color:rgb(51, 51, 51);">缓存击穿</font></strong><font style="color:rgb(51, 51, 51);">：指的是有大量请求查询一个缓存中不存在但数据库中存在的数据时，这些请求直接访问到数据库，增加数据库的负载。</font></li></ul><p><strong>原因</strong>：单个热点数据的缓存失效，短时间内大量的请求直接访问数据库。</p><p><strong><font style="color:rgb(51, 51, 51);">解决方法</font></strong><font style="color:rgb(51, 51, 51);">：缓存击穿是缓存雪崩的一个</font><strong><font style="color:rgb(51, 51, 51);">子集</font></strong><font style="color:rgb(51, 51, 51);">，可以采用</font><strong><font style="color:rgb(51, 51, 51);">互斥锁</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:rgb(51, 51, 51);">后台更新缓存</font></strong><font style="color:rgb(51, 51, 51);">等策略。</font></p><ul><li><strong><font style="color:rgb(51, 51, 51);">缓存穿透</font></strong><font style="color:rgb(51, 51, 51);">：指的是查询一个缓存和数据库都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。</font></li></ul><p><strong><font style="color:rgb(51, 51, 51);">原因</font></strong><font style="color:rgb(51, 51, 51);">：恶意攻击、业务误操作，缓存和数据库中的数据都被删除了。</font></p><p><strong><font style="color:rgb(51, 51, 51);">解决方法</font></strong><font style="color:rgb(51, 51, 51);">：</font><strong><font style="color:rgb(51, 51, 51);">限制非法请求</font></strong><font style="color:rgb(51, 51, 51);">、对查询的数据，</font><strong><font style="color:rgb(51, 51, 51);">在缓存中设置空值</font></strong><font style="color:rgb(51, 51, 51);">、使用</font><strong><font style="color:rgb(51, 51, 51);">布隆过滤器</font></strong><font style="color:rgb(51, 51, 51);">过滤恶意请求。</font></p><blockquote><p><strong>布隆过滤器</strong>是一种空间效率极高的概率型数据结构，它被用来测试一个元素是否在一个集合中。布隆过滤器可能会给出错误的正例，但永远不会给出错误的反例。也就是说，<strong>如果布隆过滤器说某个元素不在集合中，那么这个结论一定是正确的；但如果它说某个元素在集合中，那么这个结论可能是错误的</strong>。原理如下：</p><ol><li><strong>初始化</strong></li></ol><ul><li><strong><font style="color:rgb(44, 44, 54);">位数组</font></strong><font style="color:rgb(44, 44, 54);">：布隆过滤器的核心是一个很长的二进制向量（</font><strong><font style="color:rgb(44, 44, 54);">位数组</font></strong><font style="color:rgb(44, 44, 54);">），初始时所有位都是0。</font></li><li><strong><font style="color:rgb(44, 44, 54);">哈希函数</font></strong><font style="color:rgb(44, 44, 54);">：需要选择</font><strong><font style="color:rgb(44, 44, 54);">多个独立的哈希函数</font></strong><font style="color:rgb(44, 44, 54);">（通常为k个），这些函数会将输入映射到位数组中的不同位置。</font></li></ul><ol start="2"><li><strong>插入元素</strong></li></ol><ul><li><font style="color:rgb(44, 44, 54);">当一个元素被添加到布隆过滤器时，使用所有的哈希函数计算该元素对应的位数组的位置。</font></li><li><font style="color:rgb(44, 44, 54);">对于每个哈希函数计算出的位置，将位数组中对应位置的比特设为1。</font></li></ul><ol start="3"><li><strong>查询元素</strong></li></ol><ul><li><font style="color:rgb(44, 44, 54);">当查询一个元素是否存在时，同样使用所有的哈希函数计算该元素对应的位数组的位置。</font></li><li><font style="color:rgb(44, 44, 54);">如果所有计算出的位置上的比特都为1，则认为该元素</font><strong><font style="color:rgb(44, 44, 54);">可能</font></strong><font style="color:rgb(44, 44, 54);">存在于集合中。</font></li><li><font style="color:rgb(44, 44, 54);">如果任一位置的比特为0，则确定该元素不在集合中。</font></li></ul></blockquote><p><strong>如何保证数据库和缓存的一致性？</strong>***</p><ol><li><strong>缓存更新策略</strong></li></ol><p><strong>Cache Aside（旁路缓存）</strong></p><ul><li><strong>原理:</strong> <strong>读操作</strong>：先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；<strong>写操作</strong>：更新数据的时候先把数据持久化到数据库，然后删除缓存。</li><li><strong>问题:</strong> 假如有两个操作一个更新一个查询，第一个操作先更新数据库，还没来及删除数据库，查询操作可能拿到的就是旧的数据，更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性;还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效,然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。</li><li><strong>可行性:</strong> 出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并且在写操作之后更新，概率比较低。</li></ul><p><strong>Read&#x2F;Write Through</strong></p><ul><li><strong>原理:</strong> <strong>Read&#x2F;Write Through原理是把更新数据库(Repository) 的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。</strong></li><li><strong>Read Through:</strong> 应用查询缓存是否存在，存在则返回；不存在则由缓存组件去数据库加载数据到缓存。</li><li><strong>Write Through（双写法）</strong>: 先查询要写入的数据在缓存是否存在，存在则先更新缓存然后再更新数据库最后返回；如果要写入的数据在缓存不存在，则直接将数据写入数据库。</li></ul><p><strong>Write Behind(Write Back)</strong></p><ul><li><strong>原理:</strong> Write Behind 和 Read&#x2F;Write Through 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。<strong>在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库</strong>。这个设计的好处就是让数据的 I&#x2F;O 操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。</li><li><strong>第二步失效问题:</strong> 这种可能性极小，缓存删除只是标记一下无效的软删除，可以看作不耗时间。如果会出问题，一般程序在写数据库那里就没有完成: 故意在写完数据库后，休眠很长时间再来删除缓存。</li></ul><p><strong>哨兵的工作原理？</strong>***</p><ul><li><strong><font style="color:rgb(51, 51, 51);">判断节点是否存活</font></strong><font style="color:rgb(51, 51, 51);">：每个哨兵定期向Redis服务器发送PING命令，以检测服务器是否处于活跃状态。若哨兵在连续一定次数未收到服务器的响应，就认为该服务器主观下线。然后哨兵就会从从节点中选择一个作为主节点。</font></li><li><strong><font style="color:rgb(51, 51, 51);">选出新主节点</font></strong><font style="color:rgb(51, 51, 51);">：在发现主服务器下线后，哨兵们会协调选举一个新的主服务器。这个过程中，哨兵会考虑每个可用的从服务器，选择个作为新的主服务器，并将其他从服务器配置为复制新的主服务器。</font></li></ul><ul><li><strong>具体过程：</strong><ul><li><strong>选择候选从服务器</strong>：哨兵会从可用的从服务器中选择一组候选服务器，通常选择复制偏移量 (replicationoffset) 最大的从服务器。</li><li><strong>计算投票</strong>：每个哨兵为每个候选从服务器投票。投票的考量因素包括从服务器的复制偏移量、连接质量、优先级等。</li><li><strong>达成共识</strong>：哨兵们根据投票结果达成共识，选择一个从服务器作为新的主服务器。这通常需要获得多数哨兵的同意。</li></ul></li></ul><ul><li><strong><font style="color:rgb(51, 51, 51);">更新配置信息</font></strong><font style="color:rgb(51, 51, 51);">：一旦新的主服务器被选出，哨兵会更新 Redis 集群的配置信息，包括将新的主服务器的地址和端口通知给其他哨兵和客户端。</font></li><li><strong><font style="color:rgb(51, 51, 51);">通知客户端</font></strong><font style="color:rgb(51, 51, 51);">：哨兵会向客户端发送通知，告知客户端新的主服务器的位置，以便客户端能够重新连接。</font></li></ul><h3 id="Day22-5"><a href="#Day22-5" class="headerlink" title="Day22.5"></a>Day22.5</h3><p><strong>Redis中的大Key和热Key是什么，怎么解决？</strong></p><p><a href="https://cloud.tencent.com/developer/article/1977961">一文了解如何发现并解决Redis热key与大key问题-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>Redis如何实现分布式锁？</strong></p><p><a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">Redis实现分布式锁的7种方案 - why414 - 博客园</a></p><p>想要实现分布式锁，必须要求Redis有互斥的能力。可以使用SETNX命令，其含义是SET IF NOT EXIST，即如果key不存在，才会设置它的值，否则什么也不做。两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p><strong>锁过期释放，业务没执行完怎么办？</strong></p><p><a href="https://zhuanlan.zhihu.com/p/421843030">Redis 分布式锁过期了，但业务还没有执行完，怎么办！ - 知乎 (zhihu.com)</a></p><p>在Redission中，只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了「锁过期释放，业务没执行完」问题。</p><p><img src="/post/f4c4d599/1729150511518-55566ed5-4f13-44cb-9bf3-7def222d2971.png"></p><p><strong>Redis过期删除策略有哪些？</strong></p><ul><li><strong>定时删除</strong>：设置key的过期时间，当时间到达时，自动执行key的删除操作。</li><li><strong>惰性删除</strong>：每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</li><li><strong>定期删除</strong>：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</li></ul><p>Redis选择 <strong>惰性删除 + 定期删除</strong> 这两种策略配合使用。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="Day23"><a href="#Day23" class="headerlink" title="Day23"></a>Day23</h3><p><strong>TCP&#x2F;IP模型和OSI模型？</strong>**</p><p>OSI模型是国际标准化组织ISO制定的一个用于计算机或通信系统互联的标准体系，主要分为七个层级，从上到下依次为：应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。详细如下：</p><ol><li><strong>应用层：</strong>这一层为用户程序提供网络服务。常见的协议有FTP、SMTP、HTTP、DNS。</li><li><strong>表示层：</strong>负责数据的格式转换、加密和解密，确保数据在不同系统之间的正确解释性和呈现。也就是把计算机能够识别的东西转换为人能够识别的东西。</li><li><strong>会话层：</strong>建立、管理和终止应用程序之间的会话连接。</li><li><strong>传输层：提供端到端的数据传输服务。</strong>它使用TCP和UDP来传输管理数据。</li><li><strong>网络层：负责数据的路由和转发，</strong>选择最佳路径将数据从园主机传输到目标主机。使用IP地址来识别主机和网络，并提供逻辑地址寻址。<strong>传输单位是数据报。常见协议有ICMP、ARP、IP。</strong></li><li><strong>数据链路层：</strong>建立逻辑连接、进行硬件地址寻址、差错校验等功能。 ⽤MAC地址访问介质，<strong>传输单位是帧。</strong></li><li><strong>物理层：</strong>负责物理媒介传输的，例如电缆、光纤或无线信号。<strong>这一层的数据叫比特。</strong></li></ol><p>TCP&#x2F;IP模型是是一种用于组织和描述计算机网络通信的标准协议，它是互联网最常用的协议栈。主要分为四个层级：</p><ol><li><strong>应用层：该层与OSI模型的应用层和表示层以及会话层类似，提供直接与用户应用程序交互的接口。</strong>常见的协议有电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。</li><li><strong>传输层：该层对应OSI模型的传输层。它负责端到端的数据传输服务，提供可靠的、无连接的数据传输服务。</strong>常见的协议有TCP和UDP。TCP提供面向连接且可靠的数据传输，确保数据的准确性和完整性；而UDP是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。</li><li><strong>网际层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，</strong>选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来识别主机和网络，并进行逻辑地址寻址。</li><li><strong>网络接口层：该层对应OSI模型的数据链路层和物理层。</strong>它负责物理传输媒介的传输，例如以太网、WiFi等，并提供错误检测和纠正的功能。此外该层还包括硬件地址——MAC地址的管理。</li></ol><p><strong>从输入URL到页面展示发生了什么？</strong>***</p><ol><li><strong>URL 输入</strong>：用户在浏览器的地址栏中输入URL，例如”<a href="https://www.example.com" ">https://www.example.com"</a></li><li><strong>域名解析</strong>：浏览器通过域名系统(DNS)将域名解析为IP地址，以确定要连接的服务器位置。</li><li><strong>建立连接</strong>：浏览器使用解析得到的 IP 地址，与服务器建立网络连接。这通常涉及使用 TCP 协议进行三次握手。</li><li><strong>发送请求</strong>：浏览器向服务器发送 HTTP 请求，请求服务器的网页内容。请求中包含了要访问的路径、方法(GET、POST等)、头部信息等。</li><li><strong>服务器处理</strong>：服务器接收到请求后，根据请求的内容和路径，处理请求并返回响应。服务器可能从数据库中获取数据，生成动态内容，然后将响应发送回浏览器。</li><li><strong>接收响应</strong>：浏览器接收到服务器的响应，响应包含了 HTTP 状态码、头部信息和页面内容等。</li><li><strong>解析和渲染</strong>：浏览器开始解析响应内容，构建文档对象模型(DOM)和渲染树。它解析HTML、CSS和JavaScript，并确定页面的结构、样式和行为。</li><li><strong>页面渲染</strong>：浏览器使用渲染树和样式信息，将页面内容绘制到屏幕上。这包括布局、绘制和显示页面元素。</li><li><strong>执行JavaScript</strong>：如果页面包含JavaScript，浏览器会执行JavaScript 代码，添加交互和动态行为。</li><li><strong>加载资源</strong>：页面中可能包含外部资源，如图片、样式表、脚本文件等。浏览器会根据需要下载这些资源，以完整地呈现页面。</li><li><strong>完成页面加载</strong>：页面的所有内容和资源加载完成后，浏览器显示完整的页面。</li></ol><h3 id="Day24"><a href="#Day24" class="headerlink" title="Day24"></a>Day24</h3><p><strong>HTTP请求报文和响应报文是怎样的？</strong>**</p><p><strong>HTTP请求报文主要由请求行、请求头、请求体构成</strong>。下面是一个GET请求报文示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/example/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br><span class="line">--------------------------------------</span><br><span class="line">                    -------空白行</span><br><span class="line">                    -------body(这里没有内容)</span><br></pre></td></tr></table></figure><ol><li><strong>请求行</strong>：（请求方法  URL  协议版本号）</li></ol><ul><li>请求方法： GET、POST、PUT、DELETE、PATCH、HEAD、CONNECT、OPTIONS、TRACE</li><li>URL：<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;</code></li><li>协议版本号：HTTP版本号</li></ul><ol start="2"><li><strong>请求头</strong>：包含请求的附加信息，由key:value组成，它可以包含很多不同的字段，用于告知服务器有关请求的详细信息。些常见的请求头部字段包括:</li></ol><ul><li>Host：指定服务器的主机名和端口号</li><li>User-Agent：标识客户端的用户代理(浏览器或其他工具)</li><li>Accept：指定客户端可以接受的响应数据类型。</li><li>Content-Type：指定请求主体的数据类型</li><li>Authorization：用于进行身份验证的凭据。</li></ul><ol start="3"><li>空行：空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。</li><li><strong>请求体</strong>：承载多个请求参数的数据，请求主体是可选的，通常在发送POST、PUT等请求时包含请求的实际数据。例如使用POST请求提交表单数据或上传文件时，请求体会包含这些数据。</li></ol><hr><p><strong>HTTP响应报文</strong>是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关数据。<strong>一个标准的HTTP响应报文通常包含状态行、响应头、响应体</strong>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.4.38 (Unix)</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>session_id=abcd1234; Expires=Wed, 11 Aug 2023 00:00:00 GMT</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">             ----空行</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Example Page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>状态行</strong>：（协议版本号  状态码  状态消息）</li></ol><ul><li>协议版本号：HTTP版本号</li><li>状态码：服务器处理结果的三位数字号码</li><li>状态消息：对状态码的简要描述</li></ul><ol start="2"><li><strong>响应头</strong>：响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：</li></ol><ul><li>Content-Type：指定响应主体的MIME类型:</li><li>Content-Length：指定响应主体的长度(字节数)</li><li>Server：指定服务器的信息。</li><li>Location：在重定向时指定新的资源位置。</li><li>Set-Cookie：在响应中设置Cookie。</li></ul><ol start="3"><li>空行：空行是响应头部和响应主体之间的空行，用于分隔响应头部和响应主体。</li><li><strong>响应体</strong>：响应主体包含服务器返回给客户端的实际数据。例如，当请求一个网页时，响应主体将包含HTML内容。响应主体的存在与否取决于请求的性质以及服务器的处理结果。</li></ol><p><strong>HTTP请求方式有哪些？</strong>**</p><p>HTTP1.1规定了九种标准请求方式，包括<strong>GET、POST、HEAD</strong>、PUT、DELETE、TRACE、PATCH、CONNECT、OPTIONS。其中最常用的就是<strong>GET和POST</strong>请求。详细如下：</p><ol><li><strong>GET：申请获取资源，不对服务器产生影响</strong></li><li><strong>POST：POST请求通常用于发送数据，例如提交表单数据、上传文件等，会影响服务器，服务器可能动态创建新的资源或更新原有资源。</strong></li><li><strong>HEAD：类似GET，仅要求服务器返回头部信息，不返回实际的资源内容</strong></li><li>PUT：用于更新服务器上的资源或创建新资源。（<strong>与POST的区别是：PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</strong>）</li><li>DELETE：请求服务器删除指定的资源。</li><li>TRACE：用于测试。要求目标服务器返回原始的HTTP请求内容。</li><li>PATCH：用于对资源进行部分更新。</li><li>CONNECT：用于代理服务器。</li><li>OPTIONS：用于获取服务器支持的HTTP方法列表，以及针对指定资源支持的方法。</li></ol><p><strong>GET请求和POST请求的区别？</strong>***</p><ol><li><strong>使用场景：</strong>GET请求和POST请求都是HTTP请求方法，GET请求用于从服务器<strong>获取数据</strong>，POST请求用于向服务器<strong>发送数据</strong>。</li><li><strong>传递参数</strong></li></ol><ul><li>GET请求的参数一般写在URL中，所以GET传送的数据量较小，不能大于2KB，且只接受ASCII字符</li><li>POST请求参数一般放在请求体中，所以其请求信息没有长度限制，对于数据类型也没有限制</li></ul><ol start="3"><li><strong>安全和幂等</strong></li></ol><blockquote><p><strong>安全：在HTTP协议中安全指的是请求方法不会破坏服务器上的资源。</strong></p><p><strong>幂等：多次执行相同的操作，结果都相同。</strong></p></blockquote><ul><li>GET为安全幂等的，因为它为只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的</li><li>POST因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</li></ul><ol start="4"><li><strong>缓存机制：</strong>GET请求可以被浏览器缓存，POST请求不会被缓存。</li><li><strong>时间消耗</strong></li></ol><ul><li>GET 产生一个 TCP 数据包，浏览器会把 header 和 data 一并发送出去，服务器响应 200(返回数据)</li><li>POST产生两个TCP 数据包，对于POST，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok(返回数据)</li></ul><ol start="6"><li><strong>编码方式</strong></li></ol><ul><li>GET 请求只能进行 URL编码 <code>application/x-www-form-urlencoded</code> </li><li>POST 支持多种编码方式 <code>application/x-www-form-urlencoded</code>或 <code>multipart/form-data</code>（为二进制数据使用多种编码）。</li></ul><h3 id="Day25"><a href="#Day25" class="headerlink" title="Day25"></a>Day25</h3><p><strong>HTTP请求中常见的状态码？</strong>**</p><p><img src="/post/f4c4d599/1724768356156-4e8d7332-abcc-4e62-b65f-b03f28b61282.png"></p><p><strong>什么是强缓存和协商缓存？</strong>**</p><p><a href="https://t.zsxq.com/12AlZ293Z">知识星球回答连接</a></p><p><a href="https://blog.csdn.net/cuclife/article/details/136510628">强制缓存与协商缓存：概念原理、区别、适用场景和具体示例-CSDN博客</a></p><ol><li><strong>强制缓存是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</strong>其工作原理是是通过HTTP响应头中的特定字段来控制的，例如<code>Expires</code>和<code>Cache-Control</code>，它们指示了资源缓存的有效时间。当浏览器在有效时间内再次请求同一资源时，它会直接从本地缓存中获取该资源，而不会向服务器发送请求。</li></ol><ul><li><code>Expires</code><strong>强缓存</strong>：<code>Expires</code>表示未来资源会过期的时间点，当时间超过了<code>Expires</code>设置的时间点，浏览器就会重定向服务器请求资源。</li></ul><blockquote><p>因为<code>Expires</code>判断强缓存过期机制是获取本地时间戳与之前拿到资源文件中的<code>Expires</code>字段的时间做比较，来判断是否需要对服务器发起请求。<strong>这里有一个巨大的漏洞：如果本地时间不准确则会导致出现错误。</strong></p></blockquote><ul><li><code>Cache-Control</code><strong>强缓存</strong>：在HTTP1.1中增加了该字段，它提供了更灵活的缓存控制机制。例如，可以通过<code>max-age</code>参数设置缓存的最大生存时间（以秒为单位），如<code>Cache-Control: max-age=1200</code>表示缓存有效时间为1200秒。</li></ul><blockquote><p><code>Cache-Control</code>有有六个属性，分别是max-age、s-maxage、no-cache、no-store、private、public。</p><ul><li>max-age决定客户端资源被缓存多久。</li><li>s-maxage决定代理服务器缓存的时长。</li><li>no-cache表示是强制进行协商缓存。</li><li>no-store是表示禁止任何缓存策略。</li><li>public表示资源既可以被浏览器缓存也可以被代理服务器缓存。</li><li>private表示资源只能被浏览器缓存，默认为private。</li></ul></blockquote><ol start="2"><li><strong>协商缓存是浏览器与服务器之间进行通信以确认缓存资源是否仍然有效的过程。</strong></li></ol><p>协商缓存主要涉及两组HTTP头字段：<code>ETag</code>和<code>If-None-Match</code>，以及<code>Last-Modified</code>和<code>If-Modified-Since</code>。它们的工作原理如下：</p><p>ETag&#x2F;If-None-Match：当浏览器第一次请求某个资源时，服务器会返回一个ETag（实体标签），它是一个资源版本的唯一标识符。浏览器在后续请求该资源时，会在请求头中携带If-None-Match字段，其值为先前接收到的ETag。服务器会根据这个值来判断资源是否有更新。如果有更新，服务器会返回新的资源和新的ETag；如果没有更新，服务器会返回304 Not Modified状态码，告诉浏览器可以使用缓存中的资源。</p><p>Last-Modified&#x2F;If-Modified-Since：类似于ETag机制，但Last-Modified记录的是资源最后修改的时间。浏览器在后续请求时，会在请求头中携带If-Modified-Since字段，其值为先前接收到的Last-Modified时间。服务器会检查资源的最后修改时间是否在这个时间之后。如果是，说明资源有更新，服务器会返回新资源和新的Last-Modified时间；如果不是，服务器同样会返回304 Not Modified状态码。</p><p>todo…</p><h3 id="Day26"><a href="#Day26" class="headerlink" title="Day26"></a>Day26</h3><p><strong>HTTP1.0和HTTP1.1的区别？</strong>***</p><ol><li>长连接</li></ol><ul><li>HTTP1.1支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启Connection: Keep-Alive。</li><li>HTTP1.0默认为短连接，每次请求都需要建立一个TCP连接。</li></ul><ol><li>缓存</li></ol><ul><li>HTTP1.0主要使用If-Modified-Since&#x2F;Expires来做为缓存判断的标准。</li><li>HTTP1.1则引入了更多的缓存控制策略例如Entity tag， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li></ul><ol><li>管道化</li></ol><ul><li>基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。</li></ul><ol><li>增加Host字段</li></ol><ul><li>使得一个服务器能够用来创建多个 Web 站点。</li></ul><ol><li>状态码</li></ol><ul><li>新增了24个错误状态响应码。</li></ul><ol><li>带宽优化</li></ol><ul><li>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。</li><li>HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）。</li></ul><p><strong>HTTP2.0与HTTP1.1的区别？***</strong></p><ol><li>二进制分帧：在应用层（HTTP&#x2F;2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。 </li><li>多路复用（MultiPlexing），允许同时通过单一的 HTTP&#x2F;2 连接发起多重的请求-响应消息，这个强大的功能则是基于“二进制分帧”的特性。 </li><li>首部压缩，HTTP1.1 不支持 header 数据的压缩，HTTP&#x2F;2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。高效的压缩算法可以很大的压缩 header ，减少发送包的数量从而降低延迟。 </li><li>服务端推送（server push），在 HTTP&#x2F;2 中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，而无需客户端明确的请求。</li></ol><p><strong>HTTP3.0有了解过吗？</strong>**</p><hr><h3 id="Day27"><a href="#Day27" class="headerlink" title="Day27"></a>Day27</h3><p><strong>HTTPS和HTTP有哪些区别？</strong>***</p><ol><li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密。</li><li>HTTP 的端口号是 80，HTTPS 是 443。</li><li>HTTPS 需要到 CA 申请证书。</li><li>HTTP 的连接简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol><p><strong>HTTPS工作原理？*</strong>*</p><ol><li>首先，客户端向服务器端发送请求报文，请求与服务端建立连接。 </li><li>服务端产生一对公私钥，然后将自己的公钥发送给CA机构，CA机构也有一对公私钥，然后CA机构使用自己的私钥将服务端发送过来的公钥进行加密，产生一个CA数字证书。 </li><li>服务端响应客户端的请求，将CA机构生成的数字证书发送给客户端。 </li><li>客户端将服务端发送过来的数字证书进行解析(因为浏览器产商跟CA机构有合作，所以浏览器中已经保存了大部分CA机构的密钥，用于对服务端发送过来的数字证书进行解密)，验证这个数字证书是否合法，如果不合法，会发送一个警告。如果合法，取出服务端生成的公钥。 </li><li>客户端取出公钥并生成一个随机码key（其实就是对称加密中的密钥） </li><li>客户端将加密后的随机码key发送给服务端，作为接下来的对称加密的密钥 </li><li>服务端接收到随机码key后，使用自己的私钥对它进行解密，然后获得到随机码key。 </li><li>服务端使用随机码key对传输的数据进行加密，在传输加密后的内容给客户端 </li><li>客户端使用自己生成的随机码key解密服务端发送过来的数据，之后，客户端和服务端通过对称加密传输数据，随机码Key作为传输的密钥。</li></ol><hr><h3 id="Day28"><a href="#Day28" class="headerlink" title="Day28"></a>Day28</h3><p><strong>TCP和UDP的区别？</strong>***</p><ol><li>TCP与UDP的概念</li></ol><ul><li>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 </li><li>UDP（用户数据报协议）为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法。</li></ul><ol><li>特点</li></ol><ul><li>TCP：面向连接，传输可靠，传输形式为字节流，传输效率慢，所需资源多。 </li><li>UDP：无连接、传输不可靠、传输形式为数据报文段，传输效率快，所需资源少。</li></ul><ol><li>区别</li></ol><p>3.1、是否面向连接: TCP 是面向连接的传输，UDP 是无连接的传输。 </p><p>3.2、是否是可靠传输：TCP是可靠的传输服务，在传递数据之前，会有三次握手来建立连接；在数据传递时，有确认、窗口、重传、拥塞控制机制。 UDP是不可靠传输，数据传递不需要给出任何确认，且不保证数据不丢失及到达顺序。 </p><p>3.3、是否有状态：TCP 传输是有状态的，它会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等，而 UDP 是无状态的。 </p><p>3.4、传输形式: TCP 是面向字节流的，UDP 是面向报文的。 </p><p>3.5、传输效率:由于TCP 传输的时候多了连接、确认重传等机制，所以TCP 的传输效率要比UDP 低。 </p><p>3.6、首部开销 :TCP 首部开销 (20 ~ 60字节)比UDP 首部开销 (8字节)要大。 </p><p>3.7、是否提供广播或多播服务: TCP 只支持点对点通信UDP 支持一对一、一对多、多对一、多对多。 </p><ol><li>对应的使用场景 TCP常用于要求通信数据可靠场景（如网页浏览、文件传输、邮件传输、远程登录、数据库操作等）。 UDP常用于要求通信速度高场景（如域名转换、视频直播、实时游戏等）。</li></ol><p><strong>TCP连接如何确保可靠性？***</strong></p><ol><li><p><strong>建立连接：</strong>通过三次握手建立连接，保证连接实体真实存在。</p></li><li><p><strong>序列号：</strong>保证数据是按序、完整到达。</p></li><li><p><strong>确认机制：</strong>通过 ARQ 协议实现。基本原理是每发完⼀个分组就停止发送，等待对方确认。如果没收到确认，会重发数据包，直到确认后再发下⼀个分组。</p></li><li><p><strong>合理分片：</strong>tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。</p></li><li><p><strong>校验和：</strong>TCP报文头有校验和，用于校验报文是否损坏。</p></li><li><p><strong>超时重传：</strong>如果发送一直收不到应答，可能是发送数据丢失，也可能是应答丢失，发送方再等待一段时间之后都会进行重传。</p></li><li><p><strong>流量控制：</strong>当接收方来不及处理发送方的数据，能通过<strong>滑动窗口</strong>，提示发送方降低发送的速率，防止包丢失。</p></li><li><p><strong>拥塞控制：</strong>网络层拥堵造成的拥塞，包括慢启动，拥塞避免，快速重传三种机制。</p></li></ol><blockquote><p>拥塞控制算法主要有以下几种:</p><ol><li><p>慢启动</p><p>在连接刚开始时，发送方会逐渐增加发送窗口大小，从而以指数增长的速度增加发送的数据量</p></li><li><p>拥塞避免</p><p>一旦慢启动阶段过去，发送方进入拥塞避免阶段。在这个阶段，发送方逐渐增加发送窗口的大小，但增加速率较慢，避免过快增加导致网络拥塞。</p></li><li><p>超时重传</p><p>如果发送方在超时时间内未收到确认，它会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后手段，用于检测和处理网络中的丢包或拥塞情况。当网络出现拥塞，也就是会发生数据包重传。</p></li><li><p>快速重传(Fast Retransmit)和快速恢复(Fast Recovery)</p><p>当发送方发送的数据包丢失或网络出现拥塞时，接收方会发送重复确认(duplicate ACK)通知发送方有数据包丢失。当发送方收到一定数量的重复确认时，它会立即重传丢失的数据包，而不是等待超时。这样可以减少网络的拥塞程度。</p></li><li><p>拥塞窗口调整</p><p>发送方根据网络的拥塞程度动态调整发送窗口的大小，通过监测网络延迟和丢包情况来确定合适的发送速率，以避免网络拥塞。</p></li></ol></blockquote><p><strong>UDP怎么实现可靠传输？</strong>**</p><p><a href="https://zhuanlan.zhihu.com/p/643186276">字节一面：如何用 UDP 实现可靠传输？ - 知乎 (zhihu.com)</a></p><hr><h3 id="Day29"><a href="#Day29" class="headerlink" title="Day29"></a>Day29</h3><p><strong>三次握手的过程，为什么是三次？***</strong></p><ul><li><p><strong>三次握手才可以防止失效的连接请求被服务端接受从而残生错误。</strong>（主要原因）</p></li><li><p>三次握手才可以同步双方的初始序列号。因为两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p></li><li><p>三次握手才可以避免资源浪费。</p></li></ul><p><img src="/post/f4c4d599/MyInterview%5C1726662640422-48515338-86ef-4ab8-a020-15ff440baada.webp"></p><p><strong>四次挥手的过程，为什么是四次？***</strong></p><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭了 TCP 连接。 总结：两次握手可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/26680969/1726662651105-100e5e76-f041-41e8-af88-50dabeec5f06.webp" alt="img"></p><p><strong>TIME-WAIT状态为什么要等待 2MSL 时间后才进入CLOSED状态？</strong></p><p>为了保证服务端能收到客户端的确认应答。若客户端发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，服务端等待超时后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端永远无法正常关闭。</p><p><strong>HTTP的Keep-Alive是什么？TCP 的Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？*</strong>*</p><p><strong>HTTP 的 Keep-Alive</strong>，是由应用层(用户态)实现的，称为 HTTP 长连接；</p><p>每次请求都要经历这样的过程：建立 TCP -&gt;请求资源 -&gt;响应资源 -&gt;释放连接，这就是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP 的 Keep-Alive实现了使用同一个TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，就就是 HTTP 长连接。</p><p><strong>TCP 的 Keepalive</strong>，是由 TCP 层(内核态)实现的，称为 TCP 保活机制；</p><p>通俗地说，就是TCP有一个定时任务做倒计时，超时后会触发任务，内容是发送一个探测报文给对端，用来判断对端是否存活。Day30</p><p><strong>DNS查询过程？</strong>**</p><p><strong>CDN是什么？</strong>**</p><p><strong>Cookie和Session是什么?有什么区别？</strong>**</p><p>Cookie和Session都是Web开发中用于跟踪用户状态的技术，但它们在存储位置、数据容量、安全性以及生命周期等方面存在显著差异：</p><ol><li>存储位置：Cookie的数据存储在客户端（通常是浏览器）。当浏览器向服务器发送请求时，会自动附带Cookie中的数据。Session的数据存储在服务器端。服务器为每个用户分配一个唯一的Session ID，这个ID通常通过Cookie或URL重写的方式发送给客户端，客户端后续的请求会带上这个Session ID，服务器根据ID查找对应的Session数据。</li><li>数据容量：单个Cookie的大小限制通常在4KB左右，而且大多数浏览器对每个域名的总Cookie数量也有限制。由于Session存储在服务器上，理论上不受数据大小的限制，主要受限于服务器的内存大小。</li><li>安全性：Cookie相对不安全，因为数据存储在客户端，容易受到XSS（跨站脚本攻击）的威胁。不过，可以通过设置HttpOnly属性来防止JavaScript访问，减少XSS攻击的风险，但仍然可能受到CSRF（跨站请求伪造）的攻击。Session通常认为比Cookie更安全，因为敏感数据存储在服务器端。但仍然需要防范Session劫持（通过获取他人的Session ID）和会话固定攻击。</li><li>生命周期：Cookie可以设置过期时间，过期后自动删除。也可以设置为会话Cookie，即浏览器关闭时自动删除。Session在默认情况下，当用户关闭浏览器时，Session结束。但服务器也可以设置Session的超时时间，超过这个时间未活动，Session也会失效。</li><li>性能：使用Cookie时，因为数据随每个请求发送到服务器，可能会影响网络传输效率，尤其是在Cookie数据较大时。使用Session时，因为数据存储在服务器端，每次请求都需要查询服务器上的Session数据，这可能会增加服务器的负载，特别是在高并发场景下。</li></ol><h3 id="Day30-dns查询、cdn、cookie-session"><a href="#Day30-dns查询、cdn、cookie-session" class="headerlink" title="Day30(dns查询、cdn、cookie&#x2F;session)"></a>Day30(dns查询、cdn、cookie&#x2F;session)</h3><p><strong>DNS查询过程？*</strong>*</p><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。 </p><ol><li>首先用户在浏览器输入URL地址后，会先查询浏览器缓存是否有该域名对应的IP地址。 </li><li>如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存。 </li><li>如果Host文件中也没有则会向本地的DNS解析器（通常由你的互联网服务提供商（ISP）提供）发送一个DNS查询请求。 </li><li>如果本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域（.com&#x2F;.net&#x2F;.org）的DNS服务器继续查询。 </li><li>本地DNS解析器接着向指定的顶级域DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能告诉本地DNS解析器应该前往哪个权威DNS服务器查询下一步的信息。 </li><li>本地DNS解析器最后向权威DNS服务器发送查询请求。 权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找”example.com”域名对应的IP地址，并将结果返回给本地DNS解析器。 </li><li>本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地响应。</li></ol><p><strong>CDN是什么？*</strong>*</p><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p><strong>通俗易懂的解释：</strong></p><p>通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p><p>作用：</p><ol><li>加速用户对该网站的打开速度，提升用户体验。</li><li>网站不容易宕机，多个服务器达到负载均衡，不会让流量集中涌入其中某一台服务器。</li><li>解决延迟问题，提高直播等相关内容的时效性。</li></ol><p><strong>Cookie 和 Session 是什么？又什么区别？</strong></p><p>Cookie 和 Session 都用于管理用户的状态和身份，Cookie 通过在客户端记录信息确定用户<br>身份， Session 通过在服务器端记录信息确定用户身份。</p><ol><li>Cookie</li></ol><ul><li>Cookie 是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常，服务器会将一个或多个 Cookie 发送到用户浏览器，然后浏览器将这些 Cookie 存储在本地。</li><li>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li></ul><ol start="2"><li>Session<br>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 Session。Session 主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。</li></ol><p><strong>区别：</strong></p><ul><li><strong>存储位置</strong>：Cookie 数据存储在用户的浏览器中，而 Session 数据存储在服务器上。</li><li><strong>数据容量</strong>：Cookie 存储容量较小，一般为几 KB。Session 存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</li><li><strong>安全性</strong>：由于 Cookie 存储在用户浏览器中，因此可以被用户读取和篡改。相比之下Session 数据存储在服务器上，更难被用户访问和修改。</li><li><strong>传输方式</strong>：Cookie 在每次 HTTP 请求中都会被自动发送到服务器，而 Session ID 通常通过 Cookie 或 URL 参数传递。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Day31"><a href="#Day31" class="headerlink" title="Day31"></a>Day31</h3><p><strong>进程和线程的区别？</strong>***</p><p><strong>进程是系统进行资源调度和分配的的基本单位，实现了操作系统的并发。</strong></p><p><strong>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</strong>一个进程由一个或多个线程组成，这些线程共享同一块内存。</p><p>区别：</p><ol><li><strong>资源开销</strong></li></ol><ul><li>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</li><li>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需要保存和恢复少量的线程上下文，因此上下文切换的开销较小。</li></ul><ol start="2"><li><strong>通信与同步</strong></li></ol><ul><li>进程：由于进程间相互隔离，进程之间的通信需要使用一些特殊机制，如管道、消息队列、共享内存等。</li><li>线程：由于线程共享相同的内存空间，它们之间可以直接访问共享数据，线程间通信更加方便。</li></ul><ol start="3"><li><strong>安全性</strong></li></ol><ul><li>进程：由于进程间相互隔离，一个进程的崩溃不会直接影响其他进程的稳定性。</li><li>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</li></ul><p><strong>并行和并发有什么区别？</strong>**</p><blockquote><p>并行是在同一时刻执行多个任务</p><p>并发是在相同的时间段内执行多个任务，任务可能交替执行，通过调度实现。</p></blockquote><p>并行是指在同一时刻执行多个任务，这些任务可以同时进行，每个任务都在不同的处理单元(如多个CPU核心)上执行。在并行系统中，多个处理单元可以同时处理独立的子任务，从而加速整体任务的完成。</p><p>并发是指在相同的时间段内执行多个任务，这些任务可能不是同时发生的，而是交替执行，通过时间片轮转或者事件驱动的方式。并发通常与任务之间的交替执行和任务调度有关。</p><p><strong>解释一下用户态和核心态？</strong>**</p><p>用户态 <code>User Mode</code> 和核心态 <code>Kernel Mode</code> 是操作系统中两种不同的执行模式，用于<strong>控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p><ul><li>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li><li>核心态：核心态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0的状态我们称之为内核态。</li></ul><blockquote><p>什么场景下，会发生内核态和用户态的切换</p><ul><li>系统调用：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态</li><li>异常：当程序执行过程中出现错误或异常情况时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。</li><li>中断：外部设备(如键盘、鼠标、磁盘等)产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态</li></ul></blockquote><h3 id="Day32"><a href="#Day32" class="headerlink" title="Day32"></a>Day32</h3><p><strong>进程调度算法你了解多少？</strong>**</p><p>进程调度算法是操作系统中用来管理和调度进程(也称为任务或作业)执行的方法。这些算法决定了</p><p>在多任务环境下，如何为各个进程分配 CPU 时间，以实现公平性、高吞吐量、低延迟等不同的调度</p><p>目标。</p><ol><li>先来先服务调度算法</li></ol><p>按照进程到达的先后顺序进行调度，即最早到达的进程先执行，直到完成或阻塞，</p><ol start="2"><li>最短作业优先调度算法</li></ol><p>优先选择运行时间最短的进程来运行</p><ol start="3"><li>高响应比优先调度算法</li></ol><p>综合考虑等待时间和服务时间的比率，选择具有最高响应比的进程来执行</p><ol start="4"><li>时间片轮转调度算法将CPU 时间划分为时间片(时间量)，每个进程在一个时间片内运行，然后切换到下一个进程。</li><li>最高优先级调度算法</li></ol><p>为每个进程分配一个优先级，优先级较高的进程先执行。这可能导致低优先级进程长时间等待可能引发饥饿问题。</p><ol start="6"><li>多级反馈队列调度算法</li></ol><p>将进程划分为多个队列，每个队列具有不同的优先级，进程在队列之间移动。具有更高优先级的队列的进程会更早执行，而长时间等待的进程会被提升到更高优先级队列。</p><ol start="7"><li>最短剩余时间优先</li></ol><p>每次选择剩余执行时间最短的进程来执行。</p><ol start="8"><li>最大吞吐量调度</li></ol><p>旨在最大化单位时间内完成的进程数量</p><ol start="9"><li>最大吞吐量调度</li></ol><p>旨在最大化单位时间内完成的进程数量</p><p><strong>进程间有哪些通信方式？</strong>***</p><ol><li><strong>管道：</strong>是一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。</li><li>命名管道：也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li><strong>信号量：</strong>是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>消息队列：</strong>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号：用于通知接收进程某个事件已经发生，从而迫使进程执行信号处理程序。</li><li><strong>共享内存：</strong>就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程通信方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，比如信号量配合使用，来实现进程间的同步和通信。</li><li><code>Socket</code> 套接字：是支持TCP&#x2F;IP 的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。</li></ol><p><strong>解释一下进程同步和互斥，以及如何实现进程同步和互斥？</strong>**</p><p><strong>进程同步是指多个并发执行的进程之间协调和管理它们的执行顺序，以确保它们按照一定的顺序或时间间隔执行。</strong>比如说，你想要和你的队友一起完成一个副本，你们需要相互配合，有时候等待对方的信号或者消息，有时候按照对方的要求执行某些动作，这就是进程同步。</p><p><strong>互斥指的是在某一时刻只允许一个进程访问某个共享资源。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。</strong>比如说，你想要使用一个祭坛来祈愿，但是这个祭坛一次只能被一个人使用，如果有其他人也想要使用，他们就必须等待你使用完毕后再去使用，这就是进程互斥。</p><p>解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是<strong>使用信号量和 PV 操作</strong>。信号量是一种特殊的变量，它表示系统中某种资源的数量或者状态。PV 操作是一种对信号量进行增加或者减少的操作，它们可以用来控制进程之间的同步或者互斥。</p><p>举个例子，假设有一个信号量s表示一个祭坛是否可用，初始值为 1。如果 s 的值为 1，表示祭坛空闲；如果 s 的值为 0，表示祭坛被占用;如果 s 的值为 -1，表示有一个人在等待使用祭坛。那么我们可以用 PV 操作来实现对祭坛的互斥访问:</p><ul><li>如果你想要使用祭坛，你就执行 P(s)操作，将 s 的值减 1。如果结果为 0或者正数，表示你可以使用祭坛;如果结果为负数，表示有人在使用祭坛，你就必须等待。</li><li>如果你使用完了祭坛，你就执行 V(s)操作，将 s 的值加 1。如果结果为正数或者 0，表示没有人在等待使用祭坛;如果结果为负数，表示有人在等待使用祭坛，你就需要唤醒他们中的一个。</li></ul><p>这样就可以保证每次只有一个人能够使用祭坛，实现了进程互斥。</p><p>除此之外，下面的方法也可以解决进程同步和互斥问题:</p><ul><li>临界区(Critical Section)：将可能引发互斥问题的代码段称为临界区。为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。</li><li>互斥锁(Mutex)：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。</li><li>条件变量(Condition Variable)：条件变量用于在进程之间传递信息，以便它们在特定条件下等待或唤醒。通常与互斥锁一起使用，以确保等待和唤醒的操作在正确的时机执行。</li></ul><h3 id="Day33"><a href="#Day33" class="headerlink" title="Day33"></a>Day33</h3><p><strong>什么是死锁，如何预防死锁？</strong>***</p><p>死锁是指<strong>两个或多个进程在争夺系统资源时，由于互相等待对方释放资源而无法继续执行的状态。</strong></p><p>死锁只有同时满足以下四个条件才会发生:</p><ul><li><strong>互斥条件：</strong>一个进程占用了某个资源时，其他进程无法同时占用该资源</li><li><strong>请求保持条件：</strong>一个线程因为请求资源而阻塞的时候，不会释放自己的资源</li><li><strong>不可剥夺条件：</strong>资源不能被强制性地从一个进程中剥夺，只能由持有者自愿释放，</li><li><strong>环路等待条件：</strong>多个进程之间形成一个循环等待资源的链，每个进程都在等待下一个进程所占有的资源。</li></ul><p>只需要破坏上面一个条件就可以破坏死锁。</p><ul><li><strong>破坏请求与保持条件：</strong>一次性申请所有的资源，</li><li><strong>破坏不可剥夺条件：</strong>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件：</strong>靠<strong>按序申请资源</strong>来预防。让所有进程按照相同的顺序请求资源，释放资源则反序释放。</li></ul><p><strong>介绍一下几种典型的锁？</strong>**</p><p>详见day9</p><p>两个基础的锁：</p><ul><li>互斥锁：互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。</li><li>自旋锁：自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。</li></ul><p>其他的锁都是基于这两个锁的</p><ul><li>读写锁：允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读(共享)和写(排他)两种状态。</li><li>悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁</li><li>乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作</li></ul><p><strong>什么是虚拟内存？为什么需要虚拟内存？</strong>**</p><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续虚拟地址空间，<strong>它不是真实存在的</strong>，而是通过映射与实际地址空间对应，这样就可以使每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存 RAM 更大的地址空间，每个程序都可以认为它拥有足够的内存来运行。</p><p>需要虚拟内存的原因：</p><ul><li>**内存扩展: **虚拟内存使得每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据</li><li><strong>内存隔离：</strong>虚拟内存还提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存，</li><li><strong>物理内存管理：</strong>虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</li><li><strong>页面交换：</strong>当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</li><li><strong>内存映射文件：</strong>虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</li></ul><h3 id="Day34"><a href="#Day34" class="headerlink" title="Day34"></a>Day34</h3><p><strong>你知道的线程同步的方式有哪些？</strong>**</p><p>线程同步机制是指在多线程编程中，为了保证线程之间的互不干扰，而采用的一种机制。常见的线程同步机制有以下几种：</p><ol><li><strong>互斥锁：</strong>互斥锁是最常见的线程同步机制。它允许只有一个线程同时访问被保护的临界区(共享资源)。</li><li><strong>条件变量：</strong>条件变量用于线程间通信，允许一个线程等待某个条件满足，而其他线程可以发出信号通知等待线程。通常与互斥锁一起使用。</li><li><strong>读写锁：</strong>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入资源。</li><li><strong>信号量：</strong>用于控制多个线程对共享资源进行访问的工具。</li></ol><p><strong>有哪些页面置换算法？</strong>**</p><p><a href="https://www.cnblogs.com/Leophen/p/11397699.html">页面置换算法详解 - Leophen - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/m0_75262255/article/details/139337506">操作系统之页面置换算法——FIFO、OPT和LRU_fifo替换算法-CSDN博客</a></p><blockquote><p>页面置换算法是什么？</p><p>进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，其中选择调出页面的算法就称为<strong>页面置换算法</strong>。</p><p>好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</p></blockquote><h3 id="Day35"><a href="#Day35" class="headerlink" title="Day35"></a>Day35</h3><p><strong>熟悉哪些Linux命令？</strong>**</p><ol><li><font style="color:rgb(1, 1, 1);">文件相关(mv mkdir cd ls)</font></li><li><font style="color:rgb(1, 1, 1);">进程相关( ps top netstate )</font></li><li><font style="color:rgb(1, 1, 1);">权限相关(chmod chown useradd groupadd)</font></li><li><font style="color:rgb(1, 1, 1);">网络相关(netstat ip addr)</font></li><li><font style="color:rgb(1, 1, 1);">测试相关(测试网络连通性：ping；测试端口连通性：telnet)</font></li></ol><p><strong>如何查看某个端口有没有被占用？</strong>**</p><ol><li><code>netstat</code> 或 <code>ss命令</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep 端口号</span><br><span class="line">ss -tuln | grep 端口号</span><br></pre></td></tr></table></figure><ol start="2"><li><code>lsof</code> 命令</li></ol><p>这个命令是查看进程占用哪些文件的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></table></figure><ol start="3"><li><code>fuser</code> 命令</li></ol><p><code>fuser</code>命令和<code>lsof</code>正好相反，是查看某个文件被哪个进程占用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fuser 22/tcp -v</span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">22/tcp:              root       1329 F.... sshd</span><br><span class="line">                     root       1606 f.... sshd</span><br></pre></td></tr></table></figure><ol start="4"><li>nmap工具</li></ol><p>nmap默认总是会扫描端口，要扫描本机端口，很方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nmap localhost</span><br><span class="line"></span><br><span class="line">Starting Nmap 5.51 ( http://nmap.org ) at 2018-03-03 18:00 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> localhost (127.0.0.1)</span><br><span class="line">Host is up (0.0000020s latency).</span><br><span class="line">Other addresses <span class="keyword">for</span> localhost (not scanned): 127.0.0.1</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">25/tcp open  smtp</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 0.06 seconds</span><br></pre></td></tr></table></figure><p><strong>说一下 select、poll、epoll？了解I&#x2F;O多路复用吗？</strong>**</p><p><a href="https://www.cnblogs.com/flashsun/p/14591563.html">图解 | 原来这就是 IO 多路复用 - 闪客sun - 博客园 (cnblogs.com)</a></p><p>select，poll，epoll 都是 I&#x2F;O 多路复用的机制。</p><p>I&#x2F;O多路复用是一种在单个线程中管理多个输入&#x2F;输出通道的技术。它允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程。</p><p>常见的I&#x2F;O多路复用机制包括select、poll和epoll。这些机制通过将多个I&#x2F;O通道注册到一个事件管理器中，然后通过阻塞方式等待事件的发生。一旦有事件发生（如有数据可读或可写），线程就会被唤醒，然后可以针对具体的事件进行处理。</p><ul><li>当我们调用 select 函数时会传入一个文件描述符集合(fd_set)，内核会根据 IO 状态对 fd_set 的内容进行修改，从而通知执行 select 函数的进程哪一个文件或者 Socket 是可读的。</li></ul><blockquote><p>select的缺点：</p><ol><li>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</li><li>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</li><li>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</li></ol></blockquote><ul><li>poll 和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</li><li>epoll 主要就是针对select的三个缺点进行了改进。改进如下：</li></ul><ol><li>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</li><li>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li><li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</li></ol><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><strong>常见的排序算法说一下？也说一下各个时间复杂度？</strong>***</p><p><img src="/post/f4c4d599/1722855291493-b9c8a325-7a8c-482b-9072-cb6d74f0e76a.webp"></p><ul><li><font style="color:rgb(1, 1, 1);">冒泡排序：通过相邻元素的比较和交换，每次将最大（或最小）的元素逐步“冒泡”到最后（或最前）。时间复杂度：最好情况下O(n)，最坏情况下O(n^2)，平均情况下O(n^2)。，空间复杂度：O(1)。</font></li><li><font style="color:rgb(1, 1, 1);">插入排序：将待排序元素逐个插入到已排序序列的合适位置，形成有序序列。时间复杂度：最好情况下O(n)，最坏情况下O(n^2)，平均情况下O(n^2)，空间复杂度：O(1)。</font></li><li><font style="color:rgb(1, 1, 1);">选择排序（Selection Sort）：通过不断选择未排序部分的最小（或最大）元素，并将其放置在已排序部分的末尾（或开头）。时间复杂度：最好情况下O(n^2)，最坏情况下O(n^2)，平均情况下O(n^2)，空间复杂度：O(1)。</font></li><li><font style="color:rgb(1, 1, 1);">快速排序（Quick Sort）：通过选择一个基准元素，将数组划分为两个子数组，使得左子数组的元素都小于（或等于）基准元素，右子数组的元素都大于（或等于）基准元素，然后对子数组进行递归排序。时间复杂度：最好情况下O(nlogn)，最坏情况下O(n^2)，平均情况下O(nlogn)，空间复杂度：最好情况下O(logn)，最坏情况下O(n)。</font></li><li><font style="color:rgb(1, 1, 1);">归并排序（Merge Sort）：将数组不断分割为更小的子数组，然后将子数组进行合并，合并过程中进行排序。时间复杂度：最好情况下O(nlogn)，最坏情况下O(nlogn)，平均情况下O(nlogn)。空间复杂度：O(n)。</font></li><li><font style="color:rgb(1, 1, 1);">堆排序（Heap Sort）：通过将待排序元素构建成一个最大堆（或最小堆），然后将堆顶元素与末尾元素交换，再重新调整堆，重复该过程直到排序完成。时间复杂度：最好情况下O(nlogn)，最坏情况下O(nlogn)，平均情况下O(nlogn)。空间复杂度：O(1)。</font></li></ul>]]></content>
    
    
    <summary type="html">常见面试问题</summary>
    
    
    
    <category term="Java" scheme="https://threewood1.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="Interviews" scheme="https://threewood1.top/tags/Interviews/"/>
    
    <category term="MySQL" scheme="https://threewood1.top/tags/MySQL/"/>
    
    <category term="Redis" scheme="https://threewood1.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM常见面试问题</title>
    <link href="https://threewood1.top/post/c257a468.html"/>
    <id>https://threewood1.top/post/c257a468.html</id>
    <published>2024-06-17T06:18:17.000Z</published>
    <updated>2024-11-05T09:19:17.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM常见问题"><a href="#JVM常见问题" class="headerlink" title="JVM常见问题"></a>JVM常见问题</h1><h2 id="JVM主要组成部分"><a href="#JVM主要组成部分" class="headerlink" title="JVM主要组成部分"></a>JVM主要组成部分</h2><ul><li><strong>类加载器</strong></li><li><strong>运行时数据区</strong></li><li><strong>执行引擎</strong></li><li><strong>本地库接口</strong></li></ul><p>首先通过类加载器<code>ClassLoader</code>将<code>java</code>代码转为字节码，运行时数据区<code>Runtime Data Area</code>再把字节码加载到内存中，而字节码文件只是JVM的一套指令规范，并不能直接交给底层操作系统去执行，因此需要特定命令解析器执行引擎<code>Execution Engine</code>，将字节码翻译为底层系统指令，再交给<code>CPU</code>执行，而这个过程中需要调用其它语言的本地接口来实现整个程序的功能。</p><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><strong>介绍JVM内存结构，哪些是线程私有的？哪些会发生OOM(OutOfMemory内存溢出)？</strong></p><p>根据JVM规范，JVM内存共分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。</p><ul><li>堆（Heap）：<strong>线程共享</strong>。所有的<strong>对象实例</strong>以及<strong>数组</strong>都要在堆上分配。<strong>垃圾回收器</strong>主要管理的对象。</li><li>方法区（Method Area）：<strong>线程共享</strong>。存储<strong>类信息、常量、静态变量</strong>、即时编译器编译后的代码。</li><li>虚拟机栈（JVM Stack）：<strong>线程私有</strong>。存储<strong>局部变量表、操作数栈、动态链接、方法出口，对象指针</strong>。</li><li>本地方法栈（Native Method Stack）：<strong>线程私有</strong>。为虚拟机使用到的 <strong>Native 方法</strong>服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。</li><li>程序计数器（Program Counter Register）：<strong>线程私有</strong>。有些文章也翻译成<strong>PC寄存器</strong>（PC Register），同一个东西。它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。存储正在执行的虚拟机字节码指令的地址，指向下一条要执行的指令。</li></ul><p>除了<strong>程序计数器</strong>不会发生OOM之外，其他区域都有可能发生OOM。</p><ul><li><p>堆内存（Heap）：堆内存是Java程序中用于存储对象实例的区域，如果堆内存不足以存储新的对象实例，就会触发OutOfMemoryError。</p></li><li><p>方法区（Method Area）：方法区用于存储类的结构信息、静态变量、常量池等数据。如果方法区无法满足新的类加载、常量存储等需求，就会导致OutOfMemoryError。</p></li><li><p>栈内存（Stack）：栈内存用于存储线程私有的方法调用栈、局部变量等信息。如果线程调用的方法层次太深，栈内存不足，就会抛出StackOverflowError。虽然不是严格意义上的OOM，但也是一种内存相关的错误。</p></li><li><p>本地方法栈（Native Method Stack）：本地方法栈类似于Java栈，但是用于执行Native方法（即用C、C++等语言编写的方法）。如果Native方法调用层次太深，本地方法栈不足，就会抛出StackOverflowError。</p></li><li><p>直接内存（Direct Memory）：直接内存是一种使用NIO库进行I&#x2F;O操作时可能使用的一种内存，它并不受Java虚拟机内存管理系统的管理，因此也有可能发生OOM。</p></li></ul><p><img src="/post/c257a468/format.png" alt="image"></p><h2 id="对象创建机制"><a href="#对象创建机制" class="headerlink" title="对象创建机制"></a><strong>对象创建机制</strong></h2><p>分为五个步骤：<strong>类加载检查、分配内存、初始化内存空间、设置对象头、执行构造函数</strong></p><ul><li><p>类加载检查：当虚拟机(JVM)遇到一条<code>new</code>的指令时，首先将去检查这个指令的参数是否能够在<strong>常量池</strong>中定位到这个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已经被<strong>加载、解析和初始化过</strong>。如果没有，那么就要执行相应的类加载过程。</p><p>总结为 if (new指令的参数不在常量池 || 此符号引用的类没有被加载、解析和初始化过)———&gt;{执行相应类加载}</p></li><li><p>分配内存：在类加载完成后，对象所需的内存大小已完全确定，虚拟机可以对new出来的对象分配内存。主要有两种方式：</p><table><thead><tr><th>指针碰撞</th><th>空闲列表</th></tr></thead><tbody><tr><td>堆内存规整时</td><td>堆内存不规整时</td></tr><tr><td>用过的内存放在一边，没用的放一边，中间有个分界值指针</td><td>JVM维护一个列表记录划分的内存</td></tr><tr><td>GC收集器：Serial、ParNew</td><td>GC收集器：CMS</td></tr></tbody></table><p>堆内存规整与否取决于GC收集器的算法是标记-清除、还是标记-整理</p><p><strong>创建对象时涉及到的问题：</strong></p><p>线程安全：先TLAB再 CAS + 失败重试</p><ul><li><p><strong>CAS+失败重试</strong>： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而且假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</p></li><li><p><strong>TLAB</strong>： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</p></li></ul></li><li><p>初始化内存空间：内存分配完成后，虚拟机需要将分配到的内存空间都<strong>初始化为零值</strong>（<strong>不包括对象头</strong>），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>设置对象头：虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p>执行构造函数：经过1-4步骤，从JVM的角度看一个新的对象已经产生，但从Java程序上看，对象创建才刚开始。执行<code>new</code>指令之后会接着执行构造方法，<strong>把对象按照照程序员的意愿进行初始化</strong>，这样一个真正可用的对象才算完全产生出来。</p></li></ul><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a><strong>对象的结构</strong></h2><p>⼀个对象分为以下几个部分： <strong>对象头，实例数据，对齐填充</strong></p><ul><li><p>对象头：对象头包括两类数据：对象自身的运行时数据和类型指针。</p><ul><li><p>对象自身的运行时数据</p><p>对象⾃身的运⾏时数据叫做 Mark Word，包括哈希码， GC 分代年龄，锁状态标志，线程持有的锁，偏向线程 ID，偏 向时间戳等。其中，Mark Word 是⼀个动态的数据结构，为的就是在极小的空间内存储尽量多的数据。</p></li><li><p>类型指针</p><p>类型指针，对象指向元数据的指针，Java 通过这个来确定对象是哪个类的实例。</p><p>如果对象是数组类型，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数据的长度不确定，将无法通过元数据中的信息判断出数组的大小。</p></li></ul></li><li><p>实例数据：实例数据是对象真正存储的有效信息，也就是我们在程序代码中所定义的各种类型的字段内容，包括从父类继承的。 这部分的存储顺序会受到 HotSpot 虚拟机默认的分配策略参数和字段在 Java 源码中定义顺序的影响。</p></li><li><p>对齐填充：对⻬填充其实不是必然的，作⽤就是在<strong>占位符</strong>，<strong>保证对象的起始地址是 8 字节的整数倍</strong>。 也就是说，任何对象的大小都必须是 8 字节的整数倍，这个是 HotSpot 虚拟机的⾃动内存管理系统的要求。</p></li></ul><h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a><strong>对象访问定位</strong></h2><p>对象的访问的两种方式？区别和优缺点</p><p>Java 通过栈上的 reference 数据来操作堆上的具体对象， 对象访问的两种方式为<strong>句柄和直接指针</strong>。</p><ul><li>句柄方式：Java 堆中将可能会划分除⼀块内存来作为句柄池，然后 reference 储存句柄池的地址，句柄中包含了指向对象实例数据的指针，和对象类型数据的指针。</li><li>直接指针：reference 中存放的是对象地址。</li></ul><p>优缺点：</p><p>句柄方式比较稳定，对象被移动时，只会改变句柄中的实例数据指针，不需要修改 reference 本身。直接指针的话，少了⼀次指针定位的开销，所以好处就是访问速度更快。</p><h2 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a><strong>强引用、软引用、弱引用、虚引用</strong></h2><p><a href="https://segmentfault.com/a/1190000042313862"><strong>Java四大引用详解：强引用、软引用、弱引用、虚引用 - BAT架构技术与大厂面试 - SegmentFault 思否</strong></a></p><p>等级： 强 &gt; 软 &gt; 弱 &gt; 虚</p><p><strong>强引用</strong>是Java中声明对象的默认引用方式，也是使用最多的一种方式，请记住不管内存紧张也罢，不足也罢，gc永不回收强引用的对象， 即使 jvm 出现(内存溢出错误)OutOfMemoryError，使程序停止，也不会回收对象来提高内存。</p><p><strong>软引用</strong>是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><p><strong>弱引用</strong>的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><p><strong>虚引用</strong>是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示。</p><blockquote><p><strong>引用队列</strong>可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p></blockquote><h2 id="如何判断对象死亡"><a href="#如何判断对象死亡" class="headerlink" title="如何判断对象死亡"></a><strong>如何判断对象死亡</strong></h2><p>两种方法：<strong>引用计数器法和可达性分析算法</strong></p><ul><li><p>引用计数器法：给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效时，计数器就减1，任何时刻当计数器为0的时候，这个对象就不能再被使用了。优点：实现简单效率高。缺点：主流 JVM 不使用这个算法，因为无法解决<strong>对象循环依赖</strong>（A依赖B，B依赖A）的问题。</p></li><li><p>可达性分析法：从一系列称作”GC ROOT”的对象作为起点，往下搜索，节点所走过的路径称作引用链。当一个对象到GC ROOT的路径没有引用链的时候，就判断为死亡。</p><p><img src="/post/c257a468/7eb4cb27a90558f3e0d099ac9536ef58.png" alt="img"></p></li></ul><h2 id="JVM垃圾回收机制、垃圾回收算法"><a href="#JVM垃圾回收机制、垃圾回收算法" class="headerlink" title="JVM垃圾回收机制、垃圾回收算法"></a><strong>JVM垃圾回收机制、垃圾回收算法</strong></h2><p>故事版本：<a href="https://www.zhihu.com/question/21535724">JVM垃圾回收算法都有哪些？简述它们的执行过程及优缺点 - 知乎 (zhihu.com)</a></p><p>JVM的垃圾回收机制——垃圾回收算法 <a href="https://zhuanlan.zhihu.com/p/159200599">JVM的垃圾回收机制——垃圾回收算法 - 知乎 (zhihu.com)</a></p><p>垃圾回收算法：</p><ul><li><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><p>该算法分为两个阶段，<strong>标记和清除</strong>。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</p><p><img src="/post/c257a468/v2-7389d400dc04abb145a67fa86a662e33_720w.webp" alt="img"></p></li><li><p>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><p>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</p><p><img src="/post/c257a468/v2-20adb8ac4c5deb44fc27e30c8381281d_720w.webp" alt="img"></p></li><li><p>标记整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><p>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</p><p><img src="/post/c257a468/v2-cc722c4e5b289434d2181451f4fd154c_720w.webp" alt="img"></p></li><li><p>分代收集算法(jdk8)：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><p>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代和永久代。</p><p><img src="/post/c257a468/v2-40cbacd540b1555badbbf89132aace5f_720w.webp" alt="img"></p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；</p><p>年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p><img src="/post/c257a468/v2-f5426caf176fac7d2d7edcf43e127eaa_720w.webp" alt="img"></p><h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，</p><p>回收老年代的收集器包括Serial Old、Parallel Old、CMS，</p><p>有用于回收整个Java堆的G1收集器。</p><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li><strong>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</strong>： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>**G1(Garbage First)收集器 (标记-整理算法)**： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上 “-XX:+UseConcMarkSweepGC” 来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h3 id="G1和CMS"><a href="#G1和CMS" class="headerlink" title="G1和CMS"></a><strong>G1和CMS</strong></h3><p><strong>G1：</strong></p><p>全称<strong>Garbage-First</strong>，之前的收集器因为是直接将堆内存物理划分为新生代老年代，所以需要来两种收集器配合使用才能实现全代的回收。</p><p>以往对于Java堆区域的划分为：<strong>新生代和老年代，新生代又划分为 Eden区和 Survivor区，Survivor区又分为 from区和 to区。</strong>但是现在，G1将整个堆内存划分为多个等大的Region，每个Region都可以成为 Eden空间、Survivor空间、老年代空间。</p><p>Region还有一类特殊的 <strong>Humongous</strong> 区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。如果是那些超过了整个Region容量的超大对象，将会放在连续 N 个 Humongous Region区域。</p><p>对于G1来说整体采用的是<strong>标记-整理算法</strong>，然后从<strong>Region</strong>的角度来看，采用的是<strong>复制算法</strong>。</p><p><img src="/post/c257a468/v2-1287da06a62715cde37c68bc094b0da6_720w.webp" alt="img"></p><p>G1 垃圾收集过程主要分为4个阶段：</p><ol><li><p>初始标记</p><p>标记GC Roots直接关联的对象</p><p>触发STW   </p></li><li><p>并发标记 </p><p>和⽤户程序并发执行，标记出所有回收对象   </p></li><li><p>最终标记 </p><p>处理并发标记后，新产生的对象</p><p>触发STW   </p></li><li><p>筛选回收 </p><p>先对Region的回收价值进行排序，然后根据期望暂停时间，选择性回收Region</p><p>回收时采用标记复制，多条收集器线程并发执行</p><p>不追求⼀次全部清理完</p><p>触发STW</p></li></ol><p><strong>CMS：</strong></p><p><strong>CMS（Concurrent Mark Sweep）垃圾回收器是第一个关注 GC 停顿时间的垃圾收集器。</strong></p><p>在 CMS 垃圾回收器出现之前，无论是 Serious 垃圾回收器，还是 ParNew 垃圾回收器，亦或是 Parallel Scavenge 垃圾回收器，他们在进行垃圾回收的时候都需要 Stop the World，即无法实现垃圾回收线程与用户线程并发执行。<strong>而 CMS 垃圾回收器通过三色标记算法，实现了垃圾回收线程与用户线程并发执行，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。</strong></p><p>对于 CMS 垃圾回收器来说，其实通过<strong>标记 - 清除算法</strong>实现的，它的运行过程分为 4 个步骤，包括：</p><ol><li><p><strong>初始标记，指的是寻找所有被 GCRoots 引用的对象，该阶段需要「Stop the World」</strong></p></li><li><p><strong>并发标记，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop the World」</strong></p></li><li><p><strong>重新标记，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop the World」</strong></p></li><li><p><strong>并发清除，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop the World」</strong></p></li></ol><p><strong>主要优点</strong>：并发收集、低停顿</p><p>但是它有下⾯三个明显的<strong>缺点</strong>：  </p><ol><li><strong>对 CPU 资源消耗较大</strong></li><li><strong>无法处理浮动垃圾</strong></li><li>它使⽤的<strong>“标记-清除”算法</strong>会导致收集结束时会<strong>产生大量空间碎片</strong></li></ol><p><strong>垃圾回收中的三色标记法</strong></p><ul><li><p>首先，我们重新定义黑、白、灰三种颜⾊的含义</p><p><strong>白色</strong>代表需要 GC 的对象;   </p><p><strong>黑色</strong>代表确定不需要 GC 的对象;   </p><p><strong>灰色</strong>代表可能不需要 GC 的对象，但是还未完成标记的任务，也可以认为是增任务。  </p></li><li><p>在三⾊标记-清除算法中</p><p>准备⼯作：⼀开始所有对象都染成⽩⾊初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执⾏  Mutation，算法需要维护 3 个集合，⽩⾊集合、⿊⾊集合、灰⾊集合。3 个集合是互斥的，对象只能在⼀个集合 中。执⾏之初，所有对象都放⼊白色集合。</p><p>第⼀次执⾏： 算法将 Root 集合能直接引⽤的对象加⼊灰⾊集合;</p><p>往后执⾏：不断从灰⾊集合中取出元素进⾏标记;</p></li><li><p>标记的过程主要分为 3 个步骤： </p><ol><li>如果对象在⽩⾊集合中，那么先将对象放⼊灰⾊集合;   </li><li>然后遍历节点的所有的引⽤对象，并递归所有引⽤对象;   </li><li>当⼀个对象的所有引⽤对象都在灰⾊集合中，就把这个节点放⼊为⿊⾊集合。</li></ol></li></ul><p>当标记算法执⾏完成的时候，所有不需要 GC 的元素都会涂⿊；标记算法完成后，⽩⾊集合内就是需要回收的对象。</p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a><strong>JVM类加载机制</strong></h2><p><strong>类加载机制：</strong>类的数据从Class⽂件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java类型。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a><strong>类的生命周期</strong></h3><p>⼀个类型从被加载到虚拟机内存中开始，到卸载出内存为⽌，它的整个⽣命周期将会经历加载 （Loading）、验证 （Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使⽤（Using）和卸载 （Unloading）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）。</p><p><img src="/post/c257a468/b73db20eea59665fa3de67e1dec6d4e5.png" alt="img"></p><p>类加载分为三个步骤：<strong>加载、链接、初始化</strong></p><ul><li><p>加载</p><ul><li>类加载指的是将class文件读入内存，并为之创建一个java.lang.Class对象，即程序中使用任何类时，系统都会为之建立一个java.lang.Class对象，系统中所有的类都是java.lang.Class的实例。</li><li>类的加载由类加载器完成，JVM提供的类加载器叫做系统类加载器，此外还可以通过继承ClassLoader基类来自定义类加载器。</li><li>通常可以用如下几种方式加载类的二进制数据：<ol><li>从本地文件系统加载class文件。</li><li>从JAR包中加载class文件，如JAR包的数据库启驱动类。</li><li>通过网络加载class文件。</li><li>把一个Java源文件动态编译并执行加载。</li></ol></li></ul></li><li><p>连接：<strong>连接阶段负责把类的二进制数据合并到JRE中，其又可分为如下三个阶段：</strong></p><ul><li>验证：确保加载的类信息符合JVM规范，无安全方面的问题。</li><li>准备：为类的静态Field分配内存，并设置初始值。</li><li>解析：将类的二进制数据中的符号引用替换成直接引用。</li></ul></li><li><p>初始化</p><ul><li><strong>该阶段主要是对静态Field进行初始化，在Java类中对静态Field指定初始值有两种方式：</strong><ol><li>声明时即指定初始值，如static int a &#x3D; 5；</li><li>使用静态代码块为静态Field指定初始值，如：static{  b &#x3D; 5;  }</li></ol></li></ul><ul><li><p><strong>JVM初始化一个类包含如下几个步骤：</strong></p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类。</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类。</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句。</li></ol><p>所以JVM总是最先初始化java.lang.Object类。</p></li><li><p><strong>类初始化的时机（对类进行主动引用时）：</strong></p><ol><li><p>创建类的实例时（new、反射、反序列化）。</p></li><li><p>调用某个类的静态方法时。</p></li><li><p>使用某个类或接口的静态Field或对该Field赋值时。</p></li><li><p>使用反射来强制创建某个类或接口对应的java.lang.Class对象，如Class.forName(“Person”)</p></li><li><p>初始化某个类的子类时，此时该子类的所有父类都会被初始化。</p></li><li><p>直接使用java.exe运行某个主类时。</p></li></ol></li></ul></li></ul><h3 id="类加载器及加载机制"><a href="#类加载器及加载机制" class="headerlink" title="类加载器及加载机制"></a><strong>类加载器及加载机制</strong></h3><p><strong>类加载器</strong></p><p>绝大多数Java程序都会使用以下三种系统提供的Java类：</p><ul><li><strong>启动（Bootstrap）类加载器：</strong> 引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre&#x2F;lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。<br>bootstrap classloader是由C++写成的，所以在Java中无法获得它的引用（会返回Null）</li><li><strong>扩展（ExtClassLoader）类加载器：</strong> 扩展类加载器是由Sun的（sun.misc.Launcher$ExtClassLoader）实现的。它负责将jdk中jre&#x2F;lib&#x2F;ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li><li><strong>系统类加载器（System ClassLoader）：</strong> 系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。</li></ul><p><strong>双亲委派模型</strong></p><p><strong>1）双亲委派模式原理</strong></p><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理，它是一种任务委派模式。<br><strong>双亲委派模式</strong>要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，<strong>类加载器间的关系</strong>如下：</p><p><img src="/post/c257a468/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjc4NDk1MQ==,size_16,color_FFFFFF,t_70"></p><p><strong>2）双亲委派模型的工作流程</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p><strong>3）双亲委派模型优点（为什么用）</strong></p><p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。<strong>其次是考虑到安全因素</strong>，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br></pre></td></tr></table></figure><h2 id="怎么判断JVM里是否出现死锁"><a href="#怎么判断JVM里是否出现死锁" class="headerlink" title="怎么判断JVM里是否出现死锁"></a><strong>怎么判断JVM里是否出现死锁</strong></h2><ol><li>通过<code>jps</code>命令，查看java进程的PID</li><li>通过jstck PID查看线程日志</li><li>如果存在死锁，日志中会给出<code>Found one Java-level deadlock:</code>，定位到这个信息就可以快速定位问题。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001d1b0d58 (object 0x000000076b6cb368, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001d1b35e8 (object 0x000000076b6cb378, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">        at com.gupaoedu.interceptor.ThreadDemo$BlockThread.run(ThreadDemo.java:38)</span><br><span class="line">        - waiting to lock &lt;0x000000076b6cb368&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b6cb378&gt; (a java.lang.Object)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">        at com.gupaoedu.interceptor.ThreadDemo$BlockThread.run(ThreadDemo.java:38)</span><br><span class="line">        - waiting to lock &lt;0x000000076b6cb378&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b6cb368&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockThread</span>(o,o2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockThread</span>(o2,o);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BlockThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object obj1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object obj2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BlockThread</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.obj1 = obj1;</span><br><span class="line">            <span class="built_in">this</span>.obj2 = obj2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(obj1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span>(obj2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Helo&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a><strong>堆和栈的区别</strong></h2><ul><li><p>堆用来存放<strong>实例对象和数组</strong>，栈用来存放<strong>局部变量和方法调用</strong>；</p></li><li><p>堆是里面的对象是<strong>线程共享</strong>的，栈内存是<strong>线程私有</strong>的；</p></li><li><p>堆是<strong>先进先出</strong>、栈是<strong>先进后出</strong>；</p></li><li><p>堆是<strong>运行时</strong>确定内存大小，而栈在<strong>编译时</strong>确定内存大小；并且堆内存远<strong>大于</strong>栈内存，但是栈内存在分配速度上更<strong>快</strong>；</p></li><li><p>堆内存由<strong>JVM管理</strong>，栈内存会被<strong>自动释放</strong>。</p></li></ul>]]></content>
    
    
    <summary type="html">JVM常见面试问题</summary>
    
    
    
    <category term="Java" scheme="https://threewood1.top/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://threewood1.top/tags/JVM/"/>
    
    <category term="Interviews" scheme="https://threewood1.top/tags/Interviews/"/>
    
  </entry>
  
  <entry>
    <title>Java学习 | JVM的垃圾回收机制——垃圾回收算法</title>
    <link href="https://threewood1.top/post/dec4d43c.html"/>
    <id>https://threewood1.top/post/dec4d43c.html</id>
    <published>2024-05-28T12:16:24.000Z</published>
    <updated>2024-09-03T09:41:22.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java垃圾回收机制"><a href="#一、Java垃圾回收机制" class="headerlink" title="一、Java垃圾回收机制"></a><strong>一、Java垃圾回收机制</strong></h2><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h2 id="二、GC是什么？为什么要GC"><a href="#二、GC是什么？为什么要GC" class="headerlink" title="二、GC是什么？为什么要GC"></a><strong>二、GC是什么？为什么要GC</strong></h2><p>GC 垃圾收集（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存。</p><p>不当的回收可能会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><p><img src="/post/dec4d43c/v2-2648bf4a93fbab62c0f71b86de7551fd_720w.webp" alt="img"></p><h2 id="三、Java-中的引用类型"><a href="#三、Java-中的引用类型" class="headerlink" title="三、Java 中的引用类型"></a><strong>三、Java 中的引用类型</strong></h2><ol><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ol><h2 id="四、如何判断对象是否可以被回收？什么时候被回收？"><a href="#四、如何判断对象是否可以被回收？什么时候被回收？" class="headerlink" title="四、如何判断对象是否可以被回收？什么时候被回收？"></a><strong>四、如何判断对象是否可以被回收？什么时候被回收？</strong></h2><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是存活的，是不可以被回收的；哪些对象已经死亡了，需要被回收。</p><p><strong>一般有两种方法来判断：</strong></p><p><strong>引用计数器法</strong>：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。但是他有一个缺点是不能解决循环引用的问题。</p><p><strong>可达性分析算法</strong>：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><h2 id="五、JVM-的垃圾回收算法？"><a href="#五、JVM-的垃圾回收算法？" class="headerlink" title="五、JVM 的垃圾回收算法？"></a><strong>五、JVM 的垃圾回收算法？</strong></h2><p><strong>1.标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><ul><li>该算法分为两个阶段，<strong>标记和清除</strong>。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</li></ul><p><img src="/post/dec4d43c/v2-7389d400dc04abb145a67fa86a662e33_720w.webp" alt="img"></p><p>标记清除算法</p><p><strong>2.复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><ul><li>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</li></ul><p><img src="/post/dec4d43c/v2-20adb8ac4c5deb44fc27e30c8381281d_720w.webp" alt="img"></p><p>复制算法</p><p><strong>3.标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><ul><li>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</li></ul><p><img src="/post/dec4d43c/v2-cc722c4e5b289434d2181451f4fd154c_720w.webp" alt="img"></p><p>标记整理算法</p><p><strong>4.分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><ul><li>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代。</li></ul><p><img src="/post/dec4d43c/v2-40cbacd540b1555badbbf89132aace5f_720w.webp" alt="img"></p><p>分代收集</p><h2 id="六、垃圾收集器"><a href="#六、垃圾收集器" class="headerlink" title="六、垃圾收集器"></a><strong>六、垃圾收集器</strong></h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；</p><p>年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p><img src="/post/dec4d43c/v2-f5426caf176fac7d2d7edcf43e127eaa_720w.webp" alt="img"></p><p>垃圾收集器</p><p>其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，</p><p>回收老年代的收集器包括Serial Old、Parallel Old、CMS，</p><p>有用于回收整个Java堆的G1收集器。</p><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上 “-XX:+UseConcMarkSweepGC” 来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h2 id="七、分代垃圾回收器的工作机制？"><a href="#七、分代垃圾回收器的工作机制？" class="headerlink" title="七、分代垃圾回收器的工作机制？"></a><strong>七、分代垃圾回收器的工作机制？</strong></h2><p><strong>举个栗子：</strong></p><blockquote><p><strong>Java对象的一生：</strong>我是一个java对象，我出生在Eden区，在Eden区有一些跟我一样的兄弟们，我们在Eden区中一起玩，每天都有新的兄弟进来。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，在这里生活非常不稳定。有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我15岁的时候（默认15岁），就被分配到年老代那边，在这里人很多，并且年龄都挺大的。在年老代里，我生活了很久，每次GC年龄就+1，然后被回收。</p></blockquote><p>分代回收器有两个分区：<strong>老生代和新生代</strong>，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 <strong>8:1:1</strong>，它的执行流程如下：</p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To Survivor区”，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中。</p><p>清空 Eden 和 From Survivor 分区；</p><p>这时From Survivor 和 To Survivor 分区会互换角色，分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><p><img src="/post/dec4d43c/v2-40cbacd540b1555badbbf89132aace5f_720w.webp" alt="img"></p><p><strong>对象优先在 Eden 区分配：</strong></p><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><ul><li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li><li><strong>Major GC&#x2F;Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象直接进入老年代：</strong></p><p>新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。<br>虚拟机提供了一个<code>XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用的是复制算法）。</p><p><strong>长期存活对象将进入老年代：</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每过一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p><blockquote><p> 转载于：<a href="https://zhuanlan.zhihu.com/p/159200599">JVM的垃圾回收机制——垃圾回收算法 - 知乎 (zhihu.com)</a></p><p>面试版：<a href="https://www.zhihu.com/question/21535724">JVM垃圾回收算法都有哪些？简述它们的执行过程及优缺点 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">JVM垃圾回收机制、垃圾回收算法</summary>
    
    
    
    <category term="JavaSE" scheme="https://threewood1.top/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="JVM" scheme="https://threewood1.top/tags/JVM/"/>
    
    <category term="GC" scheme="https://threewood1.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java学习 | 堆和栈的区别</title>
    <link href="https://threewood1.top/post/c84b5546.html"/>
    <id>https://threewood1.top/post/c84b5546.html</id>
    <published>2024-03-12T11:00:45.000Z</published>
    <updated>2024-03-12T11:13:36.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>在Java中，内存分为两种，一种是栈内存，另一种就是堆内存。</p><h3 id="2、堆内存"><a href="#2、堆内存" class="headerlink" title="2、堆内存"></a>2、堆内存</h3><ol><li><p><strong>什么是堆内存</strong></p><p>堆内存是是Java内存中的一种，它的作用是用于存储Java中的对象和数组，当我们new一个对象或者创建一个数组的时候，就会在堆内存中开辟一段空间给它，用于存放。</p></li><li><p><strong>堆内存的特点</strong></p><p>第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队，好，你先买票。</p><p>第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p></li><li><p><strong>new对象在堆中如何分配</strong></p><p>由Java虚拟机的自动垃圾回收器来管理。</p></li></ol><h3 id="3、栈内存"><a href="#3、栈内存" class="headerlink" title="3、栈内存"></a>3、栈内存</h3><ol><li><p><strong>什么是栈内存</strong></p><p>栈内存是Java的另一种内存，主要是用来执行程序用的，比如：基本类型的变量和对象的引用变量。</p></li><li><p><strong>栈内存的特点</strong></p><p>第一点：栈内存就好像一个矿泉水瓶，像里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出。</p><p>第二点：存取速度比堆要快，仅次于寄存器，栈数据可以共享，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p></li><li><p><strong>栈内存分配机制</strong></p><p>栈内存可以称为一级缓存，由垃圾回收器自动回收。</p></li><li><p><strong>数据共享</strong></p><p>例子：<br>int a &#x3D; 3;<br>int b &#x3D; 3;</p><p>第一步处理：</p><ol><li>编译器先处理int a &#x3D; 3;</li><li>创建变量a的引用</li><li>在栈中查找是否有3这个值</li><li>没有找到，将3存放，a指向3</li></ol><p>第二步处理：</p><ol><li>处理b&#x3D;3</li><li>创建变量b的引用</li><li>找到，直接赋值</li></ol><p>第三步处理：</p><p>接下来<br>a &#x3D; 4；<br>同上方法<br>a的值改变，a指向4，b的值是不会发生改变的</p><blockquote><p>PS：如果是两个对象的话，那就不一样了，对象指向的是同一个引用，一个发生改变，另一个也会发生改变</p></blockquote></li></ol><h3 id="4、堆和栈的区别"><a href="#4、堆和栈的区别" class="headerlink" title="4、堆和栈的区别"></a>4、堆和栈的区别</h3><p>JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈。也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p><p><strong>差异：</strong></p><ol><li>堆内存用来存放由new创建的对象和数组；</li><li>栈内存用来存放方法或者局部变量等；</li><li>堆是先进先出，后进后出；</li><li>栈是后进先出，先进后出。</li></ol><p><strong>相同：</strong></p><ol><li>都是属于Java内存的一种；</li><li>系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它。</li></ol>]]></content>
    
    
    <summary type="html">Java中的堆和栈，特点，区别。</summary>
    
    
    
    <category term="JavaSE" scheme="https://threewood1.top/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="Heap" scheme="https://threewood1.top/tags/Heap/"/>
    
    <category term="Stack" scheme="https://threewood1.top/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Java学习 | 集合框架</title>
    <link href="https://threewood1.top/post/264f303d.html"/>
    <id>https://threewood1.top/post/264f303d.html</id>
    <published>2024-03-11T08:35:12.000Z</published>
    <updated>2024-03-11T09:31:38.913Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将介绍Java集合框架中常用的数据结构。Java 集合可分为 Collection 和 Map 两大体系。</p></blockquote><p><strong>java.util.Collection：</strong>存储一个一个的数据<br>    |——<strong>子接口List：</strong>存储有序的、可重复数据（“动态”数组）<br>        |——ArrayList（主要实现类）、LinkedList、Vector</p><p>​|——<strong>子接口Set：</strong>存储无序的、不可重复的数据<br>​|——HashSet（主要实现类）、LinkedHashSet、TreeSet</p><p><strong>java.util.Map：</strong>存储一对一对的数据（key-value）<br>    |——HashMap（主要实现类）、LinkedHashMap、TreeMap、Hashtable、Properties</p><p><img src="/post/264f303d/image-20240311164951772.png" alt="Collection接口继承树"></p><p><img src="/post/264f303d/image-20240311165045268.png" alt="Map接口继承树"></p><h2 id="一、ArrayList"><a href="#一、ArrayList" class="headerlink" title="一、ArrayList"></a>一、ArrayList</h2><ol><li><strong>ArrayList的特点</strong></li></ol><blockquote><p>实现了List接口，存储有序的、可重复的数据；</p><p>底层使用Object[]数组存储；</p><p>线程不安全。</p></blockquote><ol start="2"><li><p><strong>ArrayList源码解析</strong></p><p><strong>2.1 jdk7版本：(以jdk1.7.0_07为例)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下代码的执行：底层会初始化数组，数组的长度为10。</span></span><br><span class="line">Object[] elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">ArrayList\&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">&quot;AA&quot;</span>); <span class="comment">//elementData[0] = &quot;AA&quot;;</span></span><br><span class="line">list.add(<span class="string">&quot;BB&quot;</span>);<span class="comment">//elementData[1] = &quot;BB&quot;;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当要添加第11个元素的时候，底层的elementData数组已满，则需要扩容。默认扩容为原来长度的<strong>1.5倍</strong>。并将原有数组中的元素复制到新的数组中。</p><hr><p><strong>2.2 jdk8版本:(以jdk1.8.0_271为例)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下代码的执行：底层会初始化数组，即：Object[] elementData = new Object[]&#123;&#125;;</span></span><br><span class="line">ArrayList\&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">&quot;AA&quot;</span>); <span class="comment">//首次添加元素时，会初始化数组elementData = new Object[10];elementData[0] = &quot;AA&quot;;</span></span><br><span class="line">list.add(<span class="string">&quot;BB&quot;</span>);<span class="comment">//elementData[1] = &quot;BB&quot;;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当要添加第11个元素的时候，底层的elementData数组已满，则需要扩容。默认扩容为原来长度的<strong>1.5倍</strong>。并将原有数组中的元素复制到新的数组中。</p><p>区别就是后者在添加数据时才初始化数组的长度。</p></li></ol><h2 id="二、Vector"><a href="#二、Vector" class="headerlink" title="二、Vector"></a>二、Vector</h2><ol><li><strong>Vector的特点</strong></li></ol><blockquote><p>实现了List接口，存储有序的、可重复的数据；</p><p>底层使用Object[]数组存储；</p><p>线程安全。</p></blockquote><ol start="2"><li><p><strong>Vector源码解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(); <span class="comment">//底层初始化数组，长度为10。Object[] elementData = new Object[10];</span></span><br><span class="line">v.add(<span class="string">&quot;AA&quot;</span>); <span class="comment">//elementData[0] = &quot;AA&quot;;</span></span><br><span class="line">v.add(<span class="string">&quot;BB&quot;</span>);<span class="comment">//elementData[1] = &quot;BB&quot;;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当添加第11个元素时，需要扩容。默认扩容为原来的<strong>2倍</strong>。</p></li></ol><h2 id="三、LinkedList"><a href="#三、LinkedList" class="headerlink" title="三、LinkedList"></a>三、LinkedList</h2><ol><li><strong>LinkedList的特点</strong></li></ol><blockquote><p>实现了List接口，存储有序的、可重复的数据；</p><p>底层使用双向链表存储；</p><p>线程不安全。</p></blockquote><ol start="2"><li><p><strong>LinkedList源码解析</strong></p><p>因为LinkedList使用的是双向链表，不需要考虑扩容问题。</p></li></ol><h2 id="四、启示与开发建议"><a href="#四、启示与开发建议" class="headerlink" title="四、启示与开发建议"></a>四、启示与开发建议</h2><ol><li><p>Vector基本不使用了。</p></li><li><p>ArrayList底层使用数组结构，查找和添加（尾部添加）操作效率高，时间复杂度为O(1)，删除和插入操作效率低，时间复杂度为O(n)；<br>LinkedList底层使用双向链表结构，删除和插入操作效率高，时间复杂度为O(1)，查找和添加（尾部添加）操作效率高，时间复杂度为O(n) (有可能添加操作是O(1))；</p></li><li><p>在选择了ArrayList的前提下，new ArrayList() : 底层创建长度为10的数组。</p><p>new ArrayList(int capacity)：底层创建指定capacity长度的数组。<br>如果开发中，大体确认数组的长度，则推荐使用ArrayList(int capacity)这个构造器，避免了底层的扩容、复制数组的操作。</p></li></ol><h2 id="五、HashMap"><a href="#五、HashMap" class="headerlink" title="五、HashMap"></a>五、HashMap</h2><ol><li><strong>HashMap中元素的特点</strong></li></ol><blockquote><p>线程不安全；</p><p>HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。—&gt;key所在的类要重写hashCode()和equals()；</p><p>HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。—&gt;value所在的类要重写equals()；</p><p>HashMap中的一个key-value，就构成了一个entry，所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。</p></blockquote><ol start="2"><li><p><strong>HashMap源码解析</strong></p><p><strong>2.1 jdk7中创建对象和添加数据过程(以JDK1.7.0_07为例说明)：</strong></p><p>添加&#x2F;修改的过程：</p><p>将(key1,value1)添加到当前的map中：</p><p>首先，需要调用key1所在类的hashCode()方法，计算key1对应的哈希值1，此哈希值1经过某种算法(hash())之后，得到哈希值2。哈希值2再经过某种算法(indexFor())之后，就确定了(key1,value1)在数组table中的索引位置i。</p><p>  1.1 如果此索引位置i的数组上没有元素，则(key1,value1)添加成功。  —-&gt;情况1</p><p>  1.2 如果此索引位置i的数组上有元素(key2,value2),则需要继续比较key1和key2的哈希值2  —&gt;哈希冲突</p><p>​         2.1 如果key1的哈希值2与key2的哈希值2不相同，则(key1,value1)添加成功。   —-&gt;情况2</p><p>​         2.2 如果key1的哈希值2与key2的哈希值2相同，则需要继续比较key1和key2的equals()。要调用key1所在类的equals(),将key2作为参数传递进去。</p><p>​               3.1 调用equals()，返回false: 则(key1,value1)添加成功。   —-&gt;情况3</p><p>​               3.2 调用equals()，返回true: 则认为key1和key2是相同的。默认情况下，value1替换原有的value2。</p><p><strong>说明：</strong>情况1：将(key1,value1)存放到数组的索引i的位置；</p><p>​            情况2，情况3：(key1,value1)元素与现有的(key2,value2)构成单向链表结构，(key1,value1)指向(key2,value2)。</p><hr><p><strong>HashMap的扩容机制：</strong></p><p>随着不断的添加元素，在满足如下的条件的情况下，会考虑<strong>扩容</strong>：</p><p><strong>jdk1.7需要同时满足以下两个条件：(先判断是否扩容，再存入数据；头插法)</strong></p><blockquote><p>1、存放新值的时候当前已有元素的个数必须大于等于阈值；</p><p>2、存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）。</p></blockquote><p>即：(size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[i])</p><p>当元素的个数达到临界值(数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 threshold &#x3D; 16 * 0.75 –&gt; 12。默认扩容为原来的<strong>2倍</strong>。</p><p><strong>jdk1.8只需要满足以下任意条件：（先存入数据，再判断是否扩容；尾插法）</strong></p><blockquote><p>1、当前存储的数量大于等于阈值；</p><p>2、存入数据到某一条链表时，该链表长度&gt;&#x3D;8，并且数组存储的结点数size() &lt; 64时。</p></blockquote><p>即：(size &gt;&#x3D; threshold) || (linkedList.size &gt;&#x3D; 8 &amp;&amp; size &lt; 64)</p><p>当元素的个数达到临界值(数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 threshold &#x3D; 16 * 0.75 –&gt; 12。默认扩容为原来的<strong>2倍</strong>。</p><hr><p><strong>2.2 jdk8与jdk7的不同之处(以jdk1.8.0_271为例)：</strong></p><p>① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，如果发现table尚未初始化，则对数组进行初始化。<br>② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]<br>③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的(key,value)元素（尾插法）。 “七上八下”<br>④ jdk7: 数组+单向链表<br> jk8: 数组+单向链表+红黑树</p><blockquote><p><strong>什么时候会使用单向链表变为红黑树：</strong>如果数组索引 i 位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引 i 位置上的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()&#x2F;get()&#x2F;remove()操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。<br><strong>什么时候会使用红黑树变为单向链表</strong>：当使用红黑树的索引 i 位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。（为什么？节省空间）</p></blockquote></li></ol><h2 id="六、LinkedHashMap"><a href="#六、LinkedHashMap" class="headerlink" title="六、LinkedHashMap"></a>六、LinkedHashMap</h2><ol><li><strong>LinkedHashMap 与 HashMap 的关系:</strong></li></ol><blockquote><p>LinkedHashMap是HashMap的子类；</p><p>LinkedHashMap在HashMap使用的数组+单向链表+红黑树的基础上，又增加了一对双向链表，记录添加的(key,value)的先后顺序。便于我们遍历所有的key-value。</p></blockquote><p>LinkedHashMap重写了HashMap的如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>底层结构：LinkedHashMap 内部定义了一个 Entry</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after; <span class="comment">//增加的一对双向链表</span></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、HashSet和LinkedHashSet的源码分析"><a href="#七、HashSet和LinkedHashSet的源码分析" class="headerlink" title="七、HashSet和LinkedHashSet的源码分析"></a>七、HashSet和LinkedHashSet的源码分析</h2><blockquote><p>HashSet底层使用的是HashMap；</p><p>LinkedHashSet底层使用的是LinkedHashMap。</p></blockquote>]]></content>
    
    
    <summary type="html">Java常用集合结构</summary>
    
    
    
    <category term="JavaSE" scheme="https://threewood1.top/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="Collection" scheme="https://threewood1.top/tags/Collection/"/>
    
    <category term="Map" scheme="https://threewood1.top/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」二叉树的层序遍历</title>
    <link href="https://threewood1.top/post/f1d7e9fc.html"/>
    <id>https://threewood1.top/post/f1d7e9fc.html</id>
    <published>2024-03-08T12:04:27.000Z</published>
    <updated>2024-03-22T09:07:16.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-二叉树的层序遍历"><a href="#LeetCode-二叉树的层序遍历" class="headerlink" title="[LeetCode] 二叉树的层序遍历"></a>[LeetCode] 二叉树的层序遍历</h1><p><strong>题目：</strong>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>力扣链接：</strong><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><p><strong>思路：</strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//保存最终返回结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//BFS打印，levelSize为每层的节点数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">//保存每层的的节点值</span></span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="comment">//出队</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                subList.add(treeNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当前节点的子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//保存最终返回结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    bfs(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  resList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(TreeNode node, Integer deep)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    deep++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        resList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">    bfs(node.left, deep);</span><br><span class="line">    bfs(node.right, deep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">递归和非递归层序遍历二叉树</summary>
    
    
    
    <category term="LeetCode" scheme="https://threewood1.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://threewood1.top/tags/LeetCode/"/>
    
    <category term="Binary Tree" scheme="https://threewood1.top/tags/Binary-Tree/"/>
    
    <category term="BFS" scheme="https://threewood1.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」正则表达式&quot;&#92;&#92;S+&quot;——匹配任意空白字符</title>
    <link href="https://threewood1.top/post/3f00002a.html"/>
    <id>https://threewood1.top/post/3f00002a.html</id>
    <published>2024-01-26T08:05:45.000Z</published>
    <updated>2024-03-11T02:52:54.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“-S-”解释"><a href="#“-S-”解释" class="headerlink" title="“\\S+”解释"></a>“\\S+”解释</h2><p>正则表达式中\s匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</p><ul><li>\f -&gt; 匹配一个换页</li></ul><ul><li>\n -&gt; 匹配一个换行符</li><li>\r -&gt; 匹配一个回车符</li><li>\t -&gt; 匹配一个制表符</li><li>\v -&gt; 匹配一个垂直制表符</li></ul><p>而“\s+”则表示匹配任意多个上面的字符。另因为反斜杠在Java里是转义字符，所以在Java里，我们要这么用“\\s+”.</p><h2 id="“-s-”的使用"><a href="#“-s-”的使用" class="headerlink" title="“\\s+”的使用"></a>“\\s+”的使用</h2><p>今天遇见一道经典的算法题：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><p>在这道题中有了这个”\\s+”就很好解决。</p><p><strong>题目大概如下：</strong></p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>解法一：</strong></p><p>我们都知道java以及大多数高级语言都提供了一系列字符串处理函数，包括<code>split</code>（拆分），<code>reverse</code>（翻转）和 <code>join</code>（连接）等方法。所以这种方法调用这些内置api很好解决。思路就是：</p><ol><li>使用trim()去掉字符串前后的空格字符；</li><li>使用split()分割字符串；</li><li>按倒叙将字符串加入到StringBuilder中并添加空格；</li><li>去掉最后一个空格并转化成String后返回。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    String[] words = s.split(<span class="string">&quot;\\s+&quot;</span>); <span class="comment">// 这里使用\\s+就能很好的去掉多余的空格</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(words[i], <span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.substring(<span class="number">0</span>, sb.toString().length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong></p><p>我相信大多数人都能想到上面的方法，这里我将介绍一种使用双指针的方法，并且效率相比上面的方法更优。思想如下：</p><ol><li>去掉首尾字符串；</li><li>定义两个指针在字符串的末尾，i，j。</li><li>从尾部<code>i</code>到第一个空格，即<code>&quot; &quot;</code>，然后将取<code>i</code>和<code>j</code>中间的单词加入到StringBuilder</li><li>再移动<code>i</code>到第一个非空格字符，让<code>j = i</code></li><li>重复3、4直到<code>i &gt;= 0</code></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = i;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(s, i + <span class="number">1</span>, j + <span class="number">1</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">“&#92;&#92;s+”在翻转字符串里的单词”中的使用</summary>
    
    
    
    <category term="LeetCode" scheme="https://threewood1.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://threewood1.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>抽取 MQ 工具的作业参考</title>
    <link href="https://threewood1.top/post/d1dc93ff.html"/>
    <id>https://threewood1.top/post/d1dc93ff.html</id>
    <published>2024-01-22T09:15:31.000Z</published>
    <updated>2024-01-22T08:17:31.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽取-MQ-工具的作业参考"><a href="#抽取-MQ-工具的作业参考" class="headerlink" title="抽取 MQ 工具的作业参考"></a>抽取 MQ 工具的作业参考</h1><p>MQ 在企业开发中的常见应用我们就学习完毕了，除了收发消息以外，消息可靠性的处理、生产者确认、消费者确认、延迟消息等等编码还是相对比较复杂的。</p><p>因此，我们需要将这些常用的操作封装为工具，方便在项目中使用。</p><h2 id="1-抽取共享配置"><a href="#1-抽取共享配置" class="headerlink" title="1.抽取共享配置"></a>1.抽取共享配置</h2><p>首先，我们需要在 nacos 中抽取 RabbitMQ 的共享配置，命名为 <code>shared-mq.yaml</code>：</p><p><img src="/post/d1dc93ff/Ye9FbOBiso5CcdxJE3ecg4q0nfe.png"></p><p>其中只包含 mq 的基础共享配置，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;hm.mq.host:192.168.150.101&#125;</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;hm.mq.port:5672&#125;</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">$&#123;hm.mq.vhost:/hmall&#125;</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.mq.un:hmall&#125;</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.mq.pw:123&#125;</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h2 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2.引入依赖"></a>2.引入依赖</h2><p>在 <code>hm-common</code> 模块引入要用到的一些依赖，主要包括 <code>amqp、jackson</code>。但是不要引入 starter，因为我们希望可以让用户按需引入。</p><p>依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring整合Rabbit依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--json处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：依赖的 <code>scope</code> 要选择 <code>provided</code>，这样依赖仅仅是用作项目编译时不报错，真正运行时需要使用者自行引入依赖。</p><h2 id="3-封装工具"><a href="#3-封装工具" class="headerlink" title="3.封装工具"></a>3.封装工具</h2><p>在 hm-common 模块的 <code>com.hmall.common.utils</code> 包下新建一个 <code>RabbitMqHelper</code> 类：</p><p><img src="/post/d1dc93ff/A5t3bZHUWossSLx8x0ucCwwfnMh.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.UUID;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFutureCallback;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object msg)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;准备发送消息，exchange:&#123;&#125;, routingKey:&#123;&#125;, msg:&#123;&#125;&quot;</span>, exchange, routingKey, msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> delay)</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, msg, message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setDelay(delay);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;准备发送消息，exchange:&#123;&#125;, routingKey:&#123;&#125;, msg:&#123;&#125;&quot;</span>, exchange, routingKey, msg);</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString(<span class="literal">true</span>));</span><br><span class="line">        cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">int</span> retryCount;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理ack回执失败&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; !result.isAck()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;消息发送失败，收到nack，已重试次数：&#123;&#125;&quot;</span>, retryCount);</span><br><span class="line">                    <span class="keyword">if</span>(retryCount &gt;= maxRetries)&#123;</span><br><span class="line">                        log.error(<span class="string">&quot;消息发送重试次数耗尽，发送失败&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString(<span class="literal">true</span>));</span><br><span class="line">                    cd.getFuture().addCallback(<span class="built_in">this</span>);</span><br><span class="line">                    rabbitTemplate.convertAndSend(exchange, routingKey, msg, cd);</span><br><span class="line">                    retryCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, msg, cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-自动装配"><a href="#4-自动装配" class="headerlink" title="4.自动装配"></a>4.自动装配</h2><p>最后，我们在 hm-common 模块的包下定义一个配置类：</p><p><img src="/post/d1dc93ff/DrOtbNyanoG3fGxqZRWcZiL0n4b.png"></p><p>将 <code>RabbitMqHelper</code> 注册为 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.RabbitMqHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(value = &#123;MessageConverter.class, RabbitTemplate.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(ObjectMapper.class)</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">(ObjectMapper mapper)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">        <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>(mapper);</span><br><span class="line">        <span class="comment">// 2.配置自动创建消息id，用于识别不同消息</span></span><br><span class="line">        jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitMqHelper <span class="title function_">rabbitMqHelper</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RabbitMqHelper</span>(rabbitTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>由于 hm-common 模块的包名为 <code>com.hmall.common</code>，与其它微服务的包名不一致，因此无法通过扫描包使配置生效。</p><p>为了让我们的配置生效，我们需要在项目的 classpath 下的 META-INF&#x2F;spring.factories 文件中声明这个配置类：</p><p><img src="/post/d1dc93ff/Lt0gbrhBho5DWpxsoapcbPehnHb.png"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.hmall.common.config.MyBatisConfig,\</span><br><span class="line">  com.hmall.common.config.MqConfig,\</span><br><span class="line">  com.hmall.common.config.MvcConfig</span><br></pre></td></tr></table></figure><p>至此，RabbitMQ 的工具类和自动装配就完成了。</p>]]></content>
    
    
    <summary type="html">MQ学习</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="MQ" scheme="https://threewood1.top/tags/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://threewood1.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ高级</title>
    <link href="https://threewood1.top/post/b90bbc4.html"/>
    <id>https://threewood1.top/post/b90bbc4.html</id>
    <published>2024-01-22T09:14:38.000Z</published>
    <updated>2024-01-22T08:17:31.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ高级"><a href="#MQ高级" class="headerlink" title="MQ高级"></a>MQ高级</h1><p>在昨天的练习作业中，我们改造了余额支付功能，在支付成功后利用 RabbitMQ 通知交易服务，更新业务订单状态为已支付。</p><p>但是大家思考一下，如果这里 MQ 通知失败，支付服务中支付流水显示支付成功，而交易服务中的订单状态却显示未支付，数据出现了不一致。</p><p>此时前端发送请求查询支付状态时，肯定是查询交易服务状态，会发现业务订单未支付，而用户自己知道已经支付成功，这就导致用户体验不一致。</p><p>因此，这里我们必须尽可能确保 MQ 消息的可靠性，即：消息应该至少被消费者处理 1 次</p><p>那么问题来了：</p><ul><li><strong>我们该如何确保<strong><strong>MQ</strong></strong>消息的可靠性</strong>？</li><li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li></ul><p>这些问题，在今天的学习中都会找到答案。</p><h1 id="1-发送者的可靠性"><a href="#1-发送者的可靠性" class="headerlink" title="1.发送者的可靠性"></a>1.发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。</p><p>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：</p><p>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li><p>发送消息时丢失：</p><ul><li>生产者发送消息时连接 MQ 失败</li><li>生产者发送消息到达 MQ 后未找到 <code>Exchange</code></li><li>生产者发送消息到达 MQ 的 <code>Exchange</code> 后，未找到合适的 <code>Queue</code></li><li>消息到达 MQ 后，处理消息的进程发生异常</li></ul></li><li><p>MQ 导致消息丢失：</p><ul><li>消息到达 MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li><p>消费者处理消息时：</p><ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证 MQ 的可靠性，就必须从 3 个方面入手：</p><ul><li>确保生产者一定把消息发送到 MQ</li><li>确保 MQ 不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><p>这一章我们先来看如何确保生产者一定能把消息发送到 MQ。</p><h2 id="1-1-生产者重试机制"><a href="#1-1-生产者重试机制" class="headerlink" title="1.1.生产者重试机制"></a>1.1.生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与 MQ 的连接中断。</p><p>为了解决这个问题，SpringAMQP 提供的消息发送时的重试机制。即：当 <code>RabbitTemplate</code> 与 MQ 连接超时后，多次重试。</p><p>修改 <code>publisher</code> 模块的 <code>application.yaml</code> 文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p>我们利用命令停掉 RabbitMQ 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq</span><br></pre></td></tr></table></figure><p>然后测试发送一条消息，会发现会每隔 1 秒重试 1 次，总共重试了 3 次。消息发送的超时重试机制配置成功了！</p><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过 SpringAMQP 提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h2 id="1-2-生产者确认机制"><a href="#1-2-生产者确认机制" class="headerlink" title="1.2.生产者确认机制"></a>1.2.生产者确认机制</h2><p>一般情况下，只要生产者与 MQ 之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。</p><p>不过，在少数情况下，也会出现消息发送到 MQ 之后丢失的现象，比如：</p><ul><li>MQ 内部处理消息的进程发生了异常</li><li>生产者发送消息到达 MQ 后未找到 <code>Exchange</code></li><li>生产者发送消息到达 MQ 的 <code>Exchange</code> 后，未找到合适的 <code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ 提供了生产者消息确认机制，包括 <code>Publisher Confirm</code> 和 <code>Publisher Return</code> 两种。在开启确认机制的情况下，当生产者发送消息给 MQ 后，MQ 会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p>具体如图所示：</p><p><img src="/post/b90bbc4/VohQbYwSlo8R6AxfinGcLNq6nld.png"></p><p>总结如下：</p><ul><li>当消息投递到 MQ，但是路由失败时，通过 <strong>Publisher Return</strong> 返回异常信息，同时返回 ack 的确认信息，代表投递成功</li><li>临时消息投递到了 MQ，并且入队成功，返回 ACK，告知投递成功</li><li>持久消息投递到了 MQ，并且入队完成持久化，返回 ACK ，告知投递成功</li><li>其它情况都会返回 NACK，告知投递失败</li></ul><p>其中 <code>ack</code> 和 <code>nack</code> 属于 <strong>Publisher Confirm</strong> 机制，<code>ack</code> 是投递成功；<code>nack</code> 是投递失败。而 <code>return</code> 则属于 <strong>Publisher Return</strong> 机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h2 id="1-3-实现生产者确认"><a href="#1-3-实现生产者确认" class="headerlink" title="1.3.实现生产者确认"></a>1.3.实现生产者确认</h2><h3 id="1-3-1-开启生产者确认"><a href="#1-3-1-开启生产者确认" class="headerlink" title="1.3.1.开启生产者确认"></a>1.3.1.开启生产者确认</h3><p>在 publisher 模块的 <code>application.yaml</code> 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里 <code>publisher-confirm-type</code> 有三种模式可选：</p><ul><li><code>none</code>：关闭 confirm 机制</li><li><code>simple</code>：同步阻塞等待 MQ 的回执</li><li><code>correlated</code>：MQ 异步回调返回回执</li></ul><p>一般我们推荐使用 <code>correlated</code>，回调机制。</p><h3 id="1-3-2-定义-ReturnCallback"><a href="#1-3-2-定义-ReturnCallback" class="headerlink" title="1.3.2.定义 ReturnCallback"></a>1.3.2.定义 ReturnCallback</h3><p>每个 <code>RabbitTemplate</code> 只能配置一个 <code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在 publisher 模块定义一个配置类：</p><p><img src="/post/b90bbc4/VtLLb0dSFo6XOdx1EEiczVvbnvc.png"></p><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ReturnedMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-定义-ConfirmCallback"><a href="#1-3-3-定义-ConfirmCallback" class="headerlink" title="1.3.3.定义 ConfirmCallback"></a>1.3.3.定义 ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此 ConfirmCallback 需要在每次发消息时定义。具体来说，是在调用 RabbitTemplate 中的 convertAndSend 方法时，多传递一个参数：</p><p><img src="/post/b90bbc4/E2IcbQ9bQoCDTVx8m8GciifXnKe.png"></p><p>这里的 CorrelationData 中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ 对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的 Future 对象</li></ul><p>将来 MQ 的回执就会通过这个 <code>Future</code> 来返回，我们可以提前给 <code>CorrelationData</code> 中的 <code>Future</code> 添加回调函数来处理消息回执：</p><p><img src="/post/b90bbc4/TR81bF8E3ocm72xkaqHcuN9Nnph.png"></p><p>我们新建一个测试，向系统自带的交换机发送消息，并且添加 <code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="/post/b90bbc4/YmF2bo8C8ot7CexZXopcsIyTnYc.png"></p><p>可以看到，由于传递的 <code>RoutingKey</code> 是错误的，路由失败后，触发了 <code>return callback</code>，同时也收到了 ack。</p><p>当我们修改为正确的 <code>RoutingKey</code> 以后，就不会触发 <code>return callback</code> 了，只收到 ack。</p><p>而如果连交换机都是错误的，则只会收到 nack。</p><h1 id="2-MQ-的可靠性"><a href="#2-MQ-的可靠性" class="headerlink" title="2.MQ 的可靠性"></a>2.MQ 的可靠性</h1><p>消息到达 MQ 以后，如果 MQ 不能及时保存，也会导致消息丢失，所以 MQ 的可靠性也非常重要。</p><h2 id="2-1-数据持久化"><a href="#2-1-数据持久化" class="headerlink" title="2.1.数据持久化"></a>2.1.数据持久化</h2><p>为了提升性能，默认情况下 MQ 的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>我们以控制台界面为例来说明。</p><h3 id="2-1-1-交换机持久化"><a href="#2-1-1-交换机持久化" class="headerlink" title="2.1.1.交换机持久化"></a>2.1.1.交换机持久化</h3><p>在控制台的 <code>Exchanges</code> 页面，添加交换机时可以配置交换机的 <code>Durability</code> 参数：</p><p><img src="/post/b90bbc4/NPr8bcUqkoNVgIxP7ePct6thn4g.png"></p><p>设置为 <code>Durable</code> 就是持久化模式，<code>Transient</code> 就是临时模式。</p><h3 id="2-1-2-队列持久化"><a href="#2-1-2-队列持久化" class="headerlink" title="2.1.2.队列持久化"></a>2.1.2.队列持久化</h3><p>在控制台的 Queues 页面，添加队列时，同样可以配置队列的 <code>Durability</code> 参数：</p><p><img src="/post/b90bbc4/CxrxbP3awotxmkxSndlcE7iKnvd.png"></p><p>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p><h3 id="2-1-3-消息持久化"><a href="#2-1-3-消息持久化" class="headerlink" title="2.1.3.消息持久化"></a>2.1.3.消息持久化</h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个 <code>properties</code>：</p><p><img src="/post/b90bbc4/SVIKbI7VXojq3ixFUd1ch5oFnkh.png"></p><h2 id="2-2-LazyQueue"><a href="#2-2-LazyQueue" class="headerlink" title="2.2.LazyQueue"></a>2.2.LazyQueue</h2><p>在默认情况下，RabbitMQ 会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ 的内存占用就会越来越高，直到触发内存预警上限。此时 RabbitMQ 会将内存消息刷到磁盘上，这个行为成为 <code>PageOut</code>. <code>PageOut</code> 会耗费一段时间，并且会阻塞队列进程。因此在这个过程中 RabbitMQ 不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从 RabbitMQ 的 3.6.0 版本开始，就增加了 Lazy Queues 的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在 3.12 版本之后，LazyQueue 已经成为所有队列的默认格式。因此官方推荐升级 MQ 为 3.12 版本或者所有队列都设置为 LazyQueue 模式。</p><h3 id="2-2-1-控制台配置-Lazy-模式"><a href="#2-2-1-控制台配置-Lazy-模式" class="headerlink" title="2.2.1.控制台配置 Lazy 模式"></a>2.2.1.控制台配置 Lazy 模式</h3><p>在添加队列的时候，添加 <code>x-queue-mod=lazy</code> 参数即可设置队列为 Lazy 模式：</p><p><img src="/post/b90bbc4/D7mmbzVySoa0VzxTQ6Ucbpl2nKb.png"></p><h3 id="2-2-2-代码配置-Lazy-模式"><a href="#2-2-2-代码配置-Lazy-模式" class="headerlink" title="2.2.2.代码配置 Lazy 模式"></a>2.2.2.代码配置 Lazy 模式</h3><p>在利用 SpringAMQP 声明队列的时候，添加 <code>x-queue-mod=lazy</code> 参数也可设置队列为 Lazy 模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过 <code>QueueBuilder</code> 的 <code>lazy()</code> 函数配置 Lazy 模式，底层源码如下：</p><p><img src="/post/b90bbc4/EBkmbWPYIo1x2KxnEXUcWHcHn0U.png"></p><p>当然，我们也可以基于注解来声明队列并设置为 Lazy 模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-更新已有队列为-lazy-模式"><a href="#2-2-3-更新已有队列为-lazy-模式" class="headerlink" title="2.2.3.更新已有队列为 lazy 模式"></a>2.2.3.更新已有队列为 lazy 模式</h3><p>对于已经存在的队列，也可以配置为 lazy 模式，但是要通过设置 policy 实现。</p><p>可以基于命令行设置 policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ 的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为 lazy 模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置 policy，进入在控制台的 <code>Admin</code> 页面，点击 <code>Policies</code>，即可添加配置：</p><p><img src="/post/b90bbc4/AFUlbn4sMoqeX6xbldFcQPbYnXc.png"></p><h1 id="3-消费者的可靠性"><a href="#3-消费者的可靠性" class="headerlink" title="3.消费者的可靠性"></a>3.消费者的可靠性</h1><p>当 RabbitMQ 向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>…</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ 必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><p>但问题来了：RabbitMQ 如何得知消费者的处理状态呢？</p><p>本章我们就一起研究一下消费者处理消息时的可靠性解决方案。</p><h2 id="2-1-消费者确认机制"><a href="#2-1-消费者确认机制" class="headerlink" title="2.1.消费者确认机制"></a>2.1.消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ 从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ 需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ 从队列中删除该消息</li></ul><p>一般 reject 方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过 <code>try catch</code> 机制捕获，消息处理成功时返回 ack，处理失败时返回 nack.</p><p>由于消息回执的处理代码比较统一，因此 SpringAMQP 帮我们实现了消息确认。并允许我们通过配置文件设置 ACK 处理方式，有三种模式：</p><ul><li><p><strong>none</strong>：不处理。即消息投递给消费者后立刻 ack，消息会立刻从 MQ 删除。非常不安全，不建议使用</p></li><li><p><strong>manual</strong>：手动模式。需要自己在业务代码中调用 api，发送 <code>ack</code> 或 <code>reject</code>，存在业务入侵，但更灵活</p></li><li><p><strong>auto</strong>：自动模式。SpringAMQP 利用 AOP 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：</p><ul><li>如果是<strong>业务异常</strong>，会自动返回 <code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回 <code>reject</code>;</li></ul></li></ul><p>返回 Reject 的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<Foo> but Message<Bar> is received.</Bar></Foo></li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改 SpringAMQP 的 ACK 处理方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></table></figure><p>修改 consumer 服务的 SpringRabbitListener 类中的方法，模拟一个消息处理的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageConversionException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试可以发现：当消息处理发生异常时，消息依然被 RabbitMQ 删除了。</p><p>我们再次把确认机制修改为 auto：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></table></figure><p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code>（未确定状态）：</p><p><img src="/post/b90bbc4/MaLabMxNNoh4gMxwHDxc4MxTnoh.png"></p><p>放行以后，由于抛出的是<strong>消息转换异常</strong>，因此 Spring 会自动返回 <code>reject</code>，所以消息依然会被删除：</p><p><img src="/post/b90bbc4/OuJLbuT9eowqpaxI7TNcimyinZc.png"></p><p>我们将异常改为 RuntimeException 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code>（未确定状态）：</p><p><img src="/post/b90bbc4/UkKwbmXVpoyeUyxxxxncpY5NnMg.png"></p><p>放行以后，由于抛出的是业务异常，所以 Spring 返回 <code>ack</code>，最终消息恢复至 <code>Ready</code> 状态，并且没有被 RabbitMQ 删除：</p><p><img src="/post/b90bbc4/K8qRb41Uso5Riyx95aLcGAYQnCe.png"></p><p>当我们把配置改为 <code>auto</code> 时，消息处理失败后，会回到 RabbitMQ，并重新投递到消费者。</p><h2 id="2-2-失败重试机制"><a href="#2-2-失败重试机制" class="headerlink" title="2.2.失败重试机制"></a>2.2.失败重试机制</h2><p>当消费者出现异常后，消息会不断 requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次 requeue 到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息 requeue 就会无限循环，导致 mq 的消息处理飙升，带来不必要的压力：</p><p><img src="/post/b90bbc4/B2SpbJ5Rxo78AQxuyXQcauXsn4b.png"></p><p>当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况 Spring 又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的 requeue 到 mq 队列。</p><p>修改 consumer 服务的 application.yml 文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>重启 consumer 服务，重复之前的测试。可以发现：</p><ul><li>消费者在失败后消息没有重新回到 MQ 无限重新投递，而是在本地重试了 3 次</li><li>本地重试 3 次以后，抛出了 <code>AmqpRejectAndDontRequeueException</code> 异常。查看 RabbitMQ 控制台，发现消息被删除了，说明最后 SpringAMQP 返回的是 <code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会 requeue 到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring 会返回 reject，消息会被丢弃</li></ul><h2 id="2-3-失败处理策略"><a href="#2-3-失败处理策略" class="headerlink" title="2.3.失败处理策略"></a>2.3.失败处理策略</h2><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。</p><p>因此 Spring 允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由 <code>MessageRecovery</code> 接口来定义的，它有 3 个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接 <code>reject</code>，丢弃消息。默认就是这种方式</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回 <code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是 <code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在 consumer 服务中定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义一个 RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-业务幂等性"><a href="#2-4-业务幂等性" class="headerlink" title="2.4.业务幂等性"></a>2.4.业务幂等性</h2><p>何为幂等性？</p><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据 id 删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ 消息的重复投递</li></ul><p>我们在用户支付成功后会发送 MQ 消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。</p><p>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li></ol><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息 ID</li><li>业务状态判断</li></ul><h3 id="2-4-1-唯一消息-ID"><a href="#2-4-1-唯一消息-ID" class="headerlink" title="2.4.1.唯一消息 ID"></a>2.4.1.唯一消息 ID</h3><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的 id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一 ID 呢？</p><p>其实很简单，SpringAMQP 的 MessageConverter 自带了 MessageID 的功能，我们只要开启这个功能即可。</p><p>以 Jackson 的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-业务判断"><a href="#2-4-2-业务判断" class="headerlink" title="2.4.2.业务判断"></a>2.4.2.业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><p>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>相比较而言，消息 ID 的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p><p>以支付修改订单的业务为例，我们需要修改 <code>OrderServiceImpl</code> 中的 <code>markOrderPaySuccess</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">        <span class="comment">// 2.判断订单状态</span></span><br><span class="line">        <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        order.setStatus(<span class="number">2</span>);</span><br><span class="line">        order.setPayTime(LocalDateTime.now());</span><br><span class="line">        updateById(order);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p><p>我们可以合并上述操作为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，上述代码等同于这样的 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在 where 条件中除了判断 id 以外，还加上了 status 必须为 1 的条件。如果条件不符（说明订单已支付），则 SQL 匹配不到数据，根本不会执行。</p><h2 id="2-5-兜底方案"><a href="#2-5-兜底方案" class="headerlink" title="2.5.兜底方案"></a>2.5.兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息 100% 的可靠。万一真的 MQ 通知失败该怎么办呢？</p><p>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>其实思想很简单：既然 MQ 通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的 MQ 通知失败，我们依然能通过主动查询来保证订单状态的一致。</p><p>流程如下：</p><p>图中黄色线圈起来的部分就是 MQ 通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。</p><p>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。</p><p>那么问题来了，我们到底该在什么时间主动查询支付状态呢？</p><p>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔 20 秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。</p><p>定时任务大家之前学习过，具体的实现这里就不再赘述了。</p><p>至此，消息可靠性的问题已经解决了。</p><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证 MQ 消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便 MQ 通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h1 id="4-延迟消息"><a href="#4-延迟消息" class="headerlink" title="4.延迟消息"></a>4.延迟消息</h1><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p><p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>例如，订单支付超时时间为 30 分钟，则我们应该在用户下单后的第 30 分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p><p>但问题来了：如何才能准确的实现在下单后第 30 分钟去检查支付状态呢？</p><p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用 MQ 的延迟消息了。</p><p>在 RabbitMQ 中实现延迟消息也有两种方案：</p><ul><li>死信交换机 +TTL</li><li>延迟消息插件</li></ul><p>这一章我们就一起研究下这两种方案的实现方式，以及优缺点。</p><h2 id="4-1-死信交换机和延迟消息"><a href="#4-1-死信交换机和延迟消息" class="headerlink" title="4.1.死信交换机和延迟消息"></a>4.1.死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p><h3 id="4-1-1-死信交换机"><a href="#4-1-1-死信交换机" class="headerlink" title="4.1.1.死信交换机"></a>4.1.1.死信交换机</h3><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用 <code>basic.reject</code> 或 <code>basic.nack</code> 声明消费失败，并且消息的 <code>requeue</code> 参数设置为 false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过 <strong>dead-letter-exchange</strong> 属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因 TTL（有效期）到期的消息</li></ol><h3 id="4-1-2-延迟消息"><a href="#4-1-2-延迟消息" class="headerlink" title="4.1.2.延迟消息"></a>4.1.2.延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的 <code>RepublishMessageRecoverer</code> 作用类似。</p><p>而最后一种场景，大家设想一下这样的场景：</p><p>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是 <code>ttl.queue</code> 没有消费者监听，而是设定了死信交换机 <code>hmall.direct</code>，而队列 <code>direct.queue1</code> 则与死信交换机绑定，RoutingKey 是 blue：</p><p><img src="/post/b90bbc4/DU6Bbv9ELogXMVxjEYZcS4C4nae.png"></p><p>假如我们现在发送一条消息到 <code>ttl.fanout</code>，RoutingKey 为 blue，并设置消息的<strong>有效期</strong>为 5000 毫秒：</p><p><img src="/post/b90bbc4/IGCWbzpEKo3loaxCJWkcQukZnme.png"></p><p>消息肯定会被投递到 <code>ttl.queue</code> 之后，由于没有消费者，因此消息无人消费。5 秒之后，消息的有效期到期，成为死信：</p><p><img src="/post/b90bbc4/JLSsbX5RyoZCKTxCxhGcksRynFb.png"></p><p>死信被再次投递到死信交换机 <code>hmall.direct</code>，并沿用之前的 RoutingKey，也就是 <code>blue</code>：</p><p><img src="/post/b90bbc4/RVgSbj8otoQtKYxsd4jc2OdFnOb.png"></p><p>由于 <code>direct.queue1</code> 与 <code>hmall.direct</code> 绑定的 key 是 blue，因此最终消息被成功路由到 <code>direct.queue1</code>，如果此时有消费者与 <code>direct.queue1</code> 绑定， 也就能成功消费消息了。但此时已经是 5 秒钟以后了：</p><p><img src="/post/b90bbc4/KZx0bBSh7ofh4jxA0lTcTlL1nic.png"></p><p>也就是说，publisher 发送了一条消息，但最终 consumer 在 5 秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h3 id="4-1-3-总结"><a href="#4-1-3-总结" class="headerlink" title="4.1.3.总结"></a>4.1.3.总结</h3><h2 id="4-2-DelayExchange-插件"><a href="#4-2-DelayExchange-插件" class="headerlink" title="4.2.DelayExchange 插件"></a>4.2.DelayExchange 插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此 RabbitMQ 社区提供了一个延迟消息插件来实现相同的效果。</p><p>官方文档说明：</p><h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1.下载"></a>4.2.1.下载</h3><p>插件下载地址：</p><p>由于我们安装的 MQ 是 <code>3.8</code> 版本，因此这里下载 <code>3.8.17</code> 版本：</p><p><img src="/post/b90bbc4/KqSKbHiB5oHaCPxSVG5cBt00nac.png"></p><p>当然，也可以直接使用课前资料提供好的插件：</p><p><img src="/post/b90bbc4/U7x4bEQwcosUk2xNHdGc098znec.png"></p><h3 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2.安装"></a>4.2.2.安装</h3><p>因为我们是基于 Docker 安装，所以需要先查看 RabbitMQ 的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-19T09:22:59+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/mq-plugins/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mq-plugins&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>插件目录被挂载到了 <code>/var/lib/docker/volumes/mq-plugins/_data</code> 这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/post/b90bbc4/TZdFbdnG8oJ9aSxedA9cjII6n0f.png"></p><h3 id="4-2-3-声明延迟交换机"><a href="#4-2-3-声明延迟交换机" class="headerlink" title="4.2.3.声明延迟交换机"></a>4.2.3.声明延迟交换机</h3><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <code>@Bean</code> 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-发送延迟消息"><a href="#4-2-4-发送延迟消息" class="headerlink" title="4.2.4.发送延迟消息"></a>4.2.4.发送延迟消息</h3><p>发送消息时，必须通过 x-delay 属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-超时订单问题"><a href="#4-3-超时订单问题" class="headerlink" title="4.3.超时订单问题"></a>4.3.超时订单问题</h2><p>接下来，我们就在交易服务中利用延迟消息实现订单超时取消功能。其大概思路如下：</p><p><img src="/post/b90bbc4/MIOhbsy7KomGNMxnXXIc4Tu4nXW.jpeg"></p><p>假如订单超时支付时间为 30 分钟，理论上说我们应该在下单时发送一条延迟消息，延迟时间为 30 分钟。这样就可以在接收到消息时检验订单支付状态，关闭未支付订单。</p><p>但是大多数情况下用户支付都会在 1 分钟内完成，我们发送的消息却要在 MQ 中停留 30 分钟，额外消耗了 MQ 的资源。因此，我们最好多检测几次订单支付状态，而不是在最后第 30 分钟才检测。</p><p>例如：我们在用户下单后的第 10 秒、20 秒、30 秒、45 秒、60 秒、1 分 30 秒、2 分、…30 分分别设置延迟消息，如果提前发现订单已经支付，则后续的检测取消即可。</p><p>这样就可以有效避免对 MQ 资源的浪费了。</p><p>优化后的实现思路如下：</p><p><img src="/post/b90bbc4/SmNCbfSVkoAW63x9d1McO1DEnyb.jpeg"></p><p>由于我们要多次发送延迟消息，因此需要先定义一个记录消息延迟时间的消息体，处于通用性考虑，我们将其定义到 <code>hm-common</code> 模块下：</p><p><img src="/post/b90bbc4/EpYHbvNiSovHyQxTcjwcrlAOnKb.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiDelayMessage</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录延迟时间的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; delayMillis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiDelayMessage</span><span class="params">(T data, List&lt;Long&gt; delayMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.delayMillis = delayMillis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; MultiDelayMessage&lt;T&gt; <span class="title function_">of</span><span class="params">(T data, Long ... delayMillis)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultiDelayMessage</span>&lt;&gt;(data, CollUtils.newArrayList(delayMillis));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并移除下一个延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列中的第一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">removeNextDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayMillis.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否还有下一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNextDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !delayMillis.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-1-定义常量"><a href="#4-3-1-定义常量" class="headerlink" title="4.3.1.定义常量"></a>4.3.1.定义常量</h3><p>无论是消息发送还是接收都是在交易服务完成，因此我们在 <code>trade-service</code> 中定义一个常量类，用于记录交换机、队列、RoutingKey 等常量：</p><p><img src="/post/b90bbc4/GHBGbT2WLoreOwxwyT5cPu1anOf.png"></p><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MqConstants</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.topic&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;trade.order.delay.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;order.query&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-抽取共享-mq-配置"><a href="#4-3-2-抽取共享-mq-配置" class="headerlink" title="4.3.2.抽取共享 mq 配置"></a>4.3.2.抽取共享 mq 配置</h3><p>我们将 mq 的配置抽取到 nacos 中，方便各个微服务共享配置。</p><p>在 nacos 中定义一个名为 <code>shared-mq.xml</code> 的配置文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;hm.mq.host:192.168.150.101&#125;</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;hm.mq.port:5672&#125;</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">$&#123;hm.mq.vhost:/hmall&#125;</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.mq.un:hmall&#125;</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.mq.pw:123&#125;</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>这里只添加一些基础配置，至于生产者确认，消费者确认配置则由微服务根据业务自己决定。</p><p>在 <code>trade-service</code> 模块添加共享配置：</p><p><img src="/post/b90bbc4/B3AZbVyNzoVo4nxS863cyULtnyd.png"></p><h3 id="4-3-3-改造下单业务"><a href="#4-3-3-改造下单业务" class="headerlink" title="4.3.3.改造下单业务"></a>4.3.3.改造下单业务</h3><p>接下来，我们改造下单业务，在下单完成后，发送延迟消息，查询支付状态。</p><p>1）引入依赖</p><p>在 <code>trade-service</code> 模块的 <code>pom.xml</code> 中引入 amqp 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）改造下单业务</p><p>修改 <code>trade-service</code> 模块的 <code>com.hmall.trade.service.impl.OrderServiceImpl</code> 类的 <code>createOrder</code> 方法，添加消息发送的代码：</p><p><img src="/post/b90bbc4/EtARbmMkholu7MxCdzHcHL2hntX.png"></p><h3 id="4-3-4-编写查询支付状态接口"><a href="#4-3-4-编写查询支付状态接口" class="headerlink" title="4.3.4.编写查询支付状态接口"></a>4.3.4.编写查询支付状态接口</h3><p>由于 MQ 消息处理时需要查询支付状态，因此我们要在 pay-service 模块定义一个这样的接口，并提供对应的 FeignClient.</p><p>首先，在 hm-api 模块定义三个类：</p><p><img src="/post/b90bbc4/U4aPbhArAovCXyxs3iRcH6IUnAc.png"></p><p>说明：</p><ul><li>PayOrderDTO：支付单的数据传输实体</li><li>PayClient：支付系统的 Feign 客户端</li><li>PayClientFallback：支付系统的 fallback 逻辑</li></ul><p>PayOrderDTO 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 支付订单</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;支付单数据传输实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderDTO</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;业务订单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long payOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizUserId;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付渠道编码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String payChannelCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付金额，单位分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付类型，1：h5,2:小程序，3：公众号，4：扫码，5：余额支付&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer payType;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付状态，0：待提交，1:待支付，2：支付超时或取消，3：支付成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;拓展字段，用于传递不同渠道单独处理的字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String expandJson;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回业务码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回提示信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultMsg;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付成功时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime paySuccessTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付超时时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime payOverTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付二维码链接&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String qrCodeUrl;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;更新时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PayClient 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.fallback.PayClientFallback;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;pay-service&quot;, fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据交易订单id查询支付单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 业务订单id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支付单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay-orders/biz/&#123;id&#125;&quot;)</span></span><br><span class="line">    PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PayClientFallback 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;PayClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PayClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PayClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在 pay-service 模块的 PayController 中实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询支付单&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/biz/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> payOrderService.lambdaQuery().eq(PayOrder::getBizOrderNo, id).one();</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyBean(payOrder, PayOrderDTO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-消息监听"><a href="#4-3-5-消息监听" class="headerlink" title="4.3.5.消息监听"></a>4.3.5.消息监听</h3><p>接下来，我们在 trader-service 编写一个监听器，监听延迟消息，查询订单支付状态：</p><p><img src="/post/b90bbc4/M3hMbQwIxoGRZQxrTClc7r7gnje.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.domain.MultiDelayMessage;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.Order;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MqConstants.DELAY_ORDER_QUEUE, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MqConstants.DELAY_EXCHANGE, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = MqConstants.DELAY_ORDER_ROUTING_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderCheckDelayMessage</span><span class="params">(MultiDelayMessage&lt;Long&gt; msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取消息中的订单id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getData();</span><br><span class="line">        <span class="comment">// 2.查询订单，判断状态：1是未支付，大于1则是已支付或已关闭</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span> || order.getStatus() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 订单不存在或交易已经结束，放弃处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.可能是未支付，查询支付服务</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="keyword">if</span> (payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 支付成功，更新订单状态</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.确定未支付，判断是否还有剩余延迟时间</span></span><br><span class="line">        <span class="keyword">if</span> (msg.hasNextDelay()) &#123;</span><br><span class="line">            <span class="comment">// 4.1.有延迟时间，需要重发延迟消息，先获取延迟时间的int值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">delayVal</span> <span class="operator">=</span> msg.removeNextDelay().intValue();</span><br><span class="line">            <span class="comment">// 4.2.发送延迟消息</span></span><br><span class="line">            rabbitTemplate.convertAndSend(MqConstants.DELAY_EXCHANGE, MqConstants.DELAY_ORDER_ROUTING_KEY, msg,</span><br><span class="line">                    message -&gt; &#123;</span><br><span class="line">                        message.getMessageProperties().setDelay(delayVal);</span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.没有剩余延迟时间了，说明订单超时未支付，需要取消订单</span></span><br><span class="line">        orderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里要在 OrderServiceImpl 中实现 cancelOrder 方法，留作作业大家自行实现。</p><h1 id="5-作业"><a href="#5-作业" class="headerlink" title="5.作业"></a>5.作业</h1><h2 id="5-1-取消订单"><a href="#5-1-取消订单" class="headerlink" title="5.1.取消订单"></a>5.1.取消订单</h2><p>在处理超时未支付订单时，如果发现订单确实超时未支付，最终需要关闭该订单。</p><p>关闭订单需要完成两件事情：</p><ul><li>将订单状态修改为已关闭</li><li>恢复订单中已经扣除的库存</li></ul><p>这部分功能尚未实现。</p><p>大家要在 <code>IOrderService</code> 接口中定义 <code>cancelOrder</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span>;</span><br></pre></td></tr></table></figure><p>并且在 <code>OrderServiceImpl</code> 中实现该方法。实现过程中要注意业务幂等性判断。</p><h2 id="5-2-抽取-MQ-工具"><a href="#5-2-抽取-MQ-工具" class="headerlink" title="5.2.抽取 MQ 工具"></a>5.2.抽取 MQ 工具</h2><p>MQ 在企业开发中的常见应用我们就学习完毕了，除了收发消息以外，消息可靠性的处理、生产者确认、消费者确认、延迟消息等等编码还是相对比较复杂的。</p><p>因此，我们需要将这些常用的操作封装为工具，方便在项目中使用。要求如下：</p><ul><li><p>在 <code>hm-commom</code> 模块下编写发送消息的工具类 <code>RabbitMqHelper</code></p></li><li><p>定义一个自动配置类 <code>MqConsumeErrorAutoConfiguration</code>，内容包括：</p><ul><li>声明一个交换机，名为 <code>error.direct</code>，类型为 <code>direct</code></li><li>声明一个队列，名为：<code>微服务名 + error.queue</code>，也就是说要动态获取</li><li>将队列与交换机绑定，绑定时的 <code>RoutingKey</code> 就是 <code>微服务名</code></li><li>声明 <code>RepublishMessageRecoverer</code>，消费失败消息投递到上述交换机</li><li>给配置类添加条件，当 <code>spring.rabbitmq.listener.simple.retry.enabled</code> 为 <code>true</code> 时触发</li></ul></li></ul><p>RabbitMqHelper 的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object msg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> delay)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-改造业务"><a href="#5-3-改造业务" class="headerlink" title="5.3.改造业务"></a>5.3.改造业务</h2><p>利用你编写的工具，改造支付服务、购物车服务、交易服务中消息发送功能，并且添加消息确认或消费者重试机制，确保消息的可靠性。</p>]]></content>
    
    
    <summary type="html">MQ学习</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="MQ" scheme="https://threewood1.top/tags/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://threewood1.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ基础</title>
    <link href="https://threewood1.top/post/2ef47cbd.html"/>
    <id>https://threewood1.top/post/2ef47cbd.html</id>
    <published>2024-01-22T08:02:07.000Z</published>
    <updated>2024-01-22T08:17:31.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ基础"><a href="#MQ基础" class="headerlink" title="MQ基础"></a>MQ基础</h1><p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于 OpenFeign 的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p><p>我们先来看看什么是同步通讯和异步通讯。如图：</p><p><img src="/post/2ef47cbd/B82Sbxk3DoAsVTx7KV1cXjz3nsg.png"></p><p>解读：</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><p>同步调用的方式我们已经学过了，之前的 OpenFeign 调用就是。但是：</p><ul><li>异步调用又该如何实现？</li><li>哪些业务适合用异步调用来实现呢？</li></ul><p>通过今天的学习你就能明白这些问题了。</p><h1 id="1-初识-MQ"><a href="#1-初识-MQ" class="headerlink" title="1.初识 MQ"></a>1.初识 MQ</h1><h2 id="1-1-同步调用"><a href="#1-1-同步调用" class="headerlink" title="1.1.同步调用"></a>1.1.同步调用</h2><p>之前说过，我们现在基于 OpenFeign 的调用都属于是同步调用，那么这种方式存在哪些问题呢？</p><p>举个例子，我们以昨天留给大家作为作业的<strong>余额支付功能</strong>为例来分析，首先看下整个流程：</p><p>目前我们采用的是基于 OpenFeign 的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。</p><p>这其中就存在 3 个问题：</p><p><strong>第一</strong>，<strong>拓展性差</strong></p><p>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。</p><p>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？</p><p>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？</p><p>。。。</p><p>最终你的支付业务会越来越臃肿：</p><p>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</p><p><strong>第二</strong>，<strong>性能下降</strong></p><p>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：</p><p>假如每个微服务的执行时长都是 50ms，则最终整个业务的耗时可能高达 300ms，性能太差了。</p><p><strong>第三，<strong><strong>级联</strong></strong>失败</strong></p><p>由于我们是基于 OpenFeign 调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</p><p>这其实就是同步调用的<strong>级联****失败</strong>问题。</p><p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧。</p><p><img src="/post/2ef47cbd/CSCWbPDPvo6OVux4ZKecjLVFnsd.png"></p><p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p><p>综上，同步调用的方式存在下列问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败</li></ul><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h2 id="1-2-异步调用"><a href="#1-2-异步调用" class="headerlink" title="1.2.异步调用"></a>1.2.异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息 Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息 Broker。然后接收者根据自己的需求从消息 Broker 那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>还是以余额支付业务为例：</p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到 Broker。而相关的微服务都可以订阅消息通知，一旦消息到达 Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：</p><p>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅 100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于 Broker 的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h2 id="1-3-技术选型"><a href="#1-3-技术选型" class="headerlink" title="1.3.技术选型"></a>1.3.技术选型</h2><p>消息 Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为 MQ.</p><p>目比较常见的 MQ 实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见 MQ 的对比：</p><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>据统计，目前国内消息队列使用最多的还是 RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择 RabbitMQ 来学习。</p><h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h1><p>RabbitMQ 是基于 Erlang 语言开发的开源消息通信中间件，官网地址：</p><p><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p>接下来，我们就学习它的基本概念和基础用法。</p><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1.安装"></a>2.1.安装</h2><p>我们同样基于 Docker 来安装 RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hm-net\</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用 docker load 命令加载：</p><p><img src="/post/2ef47cbd/KWDWbLtlfodeGBxOs94c3JFdn9g.png"></p><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ 提供的管理控制台的端口</li><li>5672：RabbitMQ 的消息发送处理接口</li></ul><p>安装完成后，我们访问 <a href="http://192.168.150.101:15672/">http://192.168.150.101</a> 即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</p><p>登录后即可看到管理控制台总览页面：</p><p><img src="/post/2ef47cbd/YNs9bu47Vo3o1gxnEw1cI9MxnUM.png"></p><p>RabbitMQ 对应的架构如图：</p><p><img src="/post/2ef47cbd/HH6fbYlGsoySg1x34UBczqjZnSb.png"></p><p>其中包含几个概念：</p><ul><li><strong>publisher</strong>：生产者，也就是发送消息的一方</li><li><strong>consumer</strong>：消费者，也就是消费消息的一方</li><li><strong>queue</strong>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><strong>exchange</strong>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><strong>virtual host</strong>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的 exchange、queue</li></ul><p>上述这些东西都可以在 RabbitMQ 的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p><h2 id="2-2-收发消息"><a href="#2-2-收发消息" class="headerlink" title="2.2.收发消息"></a>2.2.收发消息</h2><h3 id="2-2-1-交换机"><a href="#2-2-1-交换机" class="headerlink" title="2.2.1.交换机"></a>2.2.1.交换机</h3><p>我们打开 Exchanges 选项卡，可以看到已经存在很多交换机：</p><p><img src="/post/2ef47cbd/Dc0VbMHYwoBM1ZxLdRtcAJTZnGc.png"></p><p>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的 publish message 发送一条消息：</p><p><img src="/post/2ef47cbd/TMlKboOgZom7Y7xfJ9CccgPdnNh.png"></p><p><img src="/post/2ef47cbd/BTUkbvuDVo29JDx9YURcYjhFnPc.png"></p><p>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h3 id="2-2-2-队列"><a href="#2-2-2-队列" class="headerlink" title="2.2.2.队列"></a>2.2.2.队列</h3><p>我们打开 <code>Queues</code> 选项卡，新建一个队列：</p><p><img src="/post/2ef47cbd/GvVobsp7uoSxfox0c0gcU14dnSc.png"></p><p>命名为 <code>hello.queue1</code>：</p><p><img src="/post/2ef47cbd/Ew31bOIBoo18dRxIFubcJva0nXf.png"></p><p>再以相同的方式，创建一个队列，密码为 <code>hello.queue2</code>，最终队列列表如下：</p><p><img src="/post/2ef47cbd/SmOobtVzSou586xV1a9cF11tn5d.png"></p><p>此时，我们再次向 <code>amq.fanout</code> 交换机发送一条消息。会发现消息依然没有到达队列！！</p><p>怎么回事呢？</p><p>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h3 id="2-2-3-绑定关系"><a href="#2-2-3-绑定关系" class="headerlink" title="2.2.3.绑定关系"></a>2.2.3.绑定关系</h3><p>点击 <code>Exchanges</code> 选项卡，点击 <code>amq.fanout</code> 交换机，进入交换机详情页，然后点击 <code>Bindings</code> 菜单，在表单中填写要绑定的队列名称：</p><p><img src="/post/2ef47cbd/HZ2fbpinhoLs4AxqzudcTrSdnWD.png"></p><p>相同的方式，将 hello.queue2 也绑定到改交换机。</p><p>最终，绑定结果如下：</p><p><img src="/post/2ef47cbd/WFcXbuLVzoa4NxxmZrycHEs8nwh.png"></p><h3 id="2-2-4-发送消息"><a href="#2-2-4-发送消息" class="headerlink" title="2.2.4.发送消息"></a>2.2.4.发送消息</h3><p>再次回到 exchange 页面，找到刚刚绑定的 <code>amq.fanout</code>，点击进入详情页，再次发送一条消息：</p><p><img src="/post/2ef47cbd/HzIWbJaR2oGiqwxypvocuQfYn0e.png"></p><p>回到 <code>Queues</code> 页面，可以发现 <code>hello.queue</code> 中已经有一条消息了：</p><p><img src="/post/2ef47cbd/ZROjbesEYoIkqcxLYM2cl3lcnZf.png"></p><p>点击队列名称，进入详情页，查看队列详情，这次我们点击 get message：</p><p><img src="/post/2ef47cbd/XaPeboPQVovkH6xM453cTvqmnDe.png"></p><p>可以看到消息到达队列了：</p><p><img src="/post/2ef47cbd/BR8mbRZOkohqUAxbOUncGdZ1nde.png"></p><p>这个时候如果有消费者监听了 MQ 的 <code>hello.queue1</code> 或 <code>hello.queue2</code> 队列，自然就能接收到消息了。</p><h2 id="2-3-数据隔离"><a href="#2-3-数据隔离" class="headerlink" title="2.3.数据隔离"></a>2.3.数据隔离</h2><h3 id="2-3-1-用户管理"><a href="#2-3-1-用户管理" class="headerlink" title="2.3.1.用户管理"></a>2.3.1.用户管理</h3><p>点击 <code>Admin</code> 选项卡，首先会看到 RabbitMQ 控制台的用户管理界面：</p><p><img src="/post/2ef47cbd/P27GbS0zAoWnPgx7LCQcFMlonBf.png"></p><p>这里的用户都是 RabbitMQ 的管理或运维人员。目前只有安装 RabbitMQ 时添加的 <code>itheima</code> 这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>itheima</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明 <code>itheima</code> 用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的 <code>virtual host</code>，这里的 <code>/</code> 是默认的 <code>virtual host</code></li></ul><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套 MQ 集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用 <code>virtual host</code> 的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的 <code>virtual host</code>，将每个项目的数据隔离。</li></ul><p>比如，我们给黑马商城创建一个新的用户，命名为 <code>hmall</code>：</p><p><img src="/post/2ef47cbd/TbVRbsJaKoL3VSxFGVWcbfV0nbd.png"></p><p>你会发现此时 hmall 用户没有任何 <code>virtual host</code> 的访问权限：</p><p><img src="/post/2ef47cbd/YCq6beky1oiD5yxR3klctQh3nCf.png"></p><p>别急，接下来我们就来授权。</p><h3 id="2-3-2-virtual-host"><a href="#2-3-2-virtual-host" class="headerlink" title="2.3.2.virtual host"></a>2.3.2.virtual host</h3><p>我们先退出登录：</p><p><img src="/post/2ef47cbd/Nf5AbO0mKo7RTixOUrUcdfWRn9e.png"></p><p>切换到刚刚创建的 hmall 用户登录，然后点击 <code>Virtual Hosts</code> 菜单，进入 <code>virtual host</code> 管理页：</p><p><img src="/post/2ef47cbd/NWSObodw1oiLcHxYW1TcD4rBn4b.png"></p><p>可以看到目前只有一个默认的 <code>virtual host</code>，名字为 <code>/</code>。</p><p>我们可以给黑马商城项目创建一个单独的 <code>virtual host</code>，而不是使用默认的 <code>/</code>。</p><p><img src="/post/2ef47cbd/GJwSbnpcEolw3cxtLU1cNzTcncc.png"></p><p>创建完成后如图：</p><p><img src="/post/2ef47cbd/BC6EbcBTKoaE3cxoJDWc9sTmnkc.png"></p><p>由于我们是登录 <code>hmall</code> 账户后创建的 <code>virtual host</code>，因此回到 <code>users</code> 菜单，你会发现当前用户已经具备了对 <code>/hmall</code> 这个 <code>virtual host</code> 的访问权限了：</p><p><img src="/post/2ef47cbd/Gl4QbT3buoVEo9xTnK3cXkqAnbG.png"></p><p>此时，点击页面右上角的 <code>virtual host</code> 下拉菜单，切换 <code>virtual host</code> 为 <code>/hmall</code>：</p><p><img src="/post/2ef47cbd/EOg4br4TooRmRpxCF9fcfhtkn6g.png"></p><p>然后再次查看 queues 选项卡，会发现之前的队列已经看不到了：</p><p><img src="/post/2ef47cbd/Xs2hbPZzTojKP0xNWpkcBZuin0g.png"></p><p>这就是基于 <code>virtual host </code> 的隔离效果。</p><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于 <code>RabbitMQ</code> 采用了 AMQP 协议，因此它具备跨语言的特性。任何语言只要遵循 AMQP 协议收发消息，都可以与 <code>RabbitMQ</code> 交互。并且 <code>RabbitMQ</code> 官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ 官方提供的 Java 客户端编码相对复杂，一般生产环境下我们更多会结合 Spring 来使用。而 Spring 的官方刚好基于 RabbitMQ 提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于 SpringBoot 对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp 的官方地址：</p><p>SpringAMQP 提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了 RabbitTemplate 工具，用于发送消息</li></ul><p>这一章我们就一起学习一下，如何利用 SpringAMQP 实现对 RabbitMQ 的消息收发。</p><h2 id="3-1-导入-Demo-工程"><a href="#3-1-导入-Demo-工程" class="headerlink" title="3.1.导入 Demo 工程"></a>3.1.导入 Demo 工程</h2><p>在课前资料给大家提供了一个 Demo 工程，方便我们学习 SpringAMQP 的使用：</p><p><img src="/post/2ef47cbd/NTJubEDiVovAn5xS4SScLUUjn4u.png"></p><p>将其复制到你的工作空间，然后用 Idea 打开，项目结构如图：</p><p><img src="/post/2ef47cbd/TWK8bTyJmoRYi2xTzy1cBTGgnyh.png"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在 mq-demo 这个父工程中，已经配置好了 SpringAMQP 相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>publisher<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，子工程中就可以直接使用 SpringAMQP 了。</p><h2 id="3-2-快速入门"><a href="#3-2-快速入门" class="headerlink" title="3.2.快速入门"></a>3.2.快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。</p><p>在入门案例中，我们就演示这样的简单模型，如图：</p><p>也就是：</p><ul><li>publisher 直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><p>为了方便测试，我们现在控制台新建一个队列：simple.queue</p><p><img src="/post/2ef47cbd/Pcxnbpl73o8QGwxN30ickh1Gn8f.png"></p><p>添加成功：</p><p><img src="/post/2ef47cbd/IUojbN003ocDoyxs4EUc9sopnFP.png"></p><p>接下来，我们就可以利用 Java 代码收发消息了。</p><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置 MQ 地址，在 <code>publisher</code> 服务的 <code>application.yml</code> 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在 <code>publisher</code> 服务中编写测试类 <code>SpringAmqpTest</code>，并利用 <code>RabbitTemplate</code> 实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.amqp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开控制台，可以看到消息已经发送到队列中：</p><p><img src="/post/2ef47cbd/N8Nsbeatqo5bGUx7OWJc4M1Anke.png"></p><p>接下来，我们再来实现消息接收。</p><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置 MQ 地址，在 <code>consumer</code> 服务的 <code>application.yml</code> 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在 <code>consumer</code> 服务的 <code>com.itheima.consumer.listener</code> 包中新建一个类 <code>SpringRabbitListener</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">        <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动 consumer 服务，然后在 publisher 服务中运行测试代码，发送 MQ 消息。最终 consumer 收到消息：</p><p><img src="/post/2ef47cbd/Vbf6b35dyoJb2HxdS8Nc7GI1nOf.png"></p><h2 id="3-3-WorkQueues-模型"><a href="#3-3-WorkQueues-模型" class="headerlink" title="3.3.WorkQueues 模型"></a>3.3.WorkQueues 模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用 work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来，我们就来模拟这样的场景。</p><p>首先，我们在控制台创建一个新的队列，命名为 <code>work.queue</code>：</p><p><img src="/post/2ef47cbd/HzN7btEXko5VcSxTLx7ca8egnhu.png"></p><h3 id="3-3-1-消息发送"><a href="#3-3-1-消息发送" class="headerlink" title="3.3.1.消息发送"></a>3.3.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在 publisher 服务中的 SpringAmqpTest 类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-消息接收"><a href="#3-3-2-消息接收" class="headerlink" title="3.3.2.消息接收"></a>3.3.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在 consumer 服务的 SpringRabbitListener 中添加 2 个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这两消费者，都设置了 <code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者 1 sleep 了 20 毫秒，相当于每秒钟处理 50 个消息</li><li>消费者 2 sleep 了 200 毫秒，相当于每秒处理 5 个消息</li></ul><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a>3.3.3.测试</h3><p>启动 ConsumerApplication 后，在执行 publisher 服务中刚刚编写的发送测试方法 testWorkQueue。</p><p>最终结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.869555300</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.884518</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.907454400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.953332100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.997867300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.042178700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.086478800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.087476600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.132578300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.175851200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.218533400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.261322900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.287003700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.304412400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.349950100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.394533900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.439876500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.482937800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.488977100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.526409300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.572148</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.618264800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.660780600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.689189300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.705261</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.746927300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.789835</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.834393100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.875312100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.889969500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.920702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.090725900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.293060600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.493748</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.696635100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.896809700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.099533400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.301446400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.504999100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.705702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.906601200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.108118500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.308945400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.511547700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.714038400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.916192700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.116286400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.318055100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.520656400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.723106700</span></span><br></pre></td></tr></table></figure><p>可以看到消费者 1 和消费者 2 竟然每人消费了 25 条消息：</p><ul><li>消费者 1 很快完成了自己的 25 条消息</li><li>消费者 2 却在缓慢的处理自己的 25 条消息。</li></ul><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致 1 个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了 1 秒。这样显然是有问题的。</p><h3 id="3-3-4-能者多劳"><a href="#3-3-4-能者多劳" class="headerlink" title="3.3.4.能者多劳"></a>3.3.4.能者多劳</h3><p>在 spring 中有一个简单的配置，可以解决这个问题。我们修改 consumer 服务的 application.yml 文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>再次测试，发现结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.659664200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.680610</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.703625</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.724330100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.746651100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.768401400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.790511400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.812559800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.834500600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.857438800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.880379600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.899327100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.922828400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.945617400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.968942500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.992215400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.013325600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.035687100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.058188</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.081208400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.103406200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.123827300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.146165100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.168828300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.191769500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.214839100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.238998700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.259772600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.284131800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.306190600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.325315800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.347012500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.368508600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.391785100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.416383800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.439019</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.461733900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.485990</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.509219900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.523683400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.547412100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.571191800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.593024600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.616731800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.640317</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.663111100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.686727</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.709266500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.725884900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.746299900</span></span><br></pre></td></tr></table></figure><p>可以发现，由于消费者 1 处理速度较快，所以处理了更多的消息；消费者 2 处理速度较慢，只处理了 6 条消息。而最终总的执行耗时也在 1 秒左右，大大提升。</p><p>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h3 id="3-3-5-总结"><a href="#3-3-5-总结" class="headerlink" title="3.3.5.总结"></a>3.3.5.总结</h3><p>Work 模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置 prefetch 来控制消费者预取的消息数量</li></ul><h2 id="3-4-交换机类型"><a href="#3-4-交换机类型" class="headerlink" title="3.4.交换机类型"></a>3.4.交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><p>可以看到，在订阅模型中，多了一个 exchange 角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange 的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（<strong><strong>交换机</strong></strong>）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是 Fanout 交换机</li><li><strong>Direct</strong>：订阅，基于 RoutingKey（路由 key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与 Direct 类似，只不过 RoutingKey 可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于 MQ 的消息头匹配，用的较少。</li></ul><p>课堂中，我们讲解前面的三种交换机模式。</p><h2 id="3-5-Fanout-交换机"><a href="#3-5-Fanout-交换机" class="headerlink" title="3.5.Fanout 交换机"></a>3.5.Fanout 交换机</h2><p>Fanout，英文翻译是扇出，我觉得在 MQ 中叫广播更合适。</p><p>在广播模式下，消息发送流程是这样的：</p><p><img src="/post/2ef47cbd/Z0PrbLnmnocBcyx8Xn0cyIShnjb.png"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到 Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><p><img src="/post/2ef47cbd/Reynb5FGbosgNVxHA1HclKlAnfg.png"></p><ul><li>创建一个名为 <code> hmall.fanout</code> 的交换机，类型是 <code>Fanout</code></li><li>创建两个队列 <code>fanout.queue1</code> 和 <code>fanout.queue2</code>，绑定到交换机 <code>hmall.fanout</code></li></ul><h3 id="3-5-1-声明队列和交换机"><a href="#3-5-1-声明队列和交换机" class="headerlink" title="3.5.1.声明队列和交换机"></a>3.5.1.声明队列和交换机</h3><p>在控制台创建队列 <code>fanout.queue1</code>:</p><p><img src="/post/2ef47cbd/TvF5bHPaWowb7exZc6LcFhsPnSr.png"></p><p>在创建一个队列 <code>fanout.queue2</code>：</p><p><img src="/post/2ef47cbd/U4PnbzhFtogqyIxrvOycO9xLnOe.png"></p><p>然后再创建一个交换机：</p><p><img src="/post/2ef47cbd/Jpc3b21AmodhVdx1pdIceYV7nHg.png"></p><p>然后绑定两个队列到交换机：</p><p><img src="/post/2ef47cbd/MlREb8DvBoFHmJxFiEJciMLVn8b.png"></p><p><img src="/post/2ef47cbd/ReCibIyUDoZbmXx4rJecltt7n6f.png"></p><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-消息接收"><a href="#3-5-3-消息接收" class="headerlink" title="3.5.3.消息接收"></a>3.5.3.消息接收</h3><p>在 consumer 服务的 SpringRabbitListener 中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-4-总结"><a href="#3-5-4-总结" class="headerlink" title="3.5.4.总结"></a>3.5.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收 publisher 发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange 的会将消息路由到每个绑定的队列</li></ul><h2 id="3-6-Direct-交换机"><a href="#3-6-Direct-交换机" class="headerlink" title="3.6.Direct 交换机"></a>3.6.Direct 交换机</h2><p>在 Fanout 模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到 Direct 类型的 Exchange。</p><p><img src="/post/2ef47cbd/El3hbCOh3ohMT2xatZJcpcqwnDc.png"></p><p>在 Direct 模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 <code>RoutingKey</code>（路由 key）</li><li>消息的发送方在 向 Exchange 发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 <code>Routing Key</code> 进行判断，只有队列的 <code>Routingkey</code> 与消息的 <code>Routing key</code> 完全一致，才会接收到消息</li></ul><p><strong>案例需求如图</strong>：</p><p><img src="/post/2ef47cbd/SschbFsTao91PvxfZWKc6L54nkd.png"></p><ol><li>声明一个名为 <code>hmall.direct</code> 的交换机</li><li>声明队列 <code>direct.queue1</code>，绑定 <code>hmall.direct</code>，<code>bindingKey</code> 为 <code>blud</code> 和 <code>red</code></li><li>声明队列 <code>direct.queue2</code>，绑定 <code>hmall.direct</code>，<code>bindingKey</code> 为 <code>yellow</code> 和 <code>red</code></li><li>在 <code>consumer</code> 服务中，编写两个消费者方法，分别监听 direct.queue1 和 direct.queue2</li><li>在 publisher 中编写测试方法，向 <code>hmall.direct</code> 发送消息</li></ol><h3 id="3-6-1-声明队列和交换机"><a href="#3-6-1-声明队列和交换机" class="headerlink" title="3.6.1.声明队列和交换机"></a>3.6.1.声明队列和交换机</h3><p>首先在控制台声明两个队列 <code>direct.queue1</code> 和 <code>direct.queue2</code>，这里不再展示过程：</p><p><img src="/post/2ef47cbd/XeRPbclP1odEO1xa22Hc50Non6p.png"></p><p>然后声明一个 direct 类型的交换机，命名为 <code>hmall.direct</code>:</p><p><img src="/post/2ef47cbd/SvpDbCaV8oXzzpx4oUScSftLnzf.png"></p><p>然后使用 <code>red</code> 和 <code>blue</code> 作为 key，绑定 <code>direct.queue1</code> 到 <code>hmall.direct</code>：</p><p><img src="/post/2ef47cbd/UIjhbp9j8op6Uux1MaqcxAF7nEg.png"></p><p><img src="/post/2ef47cbd/Ua6Nb5S5yoV2dGxOm5gcGFNonBb.png"></p><p>同理，使用 <code>red</code> 和 <code>yellow</code> 作为 key，绑定 <code>direct.queue2</code> 到 <code>hmall.direct</code>，步骤略，最终结果：</p><p><img src="/post/2ef47cbd/ChembAGFOoGUquxlMvhcJcn7nCg.png"></p><h3 id="3-6-2-消息接收"><a href="#3-6-2-消息接收" class="headerlink" title="3.6.2.消息接收"></a>3.6.2.消息接收</h3><p>在 consumer 服务的 SpringRabbitListener 中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息发送"><a href="#3-6-3-消息发送" class="headerlink" title="3.6.3.消息发送"></a>3.6.3.消息发送</h3><p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用的 red 这个 key，所以两个消费者都收到了消息：</p><p><img src="/post/2ef47cbd/QrjCbcq13oBpB3x9uoxcvK0mngh.png"></p><p>我们再切换为 blue 这个 key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;最新报道，哥斯拉是居民自治巨型气球，虚惊一场！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，只有消费者 1 收到了消息：</p><p><img src="/post/2ef47cbd/YyVGb2Z7BoWu2exjQGMc15BRnwf.png"></p><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下 Direct 交换机与 Fanout 交换机的差异？</p><ul><li>Fanout 交换机将消息路由给每一个与之绑定的队列</li><li>Direct 交换机根据 RoutingKey 判断路由给哪个队列</li><li>如果多个队列具有相同的 RoutingKey，则与 Fanout 功能类似</li></ul><h2 id="3-7-Topic-交换机"><a href="#3-7-Topic-交换机" class="headerlink" title="3.7.Topic 交换机"></a>3.7.Topic 交换机</h2><h3 id="3-7-1-说明"><a href="#3-7-1-说明" class="headerlink" title="3.7.1.说明"></a>3.7.1.说明</h3><p><code>Topic</code> 类型的 <code>Exchange</code> 与 <code>Direct</code> 相比，都是可以根据 <code>RoutingKey</code> 把消息路由到不同的队列。</p><p>只不过 <code>Topic</code> 类型 <code>Exchange</code> 可以让队列在绑定 <code>BindingKey</code> 的时候使用通配符！</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以 <code>.</code> 分割，例如： <code>item.insert</code></p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好 1 个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配 <code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配 <code>item.spu</code></li></ul><p>图示：</p><p><img src="/post/2ef47cbd/QFzzbeUUjoVf0RxfS1AcgT7LnUe.png"></p><p>假如此时 publisher 发送的消息使用的 <code>RoutingKey</code> 共有四种：</p><ul><li><code>china.news </code> 代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>解释：</p><ul><li><p><code>topic.queue1</code>：绑定的是 <code>china.#</code> ，凡是以 <code>china.</code> 开头的 <code>routing key</code> 都会被匹配到，包括：</p><ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><p><code>topic.queue2</code>：绑定的是 <code>#.news</code> ，凡是以 <code>.news</code> 结尾的 <code>routing key</code> 都会被匹配。包括:</p><ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>接下来，我们就按照上图所示，来演示一下 Topic 交换机的用法。</p><p>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机。此处步骤略。最终结果如下：</p><p><img src="/post/2ef47cbd/H2ZubsD1woeetoxIHMjcuFRanJd.png"></p><h3 id="3-7-2-消息发送"><a href="#3-7-2-消息发送" class="headerlink" title="3.7.2.消息发送"></a>3.7.2.消息发送</h3><p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topicExchange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-3-消息接收"><a href="#3-7-3-消息接收" class="headerlink" title="3.7.3.消息接收"></a>3.7.3.消息接收</h3><p>在 consumer 服务的 SpringRabbitListener 中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-4-总结"><a href="#3-7-4-总结" class="headerlink" title="3.7.4.总结"></a>3.7.4.总结</h3><p>描述下 Direct 交换机与 Topic 交换机的差异？</p><ul><li>Topic 交换机接收的消息 RoutingKey 必须是多个单词，以 <strong>.</strong> 分割</li><li>Topic 交换机与队列绑定时的 bindingKey 可以指定通配符</li><li><code>#</code>：代表 0 个或多个词</li><li><code>*</code>：代表 1 个词</li></ul><h2 id="3-8-声明队列和交换机"><a href="#3-8-声明队列和交换机" class="headerlink" title="3.8.声明队列和交换机"></a>3.8.声明队列和交换机</h2><p>在之前我们都是基于 RabbitMQ 控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。</p><p>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="3-8-1-基本-API"><a href="#3-8-1-基本-API" class="headerlink" title="3.8.1.基本 API"></a>3.8.1.基本 API</h3><p>SpringAMQP 提供了一个 Queue 类，用来创建队列：</p><p><img src="/post/2ef47cbd/LMnRbQuaIoHHrkxByzLcsSPFnjh.png"></p><p>SpringAMQP 还提供了一个 Exchange 接口，来表示所有不同类型的交换机：</p><p><img src="/post/2ef47cbd/RwxPbRd0boAOLhxx6qzcXQPqnKd.png"></p><p>我们可以自己创建队列和交换机，不过 SpringAMQP 还提供了 ExchangeBuilder 来简化这个过程：</p><p><img src="/post/2ef47cbd/JDYsbeQn2o2P81xGpvOc5znfn7b.png"></p><p>而在绑定队列和交换机时，则需要使用 BindingBuilder 来创建 Binding 对象：</p><p><img src="/post/2ef47cbd/XV57bsutQovJ1kxafTUcqsFWnkh.png"></p><h3 id="3-8-2-fanout-示例"><a href="#3-8-2-fanout-示例" class="headerlink" title="3.8.2.fanout 示例"></a>3.8.2.fanout 示例</h3><p>在 consumer 中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-2-direct-示例"><a href="#3-8-2-direct-示例" class="headerlink" title="3.8.2.direct 示例"></a>3.8.2.direct 示例</h3><p>direct 模式由于要绑定多个 KEY，会非常麻烦，每一个 Key 都要编写一个 binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-4-基于注解声明"><a href="#3-8-4-基于注解声明" class="headerlink" title="3.8.4.基于注解声明"></a>3.8.4.基于注解声明</h3><p>基于 @Bean 的方式声明队列和交换机比较麻烦，Spring 还提供了基于注解方式来声明。</p><p>例如，我们同样声明 Direct 模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单多了。</p><p>再试试 Topic 模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-消息转换器"><a href="#3-9-消息转换器" class="headerlink" title="3.9.消息转换器"></a>3.9.消息转换器</h2><p>Spring 的消息发送代码接收的消息体是一个 Object：</p><p><img src="/post/2ef47cbd/AEDob0gXNozbGTxWbXGceQV3nAf.png"></p><p>而在数据传输时，它会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。</p><p>只不过，默认情况下 Spring 采用的序列化方式是 JDK 序列化。众所周知，JDK 序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-9-1-测试默认转换器"><a href="#3-9-1-测试默认转换器" class="headerlink" title="3.9.1.测试默认转换器"></a>3.9.1.测试默认转换器</h3><p>1）创建测试队列</p><p>首先，我们在 consumer 服务中声明一个新的配置类：</p><p><img src="/post/2ef47cbd/UZB0bgLppoZosXxtKvkc1ts6nMh.png"></p><p>利用 @Bean 的方式创建一个队列，</p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。</p><p>重启 consumer 服务以后，该队列就会被自动创建出来了：</p><p><img src="/post/2ef47cbd/ROnHbyCujojbQ1xYIVlchnNznsh.png"></p><p>2）发送消息</p><p>我们在 publisher 模块的 SpringAmqpTest 中新增一个消息发送的代码，发送一个 Map 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台：</p><p><img src="/post/2ef47cbd/QPu1bYlfHot8wmxXxp8cB9Qzn9d.png"></p><p>可以看到消息格式非常不友好。</p><h3 id="3-9-2-配置-JSON-转换器"><a href="#3-9-2-配置-JSON-转换器" class="headerlink" title="3.9.2.配置 JSON 转换器"></a>3.9.2.配置 JSON 转换器</h3><p>显然，JDK 序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用 JSON 方式来做序列化和反序列化。</p><p>在 <code>publisher</code> 和 <code>consumer</code> 两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果项目中引入了 <code>spring-boot-starter-web</code> 依赖，则无需再次引入 <code>Jackson</code> 依赖。</p><p>配置消息转换器，在 <code>publisher</code> 和 <code>consumer</code> 两个服务的启动类中添加一个 Bean 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的 messageId 可以便于我们将来做幂等性判断。</p><p>此时，我们到 MQ 控制台<strong>删除</strong> <code>object.queue</code> 中的旧的消息。然后再次执行刚才的消息发送的代码，到 MQ 的控制台查看消息结构：</p><p><img src="/post/2ef47cbd/AEhhb30KoosYHRxuAQIcHXUSnLh.png"></p><h3 id="3-9-3-消费者接收-Object"><a href="#3-9-3-消费者接收-Object" class="headerlink" title="3.9.3.消费者接收 Object"></a>3.9.3.消费者接收 Object</h3><p>我们在 consumer 服务中定义一个新的消费者，publisher 是用 Map 发送，那么消费者也一定要用 Map 接收，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-业务改造"><a href="#4-业务改造" class="headerlink" title="4.业务改造"></a>4.业务改造</h1><p>案例需求：改造余额支付功能，将支付成功后基于 OpenFeign 的交易服务的更新订单状态接口的同步调用，改为基于 RabbitMQ 的异步通知。</p><p>如图：</p><p><img src="/post/2ef47cbd/Tbp6bvaoGohCtExJLbnccmrrnec.png"></p><p>说明，我们只关注交易服务，步骤如下：</p><ul><li>定义 topic 类型交换机，命名为 <code>pay.topic</code></li><li>定义消息队列，命名为 <code>mark.order.pay.queue</code></li><li>将 <code>mark.order.pay.queue</code> 与 <code>pay.topic</code> 绑定，<code>BindingKey</code> 为 <code>pay.success</code></li><li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到 <code>pay.topic</code>，发送消息的 <code>RoutingKey</code>  为 <code>pay.success</code>，消息内容是订单 id</li><li>交易服务监听 <code>mark.order.pay.queue</code> 队列，接收到消息后更新订单状态为已支付</li></ul><h2 id="4-1-配置-MQ"><a href="#4-1-配置-MQ" class="headerlink" title="4.1.配置 MQ"></a>4.1.配置 MQ</h2><p>不管是生产者还是消费者，都需要配置 MQ 的基本信息。分为两步：</p><p>1）添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置 MQ 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h2 id="4-1-接收消息"><a href="#4-1-接收消息" class="headerlink" title="4.1.接收消息"></a>4.1.接收消息</h2><p>在 trade-service 服务中定义一个消息监听类：</p><p><img src="/post/2ef47cbd/S7RZbgUBMoqrTZxUXMicKsf3n9j.png"></p><p>其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;mark.order.pay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;pay.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;pay.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenPaySuccess</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-发送消息"><a href="#4-2-发送消息" class="headerlink" title="4.2.发送消息"></a>4.2.发送消息</h2><p>修改 <code>pay-service</code> 服务下的 <code>com.hmall.pay.service.impl.PayOrderServiceImpl</code> 类中的 <code>tryPayOrderByBalance</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderDTO payOrderDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">    <span class="comment">// 2.判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.修改订单状态</span></span><br><span class="line">    <span class="comment">// tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;pay.topic&quot;</span>, <span class="string">&quot;pay.success&quot;</span>, po.getBizOrderNo());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;支付成功的消息发送失败，支付单id：&#123;&#125;， 交易单id：&#123;&#125;&quot;</span>, po.getId(), po.getBizOrderNo(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-练习"><a href="#5-练习" class="headerlink" title="5.练习"></a>5.练习</h1><h2 id="5-1-抽取共享的-MQ-配置"><a href="#5-1-抽取共享的-MQ-配置" class="headerlink" title="5.1.抽取共享的 MQ 配置"></a>5.1.抽取共享的 MQ 配置</h2><p>将 MQ 配置抽取到 Nacos 中管理，微服务中直接使用共享配置。</p><h2 id="5-2-改造下单功能"><a href="#5-2-改造下单功能" class="headerlink" title="5.2.改造下单功能"></a>5.2.改造下单功能</h2><p>改造下单功能，将基于 OpenFeign 的清理购物车同步调用，改为基于 RabbitMQ 的异步通知：</p><ul><li>定义 topic 类型交换机，命名为 <code>trade.topic</code></li><li>定义消息队列，命名为 <code>cart.clear.queue</code></li><li>将 <code>cart.clear.queue</code> 与 <code>trade.topic</code> 绑定，<code>BindingKey</code> 为 <code>order.create</code></li><li>下单成功时不再调用清理购物车接口，而是发送一条消息到 <code>trade.topic</code>，发送消息的 <code>RoutingKey</code>  为 <code>order.create</code>，消息内容是下单的具体商品、当前登录用户信息</li><li>购物车服务监听 <code>cart.clear.queue</code> 队列，接收到消息后清理指定用户的购物车中的指定商品</li></ul><h2 id="5-3-登录信息传递优化"><a href="#5-3-登录信息传递优化" class="headerlink" title="5.3.登录信息传递优化"></a>5.3.登录信息传递优化</h2><p>某些业务中，需要根据登录用户信息处理业务，而基于 MQ 的异步调用并不会传递登录用户信息。前面我们的做法比较麻烦，至少要做两件事：</p><ul><li>消息发送者在消息体中传递登录用户</li><li>消费者获取消息体中的登录用户，处理业务</li></ul><p>这样做不仅麻烦，而且编程体验也不统一，毕竟我们之前都是使用 UserContext 来获取用户。</p><p>大家思考一下：有没有更优雅的办法传输登录用户信息，让使用 MQ 的人无感知，依然采用 UserContext 来随时获取用户。</p><p>参考资料：</p><h2 id="5-4-改造项目一"><a href="#5-4-改造项目一" class="headerlink" title="5.4.改造项目一"></a>5.4.改造项目一</h2><p>思考一下，项目一中的哪些业务可以由同步方式改为异步方式调用？试着改造一下。</p><p>举例：短信发送</p>]]></content>
    
    
    <summary type="html">MQ学习</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="MQ" scheme="https://threewood1.top/tags/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://threewood1.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>什么是云原生？</title>
    <link href="https://threewood1.top/post/cf8abfb1.html"/>
    <id>https://threewood1.top/post/cf8abfb1.html</id>
    <published>2024-01-12T03:35:24.000Z</published>
    <updated>2024-01-12T08:23:59.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是云原生？"><a href="#什么是云原生？" class="headerlink" title="什么是云原生？"></a>什么是云原生？</h1><p>伴随云计算的滚滚浪潮，云原生(CloudNative)的概念应运而生，云原生很火，火得一塌糊涂，如今如果你还不懂云原生，那真的out了。</p><p>大家言必称云原生，却鲜少有人告诉你<strong>到底什么是云原生</strong>，若是找资料来看，读完大多会感觉云绕雾罩，一知半解，总之虚得很；甚至会让你一度怀疑自己的智商，不过我对于读不懂的文章，一律归因于写文章的人太蠢，当然这不一定是事实，但这样的思考方式能让我避免陷入自我怀疑的负面情绪。</p><p><img src="/post/cf8abfb1/img1.png"></p><p><strong>云原生之所以解释不清楚，是因为云原生没有确切的定义</strong>，云原生一直在发展变化之中，解释权不归某个人或组织所有。</p><h2 id="何谓云原生？"><a href="#何谓云原生？" class="headerlink" title="何谓云原生？"></a>何谓云原生？</h2><p><strong>技术的变革，一定是思想先行，</strong>云原生是一种<strong>构建和运行应用程序的方法</strong>，是一套技术体系和方法论。云原生（CloudNative）是一个组合词，Cloud+Native。Cloud表示应用程序位于云中，而不是传统的数据中心；Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，<strong>在云上以最佳姿势运行</strong>，充分利用和发挥云平台的弹性+分布式优势。</p><p>Pivotal公司的Matt Stine于2013年首次提出云原生（CloudNative）的概念；2015年，云原生刚推广时，Matt Stine在《迁移到云原生架构》一书中定义了符合云原生架构的几个特征：12因素、微服务、自敏捷架构、基于API协作、扛脆弱性；到了2017年，Matt Stine在接受InfoQ采访时又改了口风，将云原生架构归纳为模块化、可观察、可部署、可测试、可替换、可处理6特质；而Pivotal最新官网对云原生概括为4个要点：<strong>DevOps+持续交付+微服务+容器</strong>。</p><p>2015年云原生计算基金会（CNCF）成立，CNCF掺和进来后，最初把云原生定义为包括：容器化封装+自动化管理+面向微服务；到了2018年，CNCF又更新了云原生的定义，把服务网格(Service Mesh)和声明式API给加了进来。</p><p><img src="/post/cf8abfb1/img2.png"></p><p>可见，不同的人和组织对云原生有不同的定义，相同的人和组织在不同时间点对云原生也有不同的定义，真是乱的一匹，搞得鄙人非常晕菜，我的应对很简单，选一个我最容易记住和理解的定义：DevOps+持续交付+微服务+容器。</p><p><strong>总而言之，符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。</strong></p><p>云原生构建应用简便快捷，部署应用轻松自如、运行应用按需伸缩。优点不一而足，缺点微乎其微；秒杀传统Web框架，吊打祖传IT模式，实在是保命**、评优晋级不可多得的终极绝密武器。</p><h2 id="云元素的四要素"><a href="#云元素的四要素" class="headerlink" title="云元素的四要素"></a>云元素的四要素</h2><p><strong>微服务</strong>：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是<a href="https://zhuanlan.zhihu.com/p/104614255">康威定律</a>，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。</p><p>微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据<a href="https://zhuanlan.zhihu.com/p/109114670">DDD</a>来搞。</p><p><strong>容器化</strong>：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，<a href="https://zhuanlan.zhihu.com/p/53260098">Docker和K8S</a>都采用Go编写，都是好东西。为什么采用Go语言，原因<a href="https://zhuanlan.zhihu.com/p/601963000">在这</a>。</p><p><a href="https://zhuanlan.zhihu.com/p/91371659">DevOps</a>：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。</p><p><strong>持续交付</strong>：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。</p><p><img src="/post/cf8abfb1/img3.png"></p><h2 id="如何云原生？"><a href="#如何云原生？" class="headerlink" title="如何云原生？"></a>如何云原生？</h2><p>首先，云原生借了<a href="https://www.ibm.com/cn-zh/topics/cloud-computing">云计算</a>的东风，没有云计算，自然没有云原生，云计算是云原生的基础。</p><p>随着虚拟化技术的成熟和分布式框架的普及，在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，<strong>应用上云已经是不可逆转的趋势</strong>。</p><p>云计算的3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)为云原生提供了技术基础和方向指引，<strong>真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变</strong>，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。</p><ol><li><p>本地部署的传统应用往往采用c&#x2F;c++、企业级java编写，而云原生应用则需要用以网络为中心的go、node.js等新兴语言编写。</p></li><li><p>本地部署的传统应用可能需要停机更新，而云原生应用应该始终是最新的，需要支持频繁变更，持续交付，蓝绿部署。</p></li><li><p>本地部署的传统应用无法动态扩展，往往需要冗余资源以抵抗流量高峰，而云原生应用利用云的弹性自动伸缩，通过共享降本增效。</p></li><li><p>本地部署的传统应用对网络资源，比如ip、端口等有依赖，甚至是硬编码，而云原生应用对网络和存储都没有这种限制。</p></li><li><p>本地部署的传统应用通常人肉部署手工运维，而云原生应用这一切都是自动化的。</p></li><li><p>本地部署的传统应用通常依赖系统环境，而云原生应用不会硬连接到任何系统环境，而是依赖抽象的基础架构，从而获得良好移植性。</p></li><li><p>本地部署的传统应用有些是单体(巨石)应用，或者强依赖，而基于微服务架构的云原生应用，纵向划分服务，模块化更合理。</p></li></ol><p>可见，要转向云原生应用需要以新的云原生方法开展工作，云原生包括很多方面：基础架构服务、虚拟化、容器化、容器编排、微服务。幸运的是，开源社区在云原生应用方面做出了大量卓有成效的工作，很多开源的框架和设施可以通过拿来主义直接用，2013年Docker推出并很快成为容器事实标准，随后围绕容器编排的混战中，2017年诞生的k8s很快脱颖而出，而这些技术极大的降低了开发云原生应用的技术门槛。</p><p><img src="/post/cf8abfb1/img4.png"></p><p>虽说云原生的推介文档有引导之嫌，但面对它列举的优点，作为杠精的我亦是无可辩驳。这么说的话，云原生也忒好了吧，应用是不是要立刻马上切换到云原生架构？我的观点是：理想很丰满，现实经常很骨感，需从应用的实际需要出发，目前的问题是否真的影响到业务发展，而推倒重来的代价能否承受得来。</p><h2 id="技术的趋势和影响"><a href="#技术的趋势和影响" class="headerlink" title="技术的趋势和影响"></a>技术的趋势和影响</h2><p>软件设计有两个关键目标：<strong>高内聚、低耦合</strong>，围绕这2个核心目标，又提出了单一职责、开闭原则、里氏替换、依赖导致、接口隔离、最少知识等设计原则。</p><p>软件工程师一直都在为这两个目标而努力奋斗，以求把软件编写得更加清晰、更加健壮、更加易于扩展和维护。</p><p>但后来，人们发现有更多的诉求，希望开发软件变得更简单、更快捷，程序员希望更少编写代码，非专业人员也希望能开发程序，于是，更多的更傻瓜的编程语言被发明出来，更多的编程技术和编程思想被发明出来，比如库、组件、云基础设施。</p><p>于是很多技术变成了屠龙之技，比如汇编，时代变了，建国后动物不能成精了，没有龙可以宰了，然后很多软件工程师摇身一变成了调参工程师、Call API砖家、用库包能手、拼组件达人，这是效率分工的结果，也是技术发展的使然。</p><p>纵观近二十年的科技互联网发展历程，<strong>大的趋势是技术下沉</strong>，特别是近些年，随着云计算的发展和普及，基础设施越来越厚实，业务开发变得越来越容易，也越来越没有技术含量，而之前困扰小团队的性能、负载、安全性、扩展性问题都不复存在，这不禁让互联网行业的油腻大叔们噤若寒蝉，仿佛分分钟就要被卷入历史洪流而万劫不复。</p><p>虽然不可否认技术的重要性在降低，但也还不至于那么悲观。遥想PC时代，当VB、Delphi、MFC出现的时候，也有类似论调，所见即所得，点点鼠标，就可以开发PC桌面程序，是不是很高端？那时候码农的担心相比现在恐怕是只多不少吧，但后来随着互联网兴起，出现了后端开发这个工种，码农很快找到了新的战场，网络、分布式、数据库、海量服务、容灾防错，于是又玩出一堆新花样。</p><p>如果说PC时代的基础设施是控件库，互联网时代的基础实施是云，那AI时代基础设施是什么？又会有什么高端玩法？</p><p>其他关于云原生的解释：</p><p><a href="https://www.ibm.com/cn-zh/topics/cloud-native">云原生 | IBM</a></p><p><a href="https://learn.microsoft.com/zh-cn/dotnet/architecture/cloud-native/definition">什么是云原生？ - .NET | Microsoft Learn</a></p><p><a href="https://www.cnblogs.com/IT-Evan/p/14733233.html">我们为什么需要云原生 - 朱志勇 - 博客园 (cnblogs.com)</a></p><p>转载：</p><p><a href="https://zhuanlan.zhihu.com/p/150190166#%E5%A6%82%E4%BD%95%E4%BA%91%E5%8E%9F%E7%94%9F%EF%BC%9F">什么是云原生？这回终于有人讲明白了 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/437292677">云原生到底是什么？ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">什么是云原生？</summary>
    
    
    
    <category term="Knowledge" scheme="https://threewood1.top/categories/Knowledge/"/>
    
    
    <category term="CloudNative" scheme="https://threewood1.top/tags/CloudNative/"/>
    
    <category term="DevOps" scheme="https://threewood1.top/tags/DevOps/"/>
    
    <category term="Containers" scheme="https://threewood1.top/tags/Containers/"/>
    
    <category term="Microservice" scheme="https://threewood1.top/tags/Microservice/"/>
    
    <category term="CI/CD" scheme="https://threewood1.top/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>微服务学习3——服务保护和分布式事务</title>
    <link href="https://threewood1.top/post/d28e0038.html"/>
    <id>https://threewood1.top/post/d28e0038.html</id>
    <published>2024-01-10T07:40:28.000Z</published>
    <updated>2024-01-10T07:45:33.639Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有<strong>级联****失败</strong>问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多 Tomcat 连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的 Tomcat 连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p><p>这就是<strong>级联****失败</strong>问题，或者叫<strong>雪崩</strong>问题。</p><p>还有跨服务的事务问题：</p><p>比如昨天讲到过的下单业务，下单的过程中需要调用多个微服务：</p><ul><li>商品服务：扣减库存</li><li>订单服务：保存订单</li><li>购物车服务：清理购物车</li></ul><p>这些业务全部都是数据库的写操作，我们必须确保所有操作的同时成功或失败。但是这些操作在不同微服务，也就是不同的 Tomcat，这样的情况如何确保事务特性呢？</p><p>这些问题都会在今天找到答案。</p><p>今天的内容会分成几部分：</p><ul><li><p>微服务保护</p><ul><li>服务保护方案</li><li>请求限流</li><li>隔离和熔断</li></ul></li><li><p>分布式事务</p><ul><li>初识分布式事务</li><li>Seata</li></ul></li></ul><p>通过今天的学习，你将能掌握下面的能力：</p><ul><li>知道雪崩问题产生原因及常见解决方案</li><li>能使用 Sentinel 实现服务保护</li><li>理解分布式事务产生的原因</li><li>能使用 Seata 解决分布式事务问题</li><li>理解 AT 模式基本原理</li></ul><h1 id="1-微服务保护"><a href="#1-微服务保护" class="headerlink" title="1.微服务保护"></a>1.微服务保护</h1><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护。这章我们就一起来学习一下微服务保护的常见方案以及对应的技术。</p><h2 id="1-1-服务保护方案"><a href="#1-1-服务保护方案" class="headerlink" title="1.1.服务保护方案"></a>1.1.服务保护方案</h2><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p><p>接下来，我们就逐一了解这些方案的原理。</p><h3 id="1-1-1-请求限流"><a href="#1-1-1-请求限流" class="headerlink" title="1.1.1.请求限流"></a>1.1.1.请求限流</h3><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p><p><img src="/post/d28e0038/Fju2bguocoP9RUxvWIgcop3Nn0g.jpeg"></p><h3 id="1-1-2-线程隔离"><a href="#1-1-2-线程隔离" class="headerlink" title="1.1.2.线程隔离"></a>1.1.2.线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p><p>线程隔离的思想来自轮船的舱壁模式：</p><p><img src="/post/d28e0038/SfqWbK94YoClRRxwwL0cHd9lnCb.png"></p><p>轮船的船舱会被隔板分割为 N 个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没。</p><p>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p><p>如图所示，我们给查询购物车业务限定可用线程数量上限为 20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。</p><h3 id="1-1-3-服务熔断"><a href="#1-1-3-服务熔断" class="headerlink" title="1.1.3.服务熔断"></a>1.1.3.服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。</p><p>所以，我们要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><h2 id="1-2-Sentinel"><a href="#1-2-Sentinel" class="headerlink" title="1.2.Sentinel"></a>1.2.Sentinel</h2><p>微服务保护的技术有很多，但在目前国内使用较多的还是 Sentinel，所以接下来我们学习 Sentinel 的使用。</p><h3 id="1-2-1-介绍和安装"><a href="#1-2-1-介绍和安装" class="headerlink" title="1.2.1.介绍和安装"></a>1.2.1.介绍和安装</h3><p>Sentinel 是阿里巴巴开源的一款服务保护框架，目前已经加入 SpringCloudAlibaba 中。官方网站：</p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar 包）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，我们先把 Sentinel 的控制台搭建出来。</p><p>1）下载 jar 包</p><p>下载地址：</p><p>也可以直接使用课前资料提供的版本：</p><p><img src="/post/d28e0038/R8A7bYgFUo1vZLxpN76cDMySnbM.png"></p><p>2）运行</p><p>将 jar 包放在任意非中文、不包含特殊字符的目录下，重命名为 <code>sentinel-dashboard.jar</code>：</p><p><img src="/post/d28e0038/OZsvb8liYoVxKfxozMGcHd9HnRx.png"></p><p>然后运行如下命令启动控制台：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><p>其它启动时可配置参数可参考官方文档：</p><p>3）访问</p><p>访问 <a href="http://localhost:8080/">http://localhost:8090</a> 页面，就可以看到 sentinel 的控制台了：</p><p><img src="/post/d28e0038/H299bUI0IoJEXvxgrGUczLq0nud.png"></p><p>需要输入账号和密码，默认都是：sentinel</p><p>登录后，即可看到控制台，默认会监控 sentinel-dashboard 服务本身：</p><p><img src="/post/d28e0038/BFxbbNjNfo1mdvxNtRycqkb6nPh.png"></p><h3 id="1-2-2-微服务整合"><a href="#1-2-2-微服务整合" class="headerlink" title="1.2.2.微服务整合"></a>1.2.2.微服务整合</h3><p>我们在 <code>cart-service</code> 模块中整合 sentinel，连接 <code>sentinel-dashboard</code> 控制台，步骤如下：<br>1）引入 sentinel 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改 application.yaml 文件，添加下面内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure><p>3）访问 <code>cart-service</code> 的任意端点</p><p>重启 <code>cart-service</code>，然后访问查询购物车接口，sentinel 的客户端就会将服务访问的信息提交到 <code>sentinel-dashboard</code> 控制台。并展示出统计信息：</p><p><img src="/post/d28e0038/RS2ubTdQJoaUFyx0jpIcE8X4nKd.png"></p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="/post/d28e0038/IqR0bZ4AJot5csxyRpEc7FXqnud.png"></p><p>所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被 <code>Sentinel</code> 监控的资源。默认情况下，<code>Sentinel</code> 会监控 <code>SpringMVC</code> 的每一个 <code>Endpoint</code>（接口）。</p><p>因此，我们看到 <code>/carts</code> 这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>不过，需要注意的是，我们的 SpringMVC 接口是按照 Restful 风格设计，因此购物车的查询、删除、修改等接口全部都是 <code>/carts</code> 路径：</p><p><img src="/post/d28e0038/UE3FbWj6woljUvxAnaNcXffRnkd.png"></p><p>默认情况下 Sentinel 会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以我们可以选择打开 Sentinel 的请求方式前缀，把 <code>请求方式 + 请求路径</code> 作为簇点资源名：</p><p>首先，在 <code>cart-service</code> 的 <code>application.yml</code> 中添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><p>然后，重启服务，通过页面访问购物车的相关接口，可以看到 sentinel 控制台的簇点链路发生了变化：</p><p><img src="/post/d28e0038/YpfebGUY8o6GCzxLbiAc9I05nAd.png"></p><h2 id="1-3-请求限流"><a href="#1-3-请求限流" class="headerlink" title="1.3.请求限流"></a>1.3.请求限流</h2><p>在簇点链路后面点击流控按钮，即可对其做限流配置：</p><p><img src="/post/d28e0038/IASvbbvI8o63RNxvKOCcAiB8nlg.png"></p><p>在弹出的菜单中这样填写：</p><p><img src="/post/d28e0038/VOUbbqOluonavqx3WkScy4DbnUb.png"></p><p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒 6 个，也就是最大 QPS 为 6.</p><p>我们利用 Jemeter 做限流测试，我们每秒发出 10 个请求：</p><p><img src="/post/d28e0038/WxkAb1PsRo1fq5xy8VncoZe2n7e.png"></p><p>最终监控结果如下：</p><p><img src="/post/d28e0038/Ybj0bIzDEo3Mm5xF4xYclWh5nNc.png"></p><p>可以看出 <code>GET:/carts</code> 这个接口的通过 QPS 稳定在 6 附近，而拒绝的 QPS 在 4 附近，符合我们的预期。</p><h2 id="1-4-线程隔离"><a href="#1-4-线程隔离" class="headerlink" title="1.4.线程隔离"></a>1.4.线程隔离</h2><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源：</p><p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。</p><p>所以，我们要对查询商品的 FeignClient 接口做线程隔离。</p><h3 id="1-4-1-OpenFeign-整合-Sentinel"><a href="#1-4-1-OpenFeign-整合-Sentinel" class="headerlink" title="1.4.1.OpenFeign 整合 Sentinel"></a>1.4.1.OpenFeign 整合 Sentinel</h3><p>修改 cart-service 模块的 application.yml 文件，开启 Feign 的 sentinel 功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>然后重启 cart-service 服务，可以看到查询商品的 FeignClient 自动变成了一个簇点资源：</p><p><img src="/post/d28e0038/PUsTbAT2vojLUYxB3rIc6Vj5nEh.png"></p><h3 id="1-4-2-配置线程隔离"><a href="#1-4-2-配置线程隔离" class="headerlink" title="1.4.2.配置线程隔离"></a>1.4.2.配置线程隔离</h3><p>接下来，点击查询商品的 FeignClient 对应的簇点资源后面的流控按钮：</p><p><img src="/post/d28e0038/C26gbIeS3om5V2xunJfcDDf1nqf.png"></p><p>在弹出的表单中填写下面内容：</p><p><img src="/post/d28e0038/KaFqbCvR0ooCW0xkDmwcVDEvnIe.png"></p><p>注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用 5 个线程，而不是 5QPS。如果查询商品的接口每秒处理 2 个请求，则 5 个线程的实际 QPS 在 10 左右，而超出的请求自然会被拒绝。</p><p><img src="/post/d28e0038/QQCwb4BfHoUjsHxiCPqcntxAnNc.png"></p><p>我们利用 Jemeter 测试，每秒发送 100 个请求：</p><p><img src="/post/d28e0038/KNUubRrh7omI3RxfckockKDkniu.png"></p><p>最终测试结果如下：</p><p><img src="/post/d28e0038/EWBCbrkywoJkmVxr0zoc4Dlbnfh.png"></p><p>进入查询购物车的请求每秒大概在 100，而在查询商品时却只剩下每秒 10 左右，符合我们的预期。</p><p>此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现不受影响：</p><p><img src="/post/d28e0038/QVePbxBIqoKt4IxnxHdchklPnbb.png"></p><p>响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响到其它接口。</p><h2 id="1-5-服务熔断"><a href="#1-5-服务熔断" class="headerlink" title="1.5.服务熔断"></a>1.5.服务熔断</h2><p>在上节课，我们利用线程隔离对查询购物车业务进行隔离，保护了购物车服务的其它接口。由于查询商品的功能耗时较高（我们模拟了 500 毫秒延时），再加上线程隔离限定了线程数为 5，导致接口吞吐能力有限，最终 QPS 只有 10 左右。这就导致了几个问题：</p><p>第一，超出的 QPS 上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个<strong>降级处理</strong>逻辑。</p><p>第二，由于查询商品的延迟较高（模拟的 500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</p><h3 id="1-5-1-编写降级逻辑"><a href="#1-5-1-编写降级逻辑" class="headerlink" title="1.5.1.编写降级逻辑"></a>1.5.1.编写降级逻辑</h3><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给 FeignClient 编写失败后的降级逻辑有两种方式：</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>这里我们演示方式二的失败降级处理。</p><p><strong>步骤一</strong>：在 hm-api 模块中给 <code>ItemClient</code> 定义降级处理类，实现 <code>FallbackFactory</code>：</p><p><img src="/post/d28e0038/QQEfbpcsdoNdpix59dTcHF1Xnyg.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.ItemClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.ItemDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.OrderDetailDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BizIllegalException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="comment">// 查询购物车允许失败，查询失败，返回空集合</span></span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二</strong>：在 <code>hm-api</code> 模块中的 <code>com.hmall.api.config.DefaultFeignConfig</code> 类中将 <code>ItemClientFallback</code> 注册为一个 <code>Bean</code>：</p><p><img src="/post/d28e0038/YQeWbkS4VoDh8bxlZtzcXLfbnOb.png"></p><p><strong>步骤三</strong>：在 <code>hm-api</code> 模块中的 <code>ItemClient</code> 接口中使用 <code>ItemClientFallbackFactory</code>：</p><p><img src="/post/d28e0038/YYjebcfKmo9agaxTJyScONdLn1g.png"></p><p>重启后，再次测试，发现被限流的请求不再报错，走了降级逻辑：</p><p><img src="/post/d28e0038/BPjvbFaVJoA6DMx8LMecQ0BPnud.png"></p><p>但是未被限流的请求延时依然很高：</p><p><img src="/post/d28e0038/CkxybjbVAoNJRWxdXHqc7Pi0ned.png"></p><p>导致最终的平局响应时间较长。</p><h3 id="1-5-2-服务熔断"><a href="#1-5-2-服务熔断" class="headerlink" title="1.5.2.服务熔断"></a>1.5.2.服务熔断</h3><p>查询商品的 RT 较高（模拟的 500ms），从而导致查询购物车的 RT 也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。</p><p>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。当商品服务接口恢复正常后，再允许调用。这其实就是<strong>断路器</strong>的工作模式了。</p><p>Sentinel 中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p>状态机包括三个状态：</p><ul><li><p><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到 open 状态</p></li><li><p><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open 状态持续一段时间后会进入 half-open 状态</p></li><li><p><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。</p><ul><li>请求成功：则切换到 closed 状态</li><li>请求失败：则切换到 open 状态</li></ul></li></ul><p>我们可以在控制台通过点击簇点后的<strong>熔断</strong>按钮来配置熔断策略：</p><p><img src="/post/d28e0038/PW9IbaoktogZlCx8ophcG4V7nCk.png"></p><p>在弹出的表格中这样填写：</p><p><img src="/post/d28e0038/JVSmbTIoHobYthxf7c9cptMonMd.png"></p><p>这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT 超过 200 毫秒的请求调用就是慢调用</li><li>统计最近 1000ms 内的最少 5 次请求，如果慢调用比例不低于 0.5，则触发熔断</li><li>熔断持续时长 20s</li></ul><p>配置完成后，再次利用 Jemeter 测试，可以发现：</p><p><img src="/post/d28e0038/SwA5b2SuEoIPFNx7w8gcVn8knNG.png"></p><p>在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过 QPS 直接为 0，所有请求都被熔断了。而查询购物车的本身并没有受到影响。</p><p>此时整个购物车查询服务的平均 RT 影响不大：</p><p><img src="/post/d28e0038/AuAPbxmcJozpHOxS61Ec3h88nLe.png"></p><h1 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2.分布式事务"></a>2.分布式事务</h1><p>首先我们看看项目中的下单业务整体流程：</p><p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</p><ul><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务</li></ul><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足 ACID 特性，但全局事务跨越多个服务、多个数据库，是否还能满足呢？</p><p>我们来做一个测试，先进入购物车页面：</p><p><img src="/post/d28e0038/VP0sbKlvwoi7kwxheJJcMnW1nYc.png"></p><p>目前有 4 个购物车，然结算下单，进入订单结算页面：</p><p><img src="/post/d28e0038/AjOlb3UNXoFJJDxMa9scqEAsnqf.png"></p><p>然后将购物车中某个商品的库存修改为 <code>0</code>：</p><p><img src="/post/d28e0038/ZJpFb31C9oJ7PFxDd4KcrBTlnnc.png"></p><p>然后，提交订单，最终因库存不足导致下单失败：</p><p><img src="/post/d28e0038/BpakbAf7eoMyv6xcgO4ciNIonTf.png"></p><p>然后我们去查看购物车列表，发现购物车数据依然被清空了，并未回滚：</p><p><img src="/post/d28e0038/SAg4bx12boM0tUxoMEhcMaNfnQg.png"></p><p>事务并未遵循 ACID 的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循 ACID，但是它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循 ACID 的事务特性了。</p><p>这就是分布式事务问题，出现以下情况之一就可能产生分布式事务问题：</p><ul><li>业务跨多个服务实现</li><li>业务跨多个数据源实现</li></ul><p>接下来这一章我们就一起来研究下如何解决分布式事务问题。</p><h2 id="2-1-认识-Seata"><a href="#2-1-认识-Seata" class="headerlink" title="2.1.认识 Seata"></a>2.1.认识 Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在 2019 年开源的 Seata 了。</p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p><p>就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。</p><p>Seata 也不例外，在 Seata 的事务管理中有三个重要的角色：</p><ul><li><strong>TC</strong>** (<strong><strong>Transaction Coordinator</strong></strong>) -** <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>Seata 的工作架构如图所示：</p><p><img src="/post/d28e0038/R528bEOPxoWwoUxOiF3c5T1Fnwf.png"></p><p>其中，<strong>TM</strong> 和 <strong>RM</strong> 可以理解为 Seata 的客户端部分，引入到参与事务的微服务依赖中即可。将来 <strong>TM</strong> 和 <strong>RM</strong> 就会协助微服务，实现本地分支事务与 <strong>TC</strong> 之间交互，实现事务的提交或回滚。</p><p>而 <strong>TC</strong> 服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h2 id="2-2-部署-TC-服务"><a href="#2-2-部署-TC-服务" class="headerlink" title="2.2.部署 TC 服务"></a>2.2.部署 TC 服务</h2><h3 id="2-2-1-准备数据库表"><a href="#2-2-1-准备数据库表" class="headerlink" title="2.2.1.准备数据库表"></a>2.2.1.准备数据库表</h3><p>Seata 支持多种存储模式，但考虑到持久化的需要，我们一般选择基于数据库存储。执行课前资料提供的 <code>《seata-tc.sql》</code>，导入数据库表：</p><p><img src="/post/d28e0038/C7A9bYOYLokgdBxWsZxcH888n8f.png"></p><h3 id="2-2-2-准备配置文件"><a href="#2-2-2-准备配置文件" class="headerlink" title="2.2.2.准备配置文件"></a>2.2.2.准备配置文件</h3><p>课前资料准备了一个 seata 目录，其中包含了 seata 运行时所需要的配置文件：</p><p><img src="/post/d28e0038/AnzlbwFaFo0AtRxOT0hctMN8nab.png"></p><p>其中包含中文注释，大家可以自行阅读。</p><p>我们将整个 seata 文件夹拷贝到虚拟机的 <code>/root</code> 目录：</p><p><img src="/post/d28e0038/WryWbRfqnoK3T2xnUytcn4bCnuc.png"></p><h3 id="2-2-3-Docker-部署"><a href="#2-2-3-Docker-部署" class="headerlink" title="2.2.3.Docker 部署"></a>2.2.3.Docker 部署</h3><p>在虚拟机的 <code>/root</code> 目录执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --name seata \</span><br><span class="line">-p 8099:8099 \</span><br><span class="line">-p 7099:7099 \</span><br><span class="line">-e SEATA_IP=192.168.150.101 \</span><br><span class="line">-v ./seata:/seata-server/resources \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network hmall \</span><br><span class="line">-d \</span><br><span class="line">seataio/seata-server:1.5.2</span><br></pre></td></tr></table></figure><p>如果镜像下载困难，也可以把课前资料提供的镜像上传到虚拟机并加载：</p><p><img src="/post/d28e0038/Eizyb0YqGoBTT5xUDRmcfJdhnoc.png"></p><h2 id="2-3-微服务集成-Seata"><a href="#2-3-微服务集成-Seata" class="headerlink" title="2.3.微服务集成 Seata"></a>2.3.微服务集成 Seata</h2><p>参与分布式事务的每一个微服务都需要集成 Seata，我们以 <code>trade-service</code> 为例。</p><h3 id="2-3-1-引入依赖"><a href="#2-3-1-引入依赖" class="headerlink" title="2.3.1.引入依赖"></a>2.3.1.引入依赖</h3><p>为了方便各个微服务集成 seata，我们需要把 seata 配置共享到 nacos，因此 <code>trade-service</code> 模块不仅仅要引入 seata 依赖，还要引入 nacos 依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-改造配置"><a href="#2-3-2-改造配置" class="headerlink" title="2.3.2.改造配置"></a>2.3.2.改造配置</h3><p>首先在 nacos 上添加一个共享的 seata 配置，命名为 <code>shared-seata.yaml</code>：</p><p><img src="/post/d28e0038/Em4YbB2utok1cjxi5AvcoyNZnch.png"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><p>然后，改造 <code>trade-service</code> 模块，添加 <code>bootstrap.yaml</code>：</p><p><img src="/post/d28e0038/PzbVbzEIyoQ6lixGL25cWlU7nAf.png"></p><p>内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-seata.yaml</span> <span class="comment"># 共享seata配置</span></span><br></pre></td></tr></table></figure><p>可以看到这里加载了共享的 seata 配置。</p><p>然后改造 application.yaml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign对Sentinel的整合</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">交易服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.trade.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-trade</span></span><br></pre></td></tr></table></figure><p>参考上述办法分别改造 <code>hm-cart</code> 和 <code>hm-item</code> 两个微服务模块。</p><h3 id="2-3-3-添加数据库表"><a href="#2-3-3-添加数据库表" class="headerlink" title="2.3.3.添加数据库表"></a>2.3.3.添加数据库表</h3><p>seata 的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。</p><p>将课前资料的 seata-at.sql 分别文件导入 hm-trade、hm-cart、hm-item 三个数据库中：</p><p><img src="/post/d28e0038/NtFbbbIh3oM0FDxWRWacS7T7n7e.png"></p><p>结果：</p><p><img src="/post/d28e0038/ByaHbdbazoT4p1x4HZlcxkrcnWb.png"></p><p>OK，至此为止，微服务整合的工作就完成了。可以参考上述方式对 <code>hm-item</code> 和 <code>hm-cart</code> 模块完成整合改造。</p><h3 id="2-3-4-测试"><a href="#2-3-4-测试" class="headerlink" title="2.3.4.测试"></a>2.3.4.测试</h3><p>接下来就是测试的分布式事务的时候了。</p><p>我们找到 <code>trade-service</code> 模块下的 <code>com.hmall.trade.service.impl.OrderServiceImpl</code> 类中的 <code>createOrder</code> 方法，也就是下单业务方法。</p><p>将其上的 <code>@Transactional</code> 注解改为 Seata 提供的 <code>@GlobalTransactional</code>：</p><p><img src="/post/d28e0038/FvwqbpJPSojMu0xH932c0tOanCg.png"></p><p><code>@GlobalTransactional</code> 注解就是在标记事务的起点，将来 TM 就会基于这个方法判断全局事务范围，初始化全局事务。</p><p>我们重启 <code>trade-service</code>、<code>item-service</code>、<code>cart-service</code> 三个服务。再次测试，发现分布式事务的问题解决了！</p><p>那么，Seata 是如何解决分布式事务的呢？</p><h2 id="2-4-XA-模式"><a href="#2-4-XA-模式" class="headerlink" title="2.4.XA 模式"></a>2.4.XA 模式</h2><p>Seata 支持四种不同的分布式事务解决方案：</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p>这里我们以 <code>XA</code> 模式和 <code>AT</code> 模式来给大家讲解其实现原理。</p><p><code>XA</code> 规范 是 <code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的 <code>TM</code> 与局部的 <code>RM</code> 之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><h3 id="2-4-1-两阶段提交"><a href="#2-4-1-两阶段提交" class="headerlink" title="2.4.1.两阶段提交"></a>2.4.1.两阶段提交</h3><p>A 是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p><p>正常情况：</p><p><img src="/post/d28e0038/FFaJbY9ProUuvcxsCKwc0xzMnz8.png"></p><p>异常情况：</p><p><img src="/post/d28e0038/GDXpbJKpVoy3Dex0gNLceYGCnif.png"></p><p>一阶段：</p><ul><li>事务协调者通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><h3 id="2-4-2-Seata-的-XA-模型"><a href="#2-4-2-Seata-的-XA-模型" class="headerlink" title="2.4.2.Seata 的 XA 模型"></a>2.4.2.Seata 的 XA 模型</h3><p>Seata 对原始的 XA 模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="/post/d28e0038/VaBzb7rs0on2CcxWrOVcM6XYn3g.png"></p><p><code>RM</code> 一阶段的工作：</p><ol><li>注册分支事务到 <code>TC</code></li><li>执行分支业务 sql 但不提交</li><li>报告执行状态到 <code>TC</code></li></ol><p><code>TC</code> 二阶段的工作：</p><ol><li><code>TC</code> 检测各分支事务执行状态<ol><li>如果都成功，通知所有 RM 提交事务</li><li>如果有失败，通知所有 RM 回滚事务</li></ol></li></ol><p><code>RM</code> 二阶段的工作：</p><ul><li>接收 <code>TC</code> 指令，提交或回滚事务</li></ul><h3 id="2-4-3-优缺点"><a href="#2-4-3-优缺点" class="headerlink" title="2.4.3.优缺点"></a>2.4.3.优缺点</h3><p><code>XA</code> 模式的优点是什么？</p><ul><li>事务的强一致性，满足 ACID 原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code> 模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h2 id="2-5-AT-模式"><a href="#2-5-AT-模式" class="headerlink" title="2.5.AT 模式"></a>2.5.AT 模式</h2><p><code>AT</code> 模式同样是分阶段提交的事务模型，不过缺弥补了 <code>XA</code> 模型中资源锁定周期过长的缺陷。</p><h3 id="2-5-1-Seata-的-AT-模型"><a href="#2-5-1-Seata-的-AT-模型" class="headerlink" title="2.5.1.Seata 的 AT 模型"></a>2.5.1.Seata 的 AT 模型</h3><p>基本流程图：</p><p><img src="/post/d28e0038/CXQqbuICvoB6aZx1AR3cdKKOnNb.png"></p><p>阶段一 <code>RM</code> 的工作：</p><ul><li>注册分支事务</li><li>记录 undo-log（数据快照）</li><li>执行业务 sql 并提交</li><li>报告事务状态</li></ul><p>阶段二提交时 <code>RM</code> 的工作：</p><ul><li>删除 undo-log 即可</li></ul><p>阶段二回滚时 <code>RM</code> 的工作：</p><ul><li>根据 undo-log 恢复数据到更新前</li></ul><h3 id="2-5-2-流程梳理"><a href="#2-5-2-流程梳理" class="headerlink" title="2.5.2.流程梳理"></a>2.5.2.流程梳理</h3><p>我们用一个真实的业务来梳理下 AT 模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr><th>###### <strong>id</strong></th><th>###### <strong>money</strong></th></tr></thead><tbody><tr><td>1</td><td>100</td></tr></tbody></table><p>其中一个分支业务要执行的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>AT 模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol><li><code>TM</code> 发起并注册全局事务到 <code>TC</code></li><li><code>TM</code> 调用分支事务</li><li>分支事务准备执行业务 SQL</li><li><code>RM</code> 拦截业务 SQL，根据 where 条件查询原始数据，形成快照。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><code>RM</code> 执行业务 SQL，提交本地事务，释放数据库锁。此时 money &#x3D; 90</li><li><code>RM</code> 报告本地事务状态给 <code>TC</code></li></ol><p><strong>二阶段</strong>：</p><ol><li><p><code>TM</code> 通知 <code>TC</code> 事务结束</p></li><li><p><code>TC</code> 检查分支事务状态</p><ol><li>如果都成功，则立即删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为 100</li></ol></li></ol><p>流程图：</p><p><img src="/post/d28e0038/Ivnhbq1MwohRbvxwJFTcsZoBnFg.png"></p><h3 id="2-5-3-AT-与-XA-的区别"><a href="#2-5-3-AT-与-XA-的区别" class="headerlink" title="2.5.3.AT 与 XA 的区别"></a>2.5.3.AT 与 XA 的区别</h3><p>简述 <code>AT</code> 模式与 <code>XA</code> 模式最大的区别是什么？</p><ul><li><code>XA</code> 模式一阶段不提交事务，锁定资源；<code>AT</code> 模式一阶段直接提交，不锁定资源。</li><li><code>XA</code> 模式依赖数据库机制实现回滚；<code>AT</code> 模式利用数据快照实现数据回滚。</li><li><code>XA</code> 模式强一致；<code>AT</code> 模式最终一致</li></ul><p>可见，AT 模式使用起来更加简单，无业务侵入，性能更好。因此企业 90% 的分布式事务都可以用 AT 模式来解决。</p><h1 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h1><h2 id="3-1-编写降级逻辑"><a href="#3-1-编写降级逻辑" class="headerlink" title="3.1.编写降级逻辑"></a>3.1.编写降级逻辑</h2><p>给黑马商城中现有的 FeignClient 都编写对应的降级逻辑，并且改造项目中每一个微服务，将 OpenFeign 与 Sentinel 整合。</p><h2 id="3-2-解决分布式事务"><a href="#3-2-解决分布式事务" class="headerlink" title="3.2.解决分布式事务"></a>3.2.解决分布式事务</h2><p>除了下单业务以外，用户如果选择余额支付，前端会将请求发送到 pay-service 模块。而这个模块要做三件事情：</p><ul><li>直接从 user-service 模块调用接口，扣除余额付款</li><li>更新本地（pay-service）交易流水表状态</li><li>通知交易服务（trade-service）更新其中的业务订单状态</li></ul><p>流程如图：</p><p>显然，这里也存在分布式事务问题。</p><p>对应的页面如下：</p><p><img src="/post/d28e0038/JmDAbfxKuo4VjhxcEEHczVNFnme.png"></p><p>当我们提交订单成功后，进入支付页面，选择余额支付，输入密码后点击确认支付即可。</p><p>前端会提交支付请求，业务接口的入口在 <code>com.hmall.pay.controller.PayController</code> 类的 <code>tryPayOrderByBalance</code> 方法：</p><p><img src="/post/d28e0038/MqXcbRDVfowfLXxy9chcpoRbngf.png"></p><p>对应的 service 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderDTO payOrderDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">    <span class="comment">// 2.判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.修改订单状态</span></span><br><span class="line">    tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 seata 解决这里的分布式事务问题，并思考这个业务实现有没有什么值得改进的地方</p>]]></content>
    
    
    <summary type="html">服务保护和分布式事务笔记</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="Microservice Architecture" scheme="https://threewood1.top/tags/Microservice-Architecture/"/>
    
    <category term="SpringCloud" scheme="https://threewood1.top/tags/SpringCloud/"/>
    
    <category term="OpenFeign" scheme="https://threewood1.top/tags/OpenFeign/"/>
    
    <category term="Sentinel" scheme="https://threewood1.top/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>微服务学习2</title>
    <link href="https://threewood1.top/post/78355edd.html"/>
    <id>https://threewood1.top/post/78355edd.html</id>
    <published>2024-01-09T03:32:37.000Z</published>
    <updated>2024-01-10T07:43:18.567Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的作业中，我们将黑马商城拆分为 5 个微服务：</p><ul><li>用户服务</li><li>商品服务</li><li>购物车服务</li><li>交易服务</li><li>支付服务</li></ul><p>由于每个微服务都有不同的地址或端口，入口不同，相信大家在与前端联调的时候发现了一些问题：</p><ul><li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li><li>前端无法调用 nacos，无法实时更新服务列表</li></ul><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p><ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul><p>不要着急，这些问题都可以在今天的学习中找到答案，我们会通过<strong>网关</strong>技术解决上述问题。今天的内容会分为 3 章：</p><ul><li>第一章：网关路由，解决前端请求入口的问题。</li><li>第二章：网关鉴权，解决统一登录校验和用户信息获取的问题。</li><li>第三章：统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li></ul><p>通过今天的学习你将掌握下列能力：</p><ul><li>会利用微服务网关做请求路由</li><li>会利用微服务网关做登录身份校验</li><li>会利用 Nacos 实现统一配置管理</li><li>会利用 Nacos 实现配置热更新</li></ul><p>好了，接下来我们就一起进入今天的学习吧。</p><h1 id="1-网关路由"><a href="#1-网关路由" class="headerlink" title="1.网关路由"></a>1.网关路由</h1><h2 id="1-1-认识网关"><a href="#1-1-认识网关" class="headerlink" title="1.1.认识网关"></a>1.1.认识网关</h2><p>什么是网关？</p><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p><p>更通俗的来讲，网关就像是以前园区传达室的大爷。</p><ul><li>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。</li><li>外面的人要传话或送信，要找大爷。大爷帮你带给目标人。</li></ul><p><img src="/post/78355edd/MOmebPN8hoTCVhxN1tTcbqUhngh.jpeg"></p><p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="/post/78355edd/XWfibn1JJoIh3LxWmRtcgxulnoe.jpeg"></p><p>在 SpringCloud 当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于 Spring 的 WebFlux 技术，完全支持响应式编程，吞吐能力更强</li></ul><p>课堂中我们以 SpringCloudGateway 为例来讲解，官方网站：</p><h2 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2.快速入门"></a>1.2.快速入门</h2><p>接下来，我们先看下如何利用网关实现请求路由。由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入 SpringCloudGateway、NacosDiscovery 依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h3 id="1-2-1-创建项目"><a href="#1-2-1-创建项目" class="headerlink" title="1.2.1.创建项目"></a>1.2.1.创建项目</h3><p>首先，我们要在 hmall 下创建一个新的 module，命名为 hm-gateway，作为网关微服务：</p><p><img src="/post/78355edd/R9vpbNo6CoM5G0xjL2ccq9NWnMf.png"></p><h3 id="1-2-2-引入依赖"><a href="#1-2-2-引入依赖" class="headerlink" title="1.2.2.引入依赖"></a>1.2.2.引入依赖</h3><p>在 <code>hm-gateway</code> 模块的 <code>pom.xml</code> 文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-启动类"><a href="#1-2-3-启动类" class="headerlink" title="1.2.3.启动类"></a>1.2.3.启动类</h3><p>在 <code>hm-gateway</code> 模块的 <code>com.hmall.gateway</code> 包下新建一个启动类：</p><p><img src="/post/78355edd/Ig6AbTqFUo7AkSxCK2UcJIwgnYc.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-配置路由"><a href="#1-2-4-配置路由" class="headerlink" title="1.2.4.配置路由"></a>1.2.4.配置路由</h3><p>接下来，在 <code>hm-gateway</code> 模块的 <code>resources</code> 目录新建一个 <code>application.yaml</code> 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><h3 id="1-2-5-测试"><a href="#1-2-5-测试" class="headerlink" title="1.2.5.测试"></a>1.2.5.测试</h3><p>启动 GatewayApplication，以 <a href="http://localhost:8080/">http://localhost:8080</a> 拼接微服务接口路径来测试。例如：</p><p><a href="http://localhost:8080/items/page?pageNo=1&pageSize=1">http://localhost:8080/items/page?pageNo=1&pageSize=1</a></p><p><img src="/post/78355edd/W63Rb4EMpo4BvkxPm5KcTTctnEg.png"></p><p>此时，启动 UserApplication、CartApplication，然后打开前端页面，发现相关功能都可以正常访问了：</p><h2 id="1-3-路由过滤"><a href="#1-3-路由过滤" class="headerlink" title="1.3.路由过滤"></a>1.3.路由过滤</h2><p>路由规则的定义语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>其中 routes 对应的类型如下：</p><p><img src="/post/78355edd/Vnf6bfVPToMKy3xQtgBcuRyynUc.png"></p><p>是一个集合，也就是说可以定义很多路由规则。集合中的 <code>RouteDefinition</code> 就是具体的路由规则定义，其中常见的属性如下：</p><p><img src="/post/78355edd/CV8JbF1SkoI4CYxbp1Bc9jujnof.png"></p><p>四个属性含义如下：</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code> 代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里我们重点关注 <code>predicates</code>，也就是路由断言。SpringCloudGateway 中支持的断言类型有很多：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些 cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些 header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个 host（域名）</td><td>- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack 或者- Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的 ip 必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>weight</td><td>权重处理</td><td></td></tr></tbody></table><h1 id="2-网关登录校验"><a href="#2-网关登录校验" class="headerlink" title="2.网关登录校验"></a>2.网关登录校验</h1><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h2 id="2-1-鉴权思路分析"><a href="#2-1-鉴权思路分析" class="headerlink" title="2.1.鉴权思路分析"></a>2.1.鉴权思路分析</h2><p>我们的登录是基于 JWT 来实现的，校验 JWT 的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道 JWT 的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>此时，登录校验的流程如图：</p><p>不过，这里存在几个问题：</p><ul><li>网关路由是配置的，请求转发是 Gateway 内部代码，我们如何在转发之前做登录校验？</li><li>网关校验 JWT 之后，如何将用户信息传递给微服务？</li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><p>这些问题将在接下来几节一一解决。</p><h2 id="2-2-网关过滤器"><a href="#2-2-网关过滤器" class="headerlink" title="2.2.网关过滤器"></a>2.2.网关过滤器</h2><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是 <code>Gateway</code> 内部代码实现的，要想在请求转发之前做登录校验，就必须了解 <code>Gateway</code> 内部工作的基本原理。</p><p>如图所示：</p><ol><li>客户端请求进入网关后由 <code>HandlerMapping</code> 对请求做判断，找到与当前请求匹配的路由规则（<strong>Route</strong>），然后将请求交给 <code>WebHandler</code> 去处理。</li><li><code>WebHandler</code> 则会加载当前路由下需要执行的过滤器链（<strong>Filter chain</strong>），然后按照顺序逐一执行过滤器（后面称为 <strong>Filter</strong>）。</li><li>图中 <code>Filter</code> 被虚线分为左右两部分，是因为 <code>Filter</code> 内部的逻辑分为 <code>pre</code> 和 <code>post</code> 两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有 <code>Filter</code> 的 <code>pre</code> 逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行 <code>Filter</code> 的 <code>post</code> 逻辑。</li><li>最终把响应结果返回。</li></ol><p>如图中所示，最终请求转发是有一个名为 <code>NettyRoutingFilter</code> 的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<strong><strong>NettyRoutingFilter</strong></strong>之前</strong>，这就符合我们的需求了！</p><p>那么，该如何实现一个网关过滤器呢？</p><p>网关过滤器链中的过滤器有两种：</p><ul><li><strong>GatewayFilter</strong>：路由过滤器，作用范围比较灵活，可以是任意指定的路由 <code>Route</code>.</li><li><strong>GlobalFilter</strong>：全局过滤器，作用范围是所有路由，不可配置。</li></ul><p>其实 <code>GatewayFilter</code> 和 <code>GlobalFilter</code> 这两种过滤器的方法签名完全一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求并将其传递给下一个过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exchange 当前请求的上下文，其中包含request、response等各种数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chain 过滤器链，基于它向下传递请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br></pre></td></tr></table></figure><p><code>FilteringWebHandler</code> 在处理请求时，会将 <code>GlobalFilter</code> 装饰为 <code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p><p><code>Gateway</code> 中内置了很多的 <code>GatewayFilter</code>，详情可以参考官方文档：</p><p><code>Gateway</code> 内置的 <code>GatewayFilter</code> 过滤器使用起来非常简单，无需编码，只要在 yaml 文件中简单配置即可。而且其作用范围也很灵活，配置在哪个 <code>Route</code> 下，就作用于哪个 <code>Route</code>.</p><p>例如，有一个过滤器叫做 <code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p><p>使用的使用只需要在 application.yaml 中这样配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span> <span class="comment"># 逗号之前是请求头的key，逗号之后是value</span></span><br></pre></td></tr></table></figure><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># default-filters下的过滤器可以作用于所有路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br></pre></td></tr></table></figure><h2 id="2-3-自定义过滤器"><a href="#2-3-自定义过滤器" class="headerlink" title="2.3.自定义过滤器"></a>2.3.自定义过滤器</h2><p>无论是 <code>GatewayFilter</code> 还是 <code>GlobalFilter</code> 都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别。</p><h3 id="2-3-1-自定义-GatewayFilter"><a href="#2-3-1-自定义-GatewayFilter" class="headerlink" title="2.3.1.自定义 GatewayFilter"></a>2.3.1.自定义 GatewayFilter</h3><p>自定义 <code>GatewayFilter</code> 不是直接实现 <code>GatewayFilter</code>，而是实现 <code>AbstractGatewayFilterFactory</code>。最简单的方式是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行了&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 yaml 配置中这样使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 yaml 文件中使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照 shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-自定义-GlobalFilter"><a href="#2-3-2-自定义-GlobalFilter" class="headerlink" title="2.3.2.自定义 GlobalFilter"></a>2.3.2.自定义 GlobalFilter</h3><p>自定义 GlobalFilter 则简单很多，直接实现 GlobalFilter 即可，而且也无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-登录校验"><a href="#2-4-登录校验" class="headerlink" title="2.4.登录校验"></a>2.4.登录校验</h2><p>接下来，我们就利用自定义 <code>GlobalFilter</code> 来完成登录校验。</p><h3 id="2-4-1-JWT-工具"><a href="#2-4-1-JWT-工具" class="headerlink" title="2.4.1.JWT 工具"></a>2.4.1.JWT 工具</h3><p>登录校验需要用到 JWT，而且 JWT 的加密需要秘钥和加密工具。这些在 <code>hm-service</code> 中已经有了，我们直接拷贝过来：</p><p><img src="/post/78355edd/Qv5NbXnFXoSEulxRldWcaQhRnHe.png"></p><p>具体作用如下：</p><ul><li><code>AuthProperties</code>：配置登录校验需要拦截的路径，因为不是所有的路径都需要登录才能访问</li><li><code>JwtProperties</code>：定义与 JWT 工具有关的属性，比如秘钥文件位置</li><li><code>SecurityConfig</code>：工具的自动装配</li><li><code>JwtTool</code>：JWT 工具，其中包含了校验和解析 <code>token</code> 的功能</li><li><code>hmall.jks</code>：秘钥文件</li></ul><p>其中 <code>AuthProperties</code> 和 <code>JwtProperties</code> 所需的属性要在 <code>application.yaml</code> 中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span> <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span> <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span> <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-登录校验过滤器"><a href="#2-4-2-登录校验过滤器" class="headerlink" title="2.4.2.登录校验过滤器"></a>2.4.2.登录校验过滤器</h3><p>接下来，我们定义一个登录校验的过滤器：</p><p><img src="/post/78355edd/J5UYbPGswojkP6xsx6Vc6jOonyf.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.gateway.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.UnauthorizedException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.gateway.config.AuthProperties;</span><br><span class="line"><span class="keyword">import</span> com.hmall.gateway.util.JwtTool;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AuthProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtTool jwtTool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthProperties authProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取Request</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2.判断是否不需要拦截</span></span><br><span class="line">        <span class="keyword">if</span>(isExclude(request.getPath().toString()))&#123;</span><br><span class="line">            <span class="comment">// 无需拦截，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; headers = request.getHeaders().get(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!CollUtils.isEmpty(headers)) &#123;</span><br><span class="line">            token = headers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.校验并解析token</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = jwtTool.parseToken(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnauthorizedException e) &#123;</span><br><span class="line">            <span class="comment">// 如果无效，拦截</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 5.如果有效，传递用户信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;userId = &quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 6.放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExclude</span><span class="params">(String antPath)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String pathPattern : authProperties.getExcludePaths()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(antPathMatcher.match(pathPattern, antPath))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启测试，会发现访问&#x2F;items 开头的路径，未登录状态下不会被拦截：</p><p><img src="/post/78355edd/IpBsbwAkHoTWOgxTJhfc8V5Mn4c.png"></p><p>访问其他路径则，未登录状态下请求会被拦截，并且返回 <code>401</code> 状态码：</p><p><img src="/post/78355edd/Fh4HbAVTkoq9m8xRaxucduCVnig.png"></p><h2 id="2-5-微服务获取用户"><a href="#2-5-微服务获取用户" class="headerlink" title="2.5.微服务获取用户"></a>2.5.微服务获取用户</h2><p>现在，网关已经可以完成登录校验并获取登录用户身份信息。但是当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p><p>由于网关发送请求到微服务依然采用的是 <code>Http</code> 请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用 SpringMVC 的拦截器来实现登录用户信息获取，并存入 ThreadLocal，方便后续使用。</p><p>据图流程图如下：</p><p><img src="/post/78355edd/KhxEb6rjBoNrVCxsehLcFPLEnSd.jpeg"></p><p>因此，接下来我们要做的事情有：</p><ul><li>改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务</li><li>编写微服务拦截器，拦截请求获取用户信息，保存到 ThreadLocal 后放行</li></ul><h3 id="2-5-1-保存用户到请求头"><a href="#2-5-1-保存用户到请求头" class="headerlink" title="2.5.1.保存用户到请求头"></a>2.5.1.保存用户到请求头</h3><p>首先，我们修改登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p><p><img src="/post/78355edd/SRGpbGWcxo3PvJxvQRycfdfKnlf.png"></p><h3 id="2-5-2-拦截器获取用户"><a href="#2-5-2-拦截器获取用户" class="headerlink" title="2.5.2.拦截器获取用户"></a>2.5.2.拦截器获取用户</h3><p>在 hm-common 中已经有一个用于保存登录用户的 ThreadLocal 工具：</p><p><img src="/post/78355edd/SoZwbNA5Bo95PoxvKtAcCEy2n6b.png"></p><p>其中已经提供了保存和获取用户的方法：</p><p><img src="/post/78355edd/MSafbLjGzoleujx5LfPcRo52nOo.png"></p><p>接下来，我们只需要编写拦截器，获取用户信息并保存到 <code>UserContext</code>，然后放行即可。</p><p>由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在 <code>hm-common</code> 中，并写好自动装配。这样微服务只需要引入 <code>hm-common</code> 就可以直接具备拦截器功能，无需重复编写。</p><p>我们在 <code>hm-common</code> 模块下定义一个拦截器：</p><p><img src="/post/78355edd/U259bSutboIJ22xpeuhcVAE0n0g.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 不为空，保存到ThreadLocal</span></span><br><span class="line">                UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>hm-common</code> 模块下编写 <code>SpringMVC</code> 的配置类，配置登录拦截器：</p><p><img src="/post/78355edd/PY3Abd29hoZJnbxTpHNcpIJxnFd.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.common.interceptor.UserInfoInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是 <code>com.hmall.common.config</code>，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效。</p><p>基于 SpringBoot 的自动装配原理，我们要将其添加到 <code>resources</code> 目录下的 <code>META-INF/spring.factories</code> 文件中：</p><p><img src="/post/78355edd/FSrybmKRjoN1uexAKBDcEcz6nVd.png"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.hmall.common.config.MyBatisConfig,\</span><br><span class="line">  com.hmall.common.config.MvcConfig</span><br></pre></td></tr></table></figure><h3 id="2-5-3-恢复购物车代码"><a href="#2-5-3-恢复购物车代码" class="headerlink" title="2.5.3.恢复购物车代码"></a>2.5.3.恢复购物车代码</h3><p>之前我们无法获取登录用户，所以把购物车服务的登录用户写死了，现在需要恢复到原来的样子。</p><p>找到 <code>cart-service</code> 模块的 <code>com.hmall.cart.service.impl.CartServiceImpl</code>：</p><p><img src="/post/78355edd/YiqdbtWk4oCvchxGkVecFZ18nee.png"></p><p>修改其中的 <code>queryMyCarts</code> 方法：</p><p><img src="/post/78355edd/Brj0bkhDHo1ltOxpK0wcx52pnFe.png"></p><h2 id="2-6-OpenFeign-传递用户"><a href="#2-6-OpenFeign-传递用户" class="headerlink" title="2.6.OpenFeign 传递用户"></a>2.6.OpenFeign 传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src="/post/78355edd/Yp5Xb6eaPo5VbSxtQsPcBkJbnXl.jpeg"></p><p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于 OpenFeign 来实现的，并不是我们自己发送的请求。我们如何才能让每一个由 OpenFeign 发起的请求自动携带登录用户信息呢？</p><p>这里要借助 Feign 中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要实现这个接口，然后实现 apply 方法，利用 <code>RequestTemplate</code> 类来添加请求头，将用户信息保存到请求头中。这样以来，每次 OpenFeign 发起请求的时候都会调用该方法，传递用户信息。</p><p>由于 <code>FeignClient</code> 全部都是在 <code>hm-api</code> 模块，因此我们在 <code>hm-api</code> 模块的 <code>com.hmall.api.config.DefaultFeignConfig</code> 中编写这个拦截器：</p><p><img src="/post/78355edd/TMIebURUooAuI8xcBfycgGssn7e.png"></p><p>在 <code>com.hmall.api.config.DefaultFeignConfig</code> 中添加一个 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取登录用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">            template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在微服务之间通过 OpenFeign 调用时也会传递登录用户信息了。</p><h1 id="3-配置管理"><a href="#3-配置管理" class="headerlink" title="3.配置管理"></a>3.配置管理</h1><p>到目前为止我们已经解决了微服务相关的几个问题：</p><ul><li>微服务远程调用</li><li>微服务注册、发现</li><li>微服务请求路由、负载均衡</li><li>微服务登录用户信息传递</li></ul><p>不过，现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而 Nacos 不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="/post/78355edd/E6aHb40gYoDM11xMUNKc4c6Znxf.jpeg"></p><p>微服务共享的配置可以统一交给 Nacos 保存和管理，在 Nacos 控制台修改配置后，Nacos 会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h2 id="3-1-配置共享"><a href="#3-1-配置共享" class="headerlink" title="3.1.配置共享"></a>3.1.配置共享</h2><p>我们可以把微服务共享的配置抽取到 Nacos 中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在 Nacos 中添加共享配置</li><li>微服务拉取配置</li></ul><h3 id="3-1-1-添加共享配置"><a href="#3-1-1-添加共享配置" class="headerlink" title="3.1.1.添加共享配置"></a>3.1.1.添加共享配置</h3><p>以 cart-service 为例，我们看看有哪些配置是重复的，可以抽取的：</p><p>首先是 jdbc 相关配置：</p><p><img src="/post/78355edd/SGzLbc9OhomXrBxLwyfcjOR8nTb.png"></p><p>然后是日志配置：</p><p><img src="/post/78355edd/HDzXbMoOhouzZNxb0sdctc2Mnqg.png"></p><p>然后是 swagger 以及 OpenFeign 的配置：</p><p><img src="/post/78355edd/RHkObtlmcogGu1xXTlUceGilnob.png"></p><p>我们在 nacos 控制台分别添加这些配置。</p><p>首先是 jdbc 相关配置，在 <code>配置管理</code>-&gt;<code>配置列表</code> 中点击 <code>+</code> 新建一个配置：</p><p><img src="/post/78355edd/ToaobgZmUoO2aOx9t7vcHCfbnKf.png"></p><p>在弹出的表单中填写信息：</p><p><img src="/post/78355edd/ENvbbM2CfoWaTXx2BdPcDjysnEc.png"></p><p>其中详细的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host:192.168.150.101&#125;:$&#123;hm.db.port:3306&#125;/$&#123;hm.db.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.db.un:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw:123&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><p>注意这里的 jdbc 的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过 <code>$&#123;hm.db.host:192.168.150.101&#125;</code> 配置了默认值为 <code>192.168.150.101</code>，同时允许通过 <code>$&#123;hm.db.host&#125;</code> 来覆盖默认值</li><li><code>数据库端口</code>：通过 <code>$&#123;hm.db.port:3306&#125;</code> 配置了默认值为 <code>3306</code>，同时允许通过 <code>$&#123;hm.db.port&#125;</code> 来覆盖默认值</li><li><code>数据库database</code>：可以通过 <code>$&#123;hm.db.database&#125;</code> 来设定，无默认值</li></ul><p>然后是统一的日志配置，命名为 <code>shared-log.yaml</code>，配置内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>然后是统一的 swagger 配置，命名为 <code>shared-swagger.yaml</code>，配置内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">$&#123;hm.swagger.title:黑马商城接口文档&#125;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">$&#123;hm.swagger.description:黑马商城接口文档&#125;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">$&#123;hm.swagger.email:zhanghuyi@itcast.cn&#125;</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">$&#123;hm.swagger.concat:虎哥&#125;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">$&#123;hm.swagger.package&#125;</span></span><br></pre></td></tr></table></figure><p>注意，这里的 swagger 相关配置我们没有写死，例如：</p><ul><li><code>title</code>：接口文档标题，我们用了 <code>$&#123;hm.swagger.title&#125;</code> 来代替，将来可以有用户手动指定</li><li><code>email</code>：联系人邮箱，我们用了 <code>$&#123;hm.swagger.email:``zhanghuyi@itcast.cn``&#125;</code>，默认值是 <code>zhanghuyi@itcast.cn</code>，同时允许用户利用 <code>$&#123;hm.swagger.email&#125;</code> 来覆盖。</li></ul><h3 id="3-1-2-拉取共享配置"><a href="#3-1-2-拉取共享配置" class="headerlink" title="3.1.2.拉取共享配置"></a>3.1.2.拉取共享配置</h3><p>接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的 <code>application.yaml</code> 配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取 Nacos 配置是 SpringCloud 上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化 SpringBoot 上下文，去读取 <code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code> 文件尚未读取，根本不知道 nacos 地址，该如何去加载 nacos 中的配置文件呢？</p><p>SpringCloud 在初始化上下文的时候会先读取一个名为 <code>bootstrap.yaml</code>(或者 <code>bootstrap.properties</code>)的文件，如果我们将 nacos 地址配置到 <code>bootstrap.yaml</code> 中，那么在项目引导阶段就可以读取 nacos 中的配置了。</p><p><img src="/post/78355edd/LidubbjyhoF4sKxFdwKcZXcnnWf.jpeg"></p><p>因此，微服务整合 Nacos 配置管理的步骤如下：</p><p>1）引入依赖：</p><p>在 cart-service 模块引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）新建 bootstrap.yaml</p><p>在 cart-service 中的 resources 目录新建一个 bootstrap.yaml 文件：</p><p><img src="/post/78355edd/VWJAbDR2eoQzHBxTepdcOos3nKe.png"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>3）修改 application.yaml</p><p>由于一些配置挪到了 bootstrap.yaml，因此 application.yaml 需要修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure><p>重启服务，发现所有配置都生效了。</p><h2 id="3-2-配置热更新"><a href="#3-2-配置热更新" class="headerlink" title="3.2.配置热更新"></a>3.2.配置热更新</h2><p>有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是 10，对应代码如下：</p><p><img src="/post/78355edd/GQi9bn4atos8mfxHrODc5AwHnJf.png"></p><p>现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。</p><p>但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到 Nacos 的配置热更新能力了，分为两步：</p><ul><li>在 Nacos 中添加配置</li><li>在微服务读取配置</li></ul><h3 id="3-2-1-添加配置到-Nacos"><a href="#3-2-1-添加配置到-Nacos" class="headerlink" title="3.2.1.添加配置到 Nacos"></a>3.2.1.添加配置到 Nacos</h3><p>首先，我们在 nacos 中添加一个配置文件，将购物车的上限数量添加到配置中：</p><p><img src="/post/78355edd/NvbrbqIMXoSOt5x4cqwc4kmmnrg.png"></p><p>注意文件的 dataId 格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[服务名]-[spring.active.profile].[后缀名]</span><br></pre></td></tr></table></figure><p>文件名称由三部分组成：</p><ul><li><strong>服务名</strong>：我们是购物车服务，所以是 <code>cart-service</code></li><li><strong>spring.active.profile</strong>：就是 spring boot 中的 <code>spring.active.profile</code>，可以省略，则所有 profile 共享该配置</li><li><strong>后缀名</strong>：例如 yaml</li></ul><p>这里我们直接使用 <code>cart-service.yaml</code> 这个名称，则不管是 dev 还是 local 环境都可以共享该配置。</p><p>配置内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">cart:</span></span><br><span class="line">    <span class="attr">maxAmount:</span> <span class="number">1</span> <span class="comment"># 购物车商品数量上限</span></span><br></pre></td></tr></table></figure><p>提交配置，在控制台能看到新添加的配置：</p><p><img src="/post/78355edd/W67Hb7D9doWibGxkrQzcSuHZnrf.png"></p><h3 id="3-2-2-配置热更新"><a href="#3-2-2-配置热更新" class="headerlink" title="3.2.2.配置热更新"></a>3.2.2.配置热更新</h3><p>接着，我们在微服务中读取配置，实现配置热更新。</p><p>在 <code>cart-service</code> 中新建一个属性读取类：</p><p><img src="/post/78355edd/QnPObp5QMo3lpvxBWUYc3tZOnxd.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，在业务中使用该属性加载类：</p><p><img src="/post/78355edd/LmwfbrEjnofYP3xIVYccWiion5f.png"></p><p>测试，向购物车中添加多个商品：</p><p><img src="/post/78355edd/LSn1bp5cCoYWkGxP5IicPqFOncd.png"></p><p>我们在 nacos 控制台，将购物车上限配置为 5：</p><p><img src="/post/78355edd/XbSAbqXbQoINBwx1AvTcFrxrnLe.png"></p><p>无需重启，再次测试购物车功能：</p><p><img src="/post/78355edd/RVX9bdQtAoiggSxw5iycpoEWn7d.png"></p><p>加入成功！</p><p>无需重启服务，配置热更新就生效了！</p><h2 id="3-3-动态路由"><a href="#3-3-动态路由" class="headerlink" title="3.3.动态路由"></a>3.3.动态路由</h2><p>网关的路由配置全部是在项目启动时由 <code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code> 在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个 Map），不会改变。也不会监听路由变更，所以，我们无法利用上节课学习的配置热更新来实现路由更新。</p><p>因此，我们必须监听 Nacos 的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听 Nacos 配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h3 id="3-3-1-监听-Nacos-配置变更"><a href="#3-3-1-监听-Nacos-配置变更" class="headerlink" title="3.3.1.监听 Nacos 配置变更"></a>3.3.1.监听 Nacos 配置变更</h3><p>在 Nacos 官网中给出了手动监听 Nacos 配置变更的 SDK：</p><p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span></span><br></pre></td></tr></table></figure><p>请求参数说明：</p><table><thead><tr><th><strong>参数名</strong></th><th><strong>参数类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>dataId</td><td>string</td><td>配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节。</td></tr><tr><td>group</td><td>string</td><td>配置分组，一般是默认的 DEFAULT_GROUP。</td></tr><tr><td>listener</td><td>Listener</td><td>监听器，配置变更进入监听器的回调函数。</td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里核心的步骤有 2 步：</p><ul><li>创建 ConfigService，目的是连接到 Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><p>由于我们采用了 <code>spring-cloud-starter-alibaba-nacos-config</code> 自动装配，因此 <code>ConfigService</code> 已经在 <code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code> 中自动创建好了：</p><p><img src="/post/78355edd/INEIbFX9WozMryx0LjvcxmV1nqe.png"></p><p>NacosConfigManager 中是负责管理 Nacos 的 ConfigService 的，具体代码如下：</p><p><img src="/post/78355edd/JmqbbAPoHoNxeAxeKikcjn1MnIh.png"></p><p>因此，只要我们拿到 <code>NacosConfigManager</code> 就等于拿到了 <code>ConfigService</code>，第一步就实现了。</p><p>第二步，编写监听器。虽然官方提供的 SDK 是 ConfigService 中的 addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的 API 是这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据 dataId 和 group 读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h3 id="3-3-2-更新路由"><a href="#3-3-2-更新路由" class="headerlink" title="3.3.2.更新路由"></a>3.3.2.更新路由</h3><p>更新路由要用到 <code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code> 这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.gateway.route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是 RouteDefinition，之前我们见过，包含下列常见字段：</p><ul><li>id：路由 id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到 Nacos 的配置也要符合这个对象结构，将来我们以 JSON 来保存，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上 JSON 配置就等同于：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>OK，我们所需要用到的 SDK 已经齐全了。</p><h3 id="3-3-3-实现动态路由"><a href="#3-3-3-实现动态路由" class="headerlink" title="3.3.3.实现动态路由"></a>3.3.3.实现动态路由</h3><p>首先， 我们在网关 gateway 引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在网关 <code>gateway</code> 的 <code>resources</code> 目录创建 <code>bootstrap.yaml</code> 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>接着，修改 <code>gateway</code> 的 <code>resources</code> 目录下的 <code>application.yml</code>，把之前的路由移除，最终内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span> <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span> <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span> <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>gateway</code> 中定义配置监听器：</p><p><img src="/post/78355edd/MCeEb8smqovMrqxCovtcdPdhnAc.png"></p><p>其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.gateway.route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.cloud.nacos.NacosConfigManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.config.listener.Listener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.exception.NacosException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteDefinitionWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启网关，任意访问一个接口，比如 <a href="http://localhost:8080/search/list?pageNo=1&pageSize=1">http://localhost:8080/search/list?pageNo=1&pageSize=1</a>：</p><p><img src="/post/78355edd/AI6Mb6mknoBNcAxrI4qcuv9Unxg.png"></p><p>发现是 404，无法访问。</p><p>接下来，我们直接在 Nacos 控制台添加路由，路由文件名为 <code>gateway-routes.json</code>，类型为 <code>json</code>：</p><p><img src="/post/78355edd/GFFMbrKF1ou2LpxsgOxcTbfOnbd.png"></p><p>配置内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/carts/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://cart-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/users/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/addresses/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://user-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trade&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://trade-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pay&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/pay-orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://pau-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>无需重启网关，稍等几秒钟后，再次访问刚才的地址：</p><p><img src="/post/78355edd/Sk95bPaUYo1gEZxXuhwc9itDnOd.png"></p><p>网关路由成功了！</p><h1 id="4-作业"><a href="#4-作业" class="headerlink" title="4.作业"></a>4.作业</h1><p>将项目一拆分为一个微服务项目，并完成下列需求：</p><ul><li>基于 OpenFeign 实现服务间远程调用</li><li>定义网关，实现对微服务的请求路由</li><li>基于网关实现登录用户校验和用户信息传递</li></ul><p>以苍穹外卖为例，项目可以拆分为：</p><ul><li><p>业务服务：</p><ul><li>用户服务：用户、地址、登录等相关业务</li><li>产品服务：店铺、分类、菜品、套餐等业务</li><li>交易服务：订单、购物车业务</li><li>数据服务：工作台、报表统计等业务</li></ul></li><li><p>基础服务：</p><ul><li>支付服务：支付相关业务</li><li>文件服务：文件上传功能</li></ul></li></ul>]]></content>
    
    
    <summary type="html">微服务学习笔记2</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://threewood1.top/tags/SpringBoot/"/>
    
    <category term="Microservice Architecture" scheme="https://threewood1.top/tags/Microservice-Architecture/"/>
    
    <category term="SpringCloud" scheme="https://threewood1.top/tags/SpringCloud/"/>
    
    <category term="OpenFeign" scheme="https://threewood1.top/tags/OpenFeign/"/>
    
    <category term="Nacos" scheme="https://threewood1.top/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>微服务拆分作业</title>
    <link href="https://threewood1.top/post/b4c3744e.html"/>
    <id>https://threewood1.top/post/b4c3744e.html</id>
    <published>2024-01-09T02:22:14.000Z</published>
    <updated>2024-01-09T02:30:18.982Z</updated>
    
    <content type="html"><![CDATA[<p>作业尽量自己完成，实在觉得有困难的，再来查看本篇内容</p><h1 id="用户服务"><a href="#用户服务" class="headerlink" title="用户服务"></a>用户服务</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在 hmall 下新建一个 module，命名为 user-service：</p><p><img src="/post/b4c3744e/Hp7UbkTmWoNTPBxTROecvR02ndf.png"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>user-service 的 pom.xml 文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--api--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><p>在 user-service 中的 <code>com.hmall.user</code> 包下创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.user.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>从 <code>hm-service</code> 项目中复制 3 个 yaml 配置文件到 <code>user-service</code> 的 <code>resource</code> 目录。</p><p>其中 <code>application-dev.yaml</code> 和 <code>application-local.yaml</code> 保持不变。<code>application.yaml</code> 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-user?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">用户服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.user.controller</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span></span><br></pre></td></tr></table></figure><p>将 hm-service 下的 hmall.jks 文件拷贝到 user-service 下的 resources 目录，这是 JWT 加密的秘钥文件：</p><p><img src="/post/b4c3744e/QL60bCCg2oBnQBxdDrdc2lt5nPe.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>复制 hm-service 中所有与 user、address、jwt 有关的代码，最终项目结构如下：</p><p><img src="/post/b4c3744e/EBCMbNHXKoj54mxZCetcWGG6nWu.png"></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>user-service 也需要自己的独立的 database，向 MySQL 中导入课前资料提供的 SQL：</p><p><img src="/post/b4c3744e/ALgtbWtjkorSaMxJF17ceCldnRd.png"></p><p>导入结果如下：</p><p><img src="/post/b4c3744e/Z7zCbYNBUoaG5jx7RMPchgbSn6f.png"></p><h2 id="配置启动项"><a href="#配置启动项" class="headerlink" title="配置启动项"></a>配置启动项</h2><p>给 user-service 配置启动项，设置 profile 为 local：</p><p><img src="/post/b4c3744e/FvLdb4UJMoQhmIx3HtrcC6E9nHd.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动 UserApplication，访问 <a href="http://localhost:8084/doc.html#/default/%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/loginUsingPOST">http://localhost:8084/doc.html#/default/用户相关接口/loginUsingPOST</a>，测试登录接口：</p><p><img src="/post/b4c3744e/F1wRbOhUTotEsZxqVPIcE9oknKf.png"></p><p>用户服务测试通过。</p><h1 id="交易服务"><a href="#交易服务" class="headerlink" title="交易服务"></a>交易服务</h1><h2 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h2><p>在 hmall 下新建一个 module，命名为 trade-service：</p><p><img src="/post/b4c3744e/JBLpbdGINoutlOx0Df4cNLEonJg.png"></p><h2 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h2><p>trade-service 的 pom.xml 文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--api--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h2><p>在 trade-service 中的 <code>com.hmall.trade</code> 包下创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.trade.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TradeApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TradeApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>从 <code>hm-service</code> 项目中复制 3 个 yaml 配置文件到 <code>trade-service</code> 的 <code>resource</code> 目录。</p><p>其中 <code>application-dev.yaml</code> 和 <code>application-local.yaml</code> 保持不变。<code>application.yaml</code> 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-trade?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">交易服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.trade.controller</span></span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h3 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h3><p>复制 hm-service 中所有与 trade 有关的代码，最终项目结构如下：</p><p><img src="/post/b4c3744e/MehObrQlEoBcNhxfVQ9c1waknmh.png"></p><p>在交易服务中，用户下单时需要做下列事情：</p><ul><li><strong>根据 id 查询商品列表</strong></li><li>计算商品总价</li><li>保存订单</li><li><strong>扣减库存</strong></li><li><strong>清理购物车商品</strong></li></ul><p>其中，查询商品、扣减库存都是与商品有关的业务，在 item-service 中有相关功能；清理购物车商品是购物车业务，在 cart-service 中有相关功能。</p><p>因此交易服务要调用他们，必须通过 OpenFeign 远程调用。我们需要将上述功能抽取为 FeignClient.</p><h3 id="抽取-ItemClient-接口"><a href="#抽取-ItemClient-接口" class="headerlink" title="抽取 ItemClient 接口"></a>抽取 ItemClient 接口</h3><p>首先是<strong>扣减库存</strong>，在 <code>item-service</code> 中的对应业务接口如下：</p><p><img src="/post/b4c3744e/HJ2TbhMeIoCc8FxYzGScyOT8n8m.png"></p><p>我们将这个接口抽取到 <code>hm-api</code> 模块的 <code>com.hmall.api.client.ItemClient</code> 中:</p><p><img src="/post/b4c3744e/SE78bG540oUSamxY8UycXKlXnme.png"></p><p>将接口参数的 <code>OrderDetailDTO</code> 抽取到 <code>hm-api</code> 模块的 <code>com.hmall.api.dto</code> 包下：</p><p><img src="/post/b4c3744e/DDQGbVYEZoVcpPxbTaNcZ6WSnSf.png"></p><h3 id="抽取-CartClient-接口"><a href="#抽取-CartClient-接口" class="headerlink" title="抽取 CartClient 接口"></a>抽取 CartClient 接口</h3><p>接下来是<strong>清理购物车商品</strong>，在 <code>cart-service</code> 中的对应业务接口如下：</p><p><img src="/post/b4c3744e/Ks6dbdpprobMQTx1yXuclbVPnIe.png"></p><p>我们在 <code>hm-api</code> 模块的 <code>com.hmall.api.client</code> 包下定义一个 <code>CartClient</code> 接口：</p><p><img src="/post/b4c3744e/AkiqbW7A9oNISXx9VHWcIYFZnhc.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;cart-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CartClient</span> &#123;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/carts&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteCartItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造-OrderServiceImpl"><a href="#改造-OrderServiceImpl" class="headerlink" title="改造 OrderServiceImpl"></a>改造 OrderServiceImpl</h3><p>接下来，就可以改造 OrderServiceImpl 中的逻辑，将本地方法调用改造为基于 FeignClient 的调用，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.CartClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.ItemClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.ItemDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.OrderDetailDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BadRequestException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.dto.OrderFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.Order;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.OrderDetail;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.mapper.OrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderDetailService;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *_/</span></span><br><span class="line"><span class="comment"><span class="doctag">@Service</span></span></span><br><span class="line"><span class="comment"><span class="doctag">@RequiredArgsConstructor</span></span></span><br><span class="line"><span class="comment">public class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Order&gt; implements IOrderService &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    private final ItemClient itemClient;</span></span><br><span class="line"><span class="comment">    private final IOrderDetailService detailService;</span></span><br><span class="line"><span class="comment">    private final CartClient cartClient;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">    <span class="doctag">@Transactional</span></span></span><br><span class="line"><span class="comment">    public Long createOrder(OrderFormDTO orderFormDTO) &#123;</span></span><br><span class="line"><span class="comment">        // 1.订单数据</span></span><br><span class="line"><span class="comment">        Order order = new Order();</span></span><br><span class="line"><span class="comment">        // 1.1.查询商品</span></span><br><span class="line"><span class="comment">        List&lt;OrderDetailDTO&gt; detailDTOS = orderFormDTO.getDetails();</span></span><br><span class="line"><span class="comment">        // 1.2.获取商品id和数量的Map</span></span><br><span class="line"><span class="comment">        Map&lt;Long, Integer&gt; itemNumMap = detailDTOS.stream()</span></span><br><span class="line"><span class="comment">                .collect(Collectors.toMap(OrderDetailDTO::getItemId, OrderDetailDTO::getNum));</span></span><br><span class="line"><span class="comment">        Set&lt;Long&gt; itemIds = itemNumMap.keySet();</span></span><br><span class="line"><span class="comment">        // 1.3.查询商品</span></span><br><span class="line"><span class="comment">        List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span></span><br><span class="line"><span class="comment">        if (items == null || items.size() &lt; itemIds.size()) &#123;</span></span><br><span class="line"><span class="comment">            throw new BadRequestException(&quot;商品不存在&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 1.4.基于商品价格、购买数量计算商品总价：totalFee</span></span><br><span class="line"><span class="comment">        int total = 0;</span></span><br><span class="line"><span class="comment">        for (ItemDTO item : items) &#123;</span></span><br><span class="line"><span class="comment">__            total += item.getPrice() _ itemNumMap.get(item.getId());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        order.setTotalFee(total);</span></span><br><span class="line"><span class="comment">        // 1.5.其它属性</span></span><br><span class="line"><span class="comment">        order.setPaymentType(orderFormDTO.getPaymentType());</span></span><br><span class="line"><span class="comment">        order.setUserId(UserContext.getUser());</span></span><br><span class="line"><span class="comment">        order.setStatus(1);</span></span><br><span class="line"><span class="comment">        // 1.6.将Order写入数据库order表中</span></span><br><span class="line"><span class="comment">        save(order);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 2.保存订单详情</span></span><br><span class="line"><span class="comment">        List&lt;OrderDetail&gt; details = buildDetails(order.getId(), items, itemNumMap);</span></span><br><span class="line"><span class="comment">        detailService.saveBatch(details);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 3.扣减库存</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            itemClient.deductStock(detailDTOS);</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            throw new RuntimeException(&quot;库存不足！&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 4.清理购物车商品</span></span><br><span class="line"><span class="comment">        cartClient.deleteCartItemByIds(itemIds);</span></span><br><span class="line"><span class="comment">        return order.getId();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    private List&lt;OrderDetail&gt; buildDetails(Long orderId, List&lt;ItemDTO&gt; items, Map&lt;Long, Integer&gt; numMap) &#123;</span></span><br><span class="line"><span class="comment">        List&lt;OrderDetail&gt; details = new ArrayList&lt;&gt;(items.size());</span></span><br><span class="line"><span class="comment">        for (ItemDTO item : items) &#123;</span></span><br><span class="line"><span class="comment">            OrderDetail detail = new OrderDetail();</span></span><br><span class="line"><span class="comment">            detail.setName(item.getName());</span></span><br><span class="line"><span class="comment">            detail.setSpec(item.getSpec());</span></span><br><span class="line"><span class="comment">            detail.setPrice(item.getPrice());</span></span><br><span class="line"><span class="comment">            detail.setNum(numMap.get(item.getId()));</span></span><br><span class="line"><span class="comment">            detail.setItemId(item.getId());</span></span><br><span class="line"><span class="comment">            detail.setImage(item.getImage());</span></span><br><span class="line"><span class="comment">            detail.setOrderId(orderId);</span></span><br><span class="line"><span class="comment">            details.add(detail);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return details;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><p>trade-service 也需要自己的独立的 database，向 MySQL 中导入课前资料提供的 SQL：</p><p><img src="/post/b4c3744e/GvfGbfPqgoh5NJxc2cWcTbEYnFe.png"></p><p>导入结果如下：</p><p><img src="/post/b4c3744e/OGixbNeX2o8srlxHnXecmob8n5d.png"></p><h2 id="配置启动项-1"><a href="#配置启动项-1" class="headerlink" title="配置启动项"></a>配置启动项</h2><p>给 trade-service 配置启动项，设置 profile 为 local：</p><p><img src="/post/b4c3744e/Uv7ebsB5MoJgDixxPDgcWx6EnPn.png"></p><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>启动 TradeApplication，访问 <a href="http://localhost:8085/doc.html#/default/%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3/queryOrderByIdUsingGET">http://localhost:8085/doc.html</a>，测试查询订单接口：</p><p><img src="/post/b4c3744e/AhZCbj7PUoHe12xW2APcTPPNnFM.png"></p><p>请求参数：1654779387523936258，交易服务测试通过。</p><p>注意，创建订单接口无法测试，因为无法获取登录用户信息。</p><h1 id="支付服务"><a href="#支付服务" class="headerlink" title="支付服务"></a>支付服务</h1><h2 id="创建项目-2"><a href="#创建项目-2" class="headerlink" title="创建项目"></a>创建项目</h2><p>在 <code>hmall</code> 下新建一个 module，命名为 <code>pay-service</code>：</p><p><img src="/post/b4c3744e/BlzQbOKgGoboQtx3U4zcA06Mnoe.png"></p><h2 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h2><p><code>pay-service</code> 的 <code>pom.xml</code> 文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pay-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--api--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动类-2"><a href="#启动类-2" class="headerlink" title="启动类"></a>启动类</h2><p>在 pay-service 中的 <code>com.hmall.pay</code> 包下创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.pay.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h2><p>从 <code>hm-service</code> 项目中复制 3 个 yaml 配置文件到 <code>trade-service</code> 的 <code>resource</code> 目录。</p><p>其中 <code>application-dev.yaml</code> 和 <code>application-local.yaml</code> 保持不变。<code>application.yaml</code> 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pay-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-pay?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">支付服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;支付服务接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.pay.controller</span></span><br></pre></td></tr></table></figure><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h3 id="基础代码-1"><a href="#基础代码-1" class="headerlink" title="基础代码"></a>基础代码</h3><p>复制 hm-service 中所有与支付有关的代码，最终项目结构如下：</p><p><img src="/post/b4c3744e/CzlzbZTtZoTyuJx8WxscgFvMnVd.png"></p><p>在支付服务中，基于用户余额支付时需要做下列事情：</p><ul><li><strong>扣减用户余额</strong></li><li>标记支付单状态为已支付</li><li><strong>标记订单状态为已支付</strong></li></ul><p>其中，<strong>扣减用户余额</strong>是在 <code>user-service</code> 中有相关功能；<strong>标记订单状态</strong>则是在 <code>trade-service</code> 中有相关功能。因此交易服务要调用他们，必须通过 OpenFeign 远程调用。我们需要将上述功能抽取为 FeignClient.</p><h3 id="抽取-UserClient-接口"><a href="#抽取-UserClient-接口" class="headerlink" title="抽取 UserClient 接口"></a>抽取 UserClient 接口</h3><p>首先是<strong>扣减用户余额</strong>，在 <code>user-service</code> 中的对应业务接口如下：</p><p><img src="/post/b4c3744e/JI4ybqddhoy1PcxDBIwc3CEHn1c.png"></p><p>我们将这个接口抽取到 <code>hm-api</code> 模块的 <code>com.hmall.api.client.UserClient</code> 中:</p><p><img src="/post/b4c3744e/Z5DobBCKCogtLnxMkIncvFNMnGf.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/users/money/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">(<span class="meta">@RequestParam(&quot;pw&quot;)</span> String pw,<span class="meta">@RequestParam(&quot;amount&quot;)</span> Integer amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽取-TradeClient-接口"><a href="#抽取-TradeClient-接口" class="headerlink" title="抽取 TradeClient 接口"></a>抽取 TradeClient 接口</h3><p>接下来是<strong>标记订单状态</strong>，在 <code>trade-service</code> 中的对应业务接口如下：</p><p><img src="/post/b4c3744e/KE1ub5ghEoQbwBx45dfcpRRqnme.png"></p><p>我们将这个接口抽取到 <code>hm-api</code> 模块的 <code>com.hmall.api.client.TradeClient</code> 中:</p><p><img src="/post/b4c3744e/Y305bsxN6olQFox7SKQcUbAmnNd.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;trade-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TradeClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造-PayOrderServiceImpl"><a href="#改造-PayOrderServiceImpl" class="headerlink" title="改造 PayOrderServiceImpl"></a>改造 PayOrderServiceImpl</h3><p>接下来，就可以改造 <code>PayOrderServiceImpl</code> 中的逻辑，将本地方法调用改造为基于 <code>FeignClient</code> 的调用，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.pay.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.IdWorker;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.TradeClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.UserClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BizIllegalException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.domain.dto.PayApplyDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.domain.dto.PayOrderFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.domain.po.PayOrder;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.enums.PayStatus;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.mapper.PayOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.service.IPayOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 支付订单 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;PayOrderMapper, PayOrder&gt; <span class="keyword">implements</span> <span class="title class_">IPayOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TradeClient tradeClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">applyPayOrder</span><span class="params">(PayApplyDTO applyDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.幂等性校验</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> checkIdempotent(applyDTO);</span><br><span class="line">        <span class="comment">// 2.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> payOrder.getId().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderFormDTO payOrderDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询支付单</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">        <span class="comment">// 2.判断状态</span></span><br><span class="line">        <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">            <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">        userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">        <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.修改订单状态</span></span><br><span class="line">        tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markPayOrderSuccess</span><span class="params">(Long id, LocalDateTime successTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lambdaUpdate()</span><br><span class="line">                .set(PayOrder::getStatus, PayStatus.TRADE_SUCCESS.getValue())</span><br><span class="line">                .set(PayOrder::getPaySuccessTime, successTime)</span><br><span class="line">                .eq(PayOrder::getId, id)</span><br><span class="line">                <span class="comment">// 支付状态的乐观锁判断</span></span><br><span class="line">                .in(PayOrder::getStatus, PayStatus.NOT_COMMIT.getValue(), PayStatus.WAIT_BUYER_PAY.getValue())</span><br><span class="line">                .update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayOrder <span class="title function_">checkIdempotent</span><span class="params">(PayApplyDTO applyDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.首先查询支付单</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">oldOrder</span> <span class="operator">=</span> queryByBizOrderNo(applyDTO.getBizOrderNo());</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (oldOrder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不存在支付单，说明是第一次，写入新的支付单并返回</span></span><br><span class="line">            <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> buildPayOrder(applyDTO);</span><br><span class="line">            payOrder.setPayOrderNo(IdWorker.getId());</span><br><span class="line">            save(payOrder);</span><br><span class="line">            <span class="keyword">return</span> payOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.旧单已经存在，判断是否支付成功</span></span><br><span class="line">        <span class="keyword">if</span> (PayStatus.TRADE_SUCCESS.equalsValue(oldOrder.getStatus())) &#123;</span><br><span class="line">            <span class="comment">// 已经支付成功，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;订单已经支付！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.旧单已经存在，判断是否已经关闭</span></span><br><span class="line">        <span class="keyword">if</span> (PayStatus.TRADE_CLOSED.equalsValue(oldOrder.getStatus())) &#123;</span><br><span class="line">            <span class="comment">// 已经关闭，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;订单已关闭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.旧单已经存在，判断支付渠道是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(oldOrder.getPayChannelCode(), applyDTO.getPayChannelCode())) &#123;</span><br><span class="line">            <span class="comment">// 支付渠道不一致，需要重置数据，然后重新申请支付单</span></span><br><span class="line">            <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> buildPayOrder(applyDTO);</span><br><span class="line">            payOrder.setId(oldOrder.getId());</span><br><span class="line">            payOrder.setQrCodeUrl(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            updateById(payOrder);</span><br><span class="line">            payOrder.setPayOrderNo(oldOrder.getPayOrderNo());</span><br><span class="line">            <span class="keyword">return</span> payOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.旧单已经存在，且可能是未支付或未提交，且支付渠道一致，直接返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> oldOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayOrder <span class="title function_">buildPayOrder</span><span class="params">(PayApplyDTO payApplyDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.数据转换</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> BeanUtils.toBean(payApplyDTO, PayOrder.class);</span><br><span class="line">        <span class="comment">// 2.初始化数据</span></span><br><span class="line">        payOrder.setPayOverTime(LocalDateTime.now().plusMinutes(<span class="number">120L</span>));</span><br><span class="line">        payOrder.setStatus(PayStatus.WAIT_BUYER_PAY.getValue());</span><br><span class="line">        payOrder.setBizUserId(UserContext.getUser());</span><br><span class="line">        <span class="keyword">return</span> payOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> PayOrder <span class="title function_">queryByBizOrderNo</span><span class="params">(Long bizOrderNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lambdaQuery()</span><br><span class="line">                .eq(PayOrder::getBizOrderNo, bizOrderNo)</span><br><span class="line">                .one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库-2"><a href="#数据库-2" class="headerlink" title="数据库"></a>数据库</h2><p><code>pay-service</code> 也需要自己的独立的 database，向 MySQL 中导入课前资料提供的 SQL：</p><p><img src="/post/b4c3744e/NS3Obvx6WoB84bx7F3PcxJ5Zngg.png"></p><p>导入结果如下：</p><p><img src="/post/b4c3744e/AxtbbmLaToabXax1Rmgcw8GInRv.png"></p><h2 id="配置启动项-2"><a href="#配置启动项-2" class="headerlink" title="配置启动项"></a>配置启动项</h2><p>给 <code>pay-service</code> 配置启动项，设置 profile 为 <code>local</code>：</p><p><img src="/post/b4c3744e/Msgfby67XoqY3Axz6iCc3I1Qnbb.png"></p><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><p>在支付服务的 PayController 中添加一个接口方便测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;查询支付单&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PayOrderVO&gt; <span class="title function_">queryPayOrders</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyList(payOrderService.list(), PayOrderVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 PayApplication，访问 <a href="http://localhost:8086/doc.html#/default/%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/queryPayOrdersUsingGET">http://localhost:8086/doc.html</a>，测试查询订单接口：</p><p><img src="/post/b4c3744e/FnJnbiGUQooZYdxrBnacjRxPndb.png"></p><p>支付服务测试通过。</p>]]></content>
    
    
    <summary type="html">微服务拆分作业参考</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://threewood1.top/tags/SpringBoot/"/>
    
    <category term="Microservice Architecture" scheme="https://threewood1.top/tags/Microservice-Architecture/"/>
    
    <category term="SpringCloud" scheme="https://threewood1.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>微服务学习1</title>
    <link href="https://threewood1.top/post/e13c0f67.html"/>
    <id>https://threewood1.top/post/e13c0f67.html</id>
    <published>2024-01-09T02:11:58.000Z</published>
    <updated>2024-01-09T02:39:13.023Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们学习的项目一是单体项目，可以满足小型项目或传统项目的开发。而在互联网时代，越来越多的一线互联网公司都在使用微服务技术。</p><p>从谷歌搜索指数来看，国内从自 2016 年底开始，微服务热度突然暴涨：</p><p><img src="/post/e13c0f67/V8Fib919ToSZMXxyLLvcJ227nKf.png"></p><p>那么：</p><ul><li>到底什么是微服务？</li><li>企业该不该引入微服务？</li><li>微服务技术该如何在企业落地？</li></ul><p>接下来几天，我们就一起来揭开它的神秘面纱。</p><p>计划是这样的，课前资料中给大家准备了一个<strong>单体</strong>的电商小项目：黑马商城，我们会基于这个单体项目来演示从单体架构到微服务架构的演变过程、分析其中存在的问题，以及微服务技术是如何解决这些问题的。</p><p>你会发现每一个微服务技术都是在解决服务化过程中产生的问题，你对于每一个微服务技术具体的应用场景和使用方式都会有更深层次的理解。</p><p>今天作为课程的第一天，我们要完成下面的内容：</p><ul><li>知道单体架构的特点</li><li>知道微服务架构的特点</li><li>学会拆分微服务</li><li>会使用 Nacos 实现服务治理</li><li>会使用 OpenFeign 实现远程调用</li></ul><h1 id="导入黑马商城项目"><a href="#导入黑马商城项目" class="headerlink" title="导入黑马商城项目"></a>导入黑马商城项目</h1><p>在课前资料中给大家提供了黑马商城项目的资料，我们需要先导入这个单体项目。不过需要注意的是，本篇及后续的微服务学习都是基于 Centos7 系统下的 Docker 部署，因此你必须做好一些准备：</p><ul><li>Centos7 的环境及一个好用的 SSH 客户端</li><li>安装好 Docker</li><li>会使用 Docker</li></ul><p>如果你没有这样的 Linux 环境，或者不是 Centos7 的话，那么这里有一篇参考文档：</p><ul><li><a href="https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc">Linux 环境搭建</a></li></ul><p>建议按照上面的文档来搭建虚拟机环境，使用其它版本会出现一些环境问题，比较痛苦。</p><p>如果已经有 Linux 环境，但是没有安装 Docker 的话，那么这里还有一篇参考文档：</p><ul><li><a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">安装 Docker</a></li></ul><p>如果不会使用 Docker 的话可以参考黑马的微服务前置 Docker 课程，B 站地址如下：</p><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>在课前资料提供好了 MySQL 的一个目录：</p><p><img src="/post/e13c0f67/HJZybGXW7o5gaUxgcmPcO5X3nDc.png"></p><p>其中有 MySQL 的配置文件和初始化脚本：</p><p><img src="/post/e13c0f67/VGKzbg8Fgo9LebxXmwtcdtK7nrc.png"></p><p>我们将其复制到虚拟机的 <code>/root</code> 目录。如果 <code>/root</code> 下已经存在 <code>mysql</code> 目录则删除旧的，如果不存在则直接复制本地的：</p><p><img src="/post/e13c0f67/SrysbgTIOomhx1xviOgcrbIhnxg.png"></p><p>然后创建一个通用网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create hm-net</span><br></pre></td></tr></table></figure><p>使用下面的命令来安装 MySQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hm-net\</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>此时，通过命令查看 mysql 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/post/e13c0f67/AiCHbWLiBojOwXxCGh4cKpPrnjc.png"></p><p>发现 mysql 容器正常运行。</p><blockquote><p>注：图片中的 dps 命令是我设置的别名，等同于 docker ps –format，可以简化命令格式。你可以参考黑马的 <a href="https://b11et3un53m.feishu.cn/wiki/MWQIw4Zvhil0I5ktPHwcoqZdnec">day02-Docker</a> 的 2.1.3 小节来配置。</p></blockquote><p>此时，如果我们使用 MySQL 的客户端工具连接 MySQL，应该能发现已经创建了黑马商城所需要的表：</p><p><img src="/post/e13c0f67/UI6ibcKoVoQZw3xGQbuc5BFgnxc.png"></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>然后是 Java 代码，在课前资料提供了一个 hmall 目录：</p><p><img src="/post/e13c0f67/Y982bJVbao4HoJx3CCFclTIKn8b.png"></p><p>将其复制到你的工作空间，然后利用 Idea 打开。</p><p>项目结构如下：</p><p><img src="/post/e13c0f67/L5s0b5xt5opKd5xC92Scu3MBnwh.png"></p><p>按下 <code>ALT</code> + <code>8</code> 键打开 services 窗口，新增一个启动项：</p><p><img src="/post/e13c0f67/W0pBbw05gothLvxYxmRcYUjonrf.png"></p><p>在弹出窗口中鼠标向下滚动，找到 <code>Spring Boot</code>:</p><p><img src="/post/e13c0f67/LqPXb3EFVop6fYxsyCocBIeYnHb.png"></p><p>点击后应该会在 services 中出现 hmall 的启动项：</p><p><img src="/post/e13c0f67/Ijhyb8oLYogNf6xcXgLcgHxWnDd.png"></p><p>点击对应按钮，即可实现运行或 DEBUG 运行。</p><p><strong>不过别着急！！</strong></p><p>我们还需要对这个启动项做简单配置，在 <code>HMallApplication</code> 上点击鼠标右键，会弹出窗口，然后选择 <code>Edit Configuration</code>：</p><p><img src="/post/e13c0f67/AtZ0birx5o7IOHxia7tc4LFmnZc.png"></p><p>在弹出窗口中配置 SpringBoot 的启动环境为 local：</p><p><img src="/post/e13c0f67/LyHFbEmiFoArMtxDr8ScNiWpn17.png"></p><p>点击 OK 配置完成。接下来就可以运行了！</p><p>启动完成后，试试看访问下 <a href="http://localhost:8080/hi">http://localhost:8080/hi</a> 吧！</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>在课前资料中还提供了一个 hmall-nginx 的目录：</p><p><img src="/post/e13c0f67/TzE4bnEECokMkox5e9CcQamLnXd.png"></p><p>其中就是一个 nginx 程序以及我们的前端代码，直接在 windows 下将其复制到一个非中文、不包含特殊字符的目录下。然后进入 hmall-nginx 后，利用 cmd 启动即可：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line"><span class="built_in">start</span> nginx.exe</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">nginx.exe <span class="literal">-s</span> stop</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">nginx.exe <span class="literal">-s</span> reload</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">nginx.exe <span class="literal">-s</span> restart</span><br></pre></td></tr></table></figure><p>启动成功后，访问 <a href="http://localhost:18080，应该能看到我们的门户页面：">http://localhost:18080，应该能看到我们的门户页面：</a></p><p><img src="/post/e13c0f67/P5JTbfltkorIRIxvm2IcFf08ndc.png"></p><h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><p>这一章我们从单体架构的优缺点来分析，看看开发大型项目采用单体架构存在哪些问题，而微服务架构又是如何解决这些问题的。</p><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>单体架构（monolithic structure）：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。</p><p><img src="/post/e13c0f67/LKOfbgsSnoBPuNxcmyNc6wj8nmb.jpeg"></p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p><p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>在上述问题中，前两点相信大家在实战过程中应该深有体会。对于第三点系统可用性问题，很多同学可能感触不深。接下来我们就通过黑马商城这个项目，给大家做一个简单演示。</p><p>首先，我们修改 hm-service 模块下的 <code>com.hmall.controller.HelloController</code> 中的 <code>hello</code> 方法，模拟方法执行时的耗时：</p><p><img src="/post/e13c0f67/ZOAzb2kEQoGMstxm7QRco6kanGf.png"></p><p>接下来，启动项目，目前有两个接口是无需登录即可访问的：</p><ul><li><code>http://localhost:8080/hi</code></li><li><code>http://localhost:8080/search/list</code></li></ul><p>经过测试，目前 <code>/search/list</code> 是比较正常的，访问耗时在 30 毫秒左右。</p><p>接下来，我们假设 <code>/hi</code> 这个接口是一个并发较高的热点接口，我们通过 Jemeter 来模拟 500 个用户不停访问。在课前资料中已经提供了 Jemeter 的测试脚本：</p><p><img src="/post/e13c0f67/Qqonb6XHpoNge2xDS6pcYBBLnCc.png"></p><p>导入 Jemeter 并测试：</p><p><img src="/post/e13c0f67/Lw2Rb08bqoOlK4xuZ72cQF8An4g.png"></p><p>这个脚本会开启 500 个线程并发请求 <code>http://localhost/hi</code> 这个接口。由于该接口存在执行耗时（500 毫秒），这就服务端导致每秒能处理的请求数量有限，最终会有越来越多请求积压，直至 Tomcat 资源耗尽。这样，其它本来正常的接口（例如 <code>/search/list</code>）也都会被拖慢，甚至因超时而无法访问了。</p><p>我们测试一下，启动测试脚本，然后在浏览器访问 <code>http://localhost:8080/search/list</code> 这个接口，会发现响应速度非常慢：</p><p><img src="/post/e13c0f67/UowRbc33toZzQNxo7P9cTfTWnVb.png"></p><p>如果进一步提高 <code>/hi</code> 这个接口的并发，最终会发现 <code>/search/list</code> 接口的请求响应速度会越来越慢。</p><p>可见，单体架构的可用性是比较差的，功能之间相互影响比较大。</p><p>当然，有同学会说我们可以做水平扩展。</p><p>此时如果我们对系统做水平扩展，增加更多机器，资源还是会被这样的热点接口占用，从而影响到其它接口，并不能从根本上解决问题。这也就是单体架构的扩展性差的一个原因。</p><p>而要想解决这些问题，就需要使用微服务架构了。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过 10 人（2 张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p>例如，黑马商城项目，我们就可以把商品、用户、购物车、交易等模块拆分，交给不同的团队去开发，并独立部署：</p><p><img src="/post/e13c0f67/Z4ubbQhm5oXqCUx0hoacCk88nQg.jpeg"></p><p>那么，单体架构存在的问题有没有解决呢？</p><ul><li><p>团队协作成本高？</p><ul><li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在 1~3 名，协作成本大大降低</li></ul></li><li><p>系统发布效率低？</p><ul><li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li></ul></li><li><p>系统可用性差？</p><ul><li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务。</li></ul></li></ul><p>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正式分布式架构的一种最佳实践的方案。</p><p>当然，微服务架构虽然能解决单体架构的各种问题，但在拆分的过程中，还会面临很多其它问题。比如：</p><ul><li>如果出现跨服务的业务该如何处理？</li><li>页面请求到底该访问哪个服务？</li><li>如何实现各个服务之间的服务隔离？</li></ul><p>这些问题，我们在后续的学习中会给大家逐一解答。</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>微服务拆分以后碰到的各种问题都有对应的解决方案和微服务组件，而 SpringCloud 框架可以说是目前 Java 领域最全面的微服务组件的集合了。</p><p><img src="/post/e13c0f67/V6ILb9imUoe9cZx6ll5cm0mynzc.png"></p><p>而且 SpringCloud 依托于 SpringBoot 的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用 SpringCloud 全家桶来实现微服务开发可以说是最合适的选择了！</p><p>目前 SpringCloud 最新版本为 <code>2022.0.x</code> 版本，对应的 SpringBoot 版本为 <code>3.x</code> 版本，但它们全部依赖于 JDK17，目前在企业中使用相对较少。</p><table><thead><tr><th>##### <strong>SpringCloud 版本</strong></th><th>##### <strong>SpringBoot 版本</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">2022.0.x</a> aka Kilburn</td><td>3.0.x</td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td><td>2.6.x, 2.7.x (Starting with 2021.0.3)</td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td>2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td>2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td>2.1.x</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td>2.0.x</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td>1.5.x</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td>1.5.x</td></tr></tbody></table><p>因此，我们推荐使用次新版本：Spring Cloud 2021.0.x 以及 Spring Boot 2.7.x 版本。</p><p>另外，Alibaba 的微服务产品 SpringCloudAlibaba 目前也成为了 SpringCloud 组件中的一员，我们课堂中也会使用其中的部分组件。</p><p>在我们的父工程 hmall 中已经配置了 SpringCloud 以及 SpringCloudAlibaba 的依赖：</p><p><img src="/post/e13c0f67/HwRGbEBQyoPIJyxf6ypcDknUnUh.png"></p><p>对应的版本：</p><p><img src="/post/e13c0f67/QNSfbaH3Po2VkoxmfKAcbWKPnpf.png"></p><p>这样，我们在后续需要使用 SpringCloud 或者 SpringCloudAlibaba 组件时，就无需单独指定版本了。</p><h1 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h1><p>接下来，我们就一起将黑马商城这个单体项目拆分为微服务项目，并解决其中出现的各种问题。</p><h2 id="熟悉黑马商城"><a href="#熟悉黑马商城" class="headerlink" title="熟悉黑马商城"></a>熟悉黑马商城</h2><p>首先，我们需要熟悉黑马商城项目的基本结构：</p><p><img src="/post/e13c0f67/Q0oTb9mi1oWvjYxobH3c9058n9b.png"></p><p>大家可以直接启动该项目，测试效果。不过，需要修改数据库连接参数，在 application-local.yaml 中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 修改为你自己的虚拟机IP地址</span></span><br><span class="line">    <span class="attr">pw:</span> <span class="number">123</span> <span class="comment"># 修改为docker中的MySQL密码</span></span><br></pre></td></tr></table></figure><p>同时配置启动项激活的是 local 环境：</p><p><img src="/post/e13c0f67/KvV4bAjUvo0yN3xrEo7cal9Dntc.png"></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>首先来看一下登录业务流程：</p><p>登录入口在 <code>com.hmall.controller.UserController</code> 中的 <code>login</code> 方法：</p><p><img src="/post/e13c0f67/PvjHbZMmmocIbIx7ecJcF8CknVh.png"></p><h3 id="搜索商品"><a href="#搜索商品" class="headerlink" title="搜索商品"></a>搜索商品</h3><p>在首页搜索框输入关键字，点击搜索即可进入搜索列表页面：</p><p><img src="/post/e13c0f67/JsqtbPK3ToxHVIxIDBHcraAsnmg.png"></p><p>该页面会调用接口：<code>/search/list</code>，对应的服务端入口在 <code>com.hmall.controller.SearchController</code> 中的 <code>search</code> 方法：</p><p><img src="/post/e13c0f67/GVl9bwS1OoAr5UxZyQocQUAjnHf.png"></p><p>这里目前是利用数据库实现了简单的分页查询。</p><h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p>在搜索到的商品列表中，点击按钮 <code>加入购物车</code>，即可将商品加入购物车：</p><p><img src="/post/e13c0f67/FsqYbIKkcoqIf7xwfzecfNG4noe.png"></p><p>加入成功后即可进入购物车列表页，查看自己购物车商品列表：</p><p><img src="/post/e13c0f67/RJdPb3Sq4oGVI7xKqX3cMEAlnOf.png"></p><p>同时这里还可以对购物车实现修改、删除等操作。</p><p>相关功能全部在 <code>com.hmall.controller.CartController</code> 中：</p><p><img src="/post/e13c0f67/VuS3b5llGo4p8bx3F6qcrSa3nmd.png"></p><p>其中，查询购物车列表时，由于要判断商品最新的价格和状态，所以还需要查询商品信息，业务流程如下：</p><h3 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h3><p>在购物车页面点击 <code>结算</code> 按钮，会进入订单结算页面：</p><p><img src="/post/e13c0f67/E80SbvmzHoyympxpbOQcXJRenag.png"></p><p>点击提交订单，会提交请求到服务端，服务端做 3 件事情：</p><ul><li>创建一个新的订单</li><li>扣减商品库存</li><li>清理购物车中商品</li></ul><p>业务入口在 <code>com.hmall.controller.OrderController</code> 中的 <code>createOrder</code> 方法：</p><p><img src="/post/e13c0f67/SFYQbyLefoQ0gUxuqTwc2D6innI.png"></p><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>下单完成后会跳转到支付页面，目前只支持<strong>余额支付</strong>：</p><p><img src="/post/e13c0f67/NtZjbxHHwoQMdPxZxDjc9bAMnKJ.png"></p><p>在选择<strong>余额支付</strong>这种方式后，会发起请求到服务端，服务端会立刻创建一个支付流水单，并返回支付流水单号到前端。</p><p>当用户输入用户密码，然后点击确认支付时，页面会发送请求到服务端，而服务端会做几件事情：</p><ul><li>校验用户密码</li><li>扣减余额</li><li>修改支付流水状态</li><li>修改交易订单状态</li></ul><p>请求入口在 <code>com.hmall.controller.PayController</code> 中：</p><p><img src="/post/e13c0f67/SjSqbzY58oXzJQxXSRWccF3Hnid.png"></p><h2 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h2><p>服务拆分一定要考虑几个问题：</p><ul><li>什么时候拆？</li><li>如何拆？</li></ul><h3 id="什么时候拆"><a href="#什么时候拆" class="headerlink" title="什么时候拆"></a>什么时候拆</h3><p>一般情况下，对于一个初创的项目，首先要做的是验证项目的可行性。因此这一阶段的首要任务是敏捷开发，快速产出生产可用的产品，投入市场做验证。为了达成这一目的，该阶段项目架构往往会比较简单，很多情况下会直接采用单体架构，这样开发成本比较低，可以快速产出结果，一旦发现项目不符合市场，损失较小。</p><p>如果这一阶段采用复杂的微服务架构，投入大量的人力和时间成本用于架构设计，最终发现产品不符合市场需求，等于全部做了无用功。</p><p>所以，对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、业务复杂后<strong>再逐渐拆分为****微服务架构</strong>。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）。</p><p>而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）。</p><h3 id="怎么拆"><a href="#怎么拆" class="headerlink" title="怎么拆"></a>怎么拆</h3><p>之前我们说过，微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析：</p><ul><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</li><li><strong>低****耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</li></ul><p><strong>高内聚</strong>首先是<strong>单一职责，</strong>但不能说一个微服务就一个接口，而是要保证微服务内部业务的完整性为前提。目标是当我们要修改某个业务时，最好就只修改当前微服务，这样变更的成本更低。</p><p>一旦微服务做到了高内聚，那么服务之间的<strong>耦合度</strong>自然就降低了。</p><p>当然，微服务之间不可避免的会有或多或少的业务交互，比如下单时需要查询商品数据。这个时候我们不能在订单服务直接查询商品数据库，否则就导致了数据耦合。而应该由商品服务对应暴露接口，并且一定要保证微服务对外<strong>接口的稳定性</strong>（即：尽量保证接口外观不变）。虽然出现了服务间调用，但此时无论你如何在商品服务做内部修改，都不会影响到订单微服务，服务间的耦合度就降低了。</p><p>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式：</p><ul><li><strong>纵向</strong>拆分</li><li><strong>横向</strong>拆分</li></ul><p>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</p><p>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</p><p>当然，由于黑马商城并不是一个完整的项目，其中的短信发送、风控管理并没有实现，这里就不再考虑了。而其它的业务按照纵向拆分，可以分为以下几个微服务：</p><ul><li>用户服务</li><li>商品服务</li><li>订单服务</li><li>购物车服务</li><li>支付服务</li></ul><h2 id="拆分购物车、商品服务"><a href="#拆分购物车、商品服务" class="headerlink" title="拆分购物车、商品服务"></a>拆分购物车、商品服务</h2><p>接下来，我们先把商品管理功能、购物车功能抽取为两个独立服务。</p><p>一般微服务项目有两种不同的工程结构：</p><ul><li><p>完全解耦：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。</p><ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li><p>Maven 聚合：整个项目为一个 Project，然后每个微服务是其中的一个 Module</p><ul><li>优点：项目代码集中，管理和运维方便（授课也方便）</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><p>在 hmall 父工程之中，我已经提前定义了 SpringBoot、SpringCloud 的依赖版本，所以为了方便期间，我们直接在这个项目中创建微服务 module.</p><h3 id="商品服务"><a href="#商品服务" class="headerlink" title="商品服务"></a>商品服务</h3><p>在 hmall 中创建 module：</p><p><img src="/post/e13c0f67/DYmJb2D8xoSUB8xuxSHcJu77nmc.png"></p><p>选择 maven 模块，并设定 JDK 版本为 11：</p><p><img src="/post/e13c0f67/EIBQb3Yk0ofORHxLECzcVrJ9nNe.png"></p><p>商品模块，我们起名为 <code>item-service</code>：</p><p><img src="/post/e13c0f67/IrH8byiAvo3i3sx88jocT8K3nNh.png"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>item-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写启动类：</p><p><img src="/post/e13c0f67/KU5AbTlaCo1g3Cx60CscLbvBnYb.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.item.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ItemApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是配置文件，可以从 <code>hm-service</code> 中拷贝：</p><p><img src="/post/e13c0f67/VYqWbNOWXoYzgxxx5YbcAhoonjc.png"></p><p>其中，<code>application.yaml</code> 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-item?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">商品服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.item.controller</span></span><br></pre></td></tr></table></figure><p>剩下的 <code>application-dev.yaml</code> 和 <code>application-local.yaml</code> 直接从 hm-service 拷贝即可。</p><p>然后拷贝 <code>hm-service</code> 中与商品管理有关的代码到 <code>item-service</code>，如图：</p><p><img src="/post/e13c0f67/Tjb3bomtEovlWZxM4V1cJR1xnYb.png"></p><p>这里有一个地方的代码需要改动，就是 <code>ItemServiceImpl</code> 中的 <code>deductStock</code> 方法：</p><p><img src="/post/e13c0f67/Vph4bmBwCoJbttxaDLEcvlaOndf.png"><br><strong>改动前</strong><br><img src="/post/e13c0f67/OmknbUXRkolDrfx0GbVc20c2nce.png"><br><strong>改动后</strong></p><p>这也是因为 ItemMapper 的所在包发生了变化，因此这里代码必须修改包路径。</p><p>最后，还要导入数据库表。默认的数据库连接的是虚拟机，在你 docker 数据库执行课前资料提供的 SQL 文件：</p><p><img src="/post/e13c0f67/H3YMbxtPMovyKxxi4hpc5JfDnZe.png"></p><p>最终，会在数据库创建一个名为 hm-item 的 database，将来的每一个微服务都会有自己的一个 database：</p><p><img src="/post/e13c0f67/FedybwvUqoerfexQJFycMfkwnYd.png"></p><p>接下来，就可以启动测试了，在启动前我们要配置一下启动项，让默认激活的配置为 <code>local</code> 而不是 <code>dev</code>：</p><p><img src="/post/e13c0f67/SRBPba3eFoHR6sx7WmYcho69noc.png"></p><p>在打开的编辑框填写 <code>active profiles</code>:</p><p><img src="/post/e13c0f67/RrCvbhFF3omO2CxwnrBc5m77n3d.png"></p><p>接着，启动 <code>item-service</code>，访问商品微服务的 swagger 接口文档：<a href="http://localhost:8081/doc.html">http://localhost:8081/doc.html</a></p><p>然后测试其中的根据 id 批量查询商品这个接口：</p><p><img src="/post/e13c0f67/AHjCbB6CUo7kzjx6JExcgwgingg.png"></p><p>测试参数：100002672302,100002624500,100002533430，结果如下：</p><p><img src="/post/e13c0f67/Hdpfbb4ELof3XaxUiqvcg5R8ned.png"></p><p>说明商品微服务抽取成功了。</p><h3 id="购物车服务"><a href="#购物车服务" class="headerlink" title="购物车服务"></a>购物车服务</h3><p>与商品服务类似，在 hmall 下创建一个新的 <code>module</code>，起名为 <code>cart-service</code>:</p><p><img src="/post/e13c0f67/A9U0bW67JoddJlxZ889cJkoqndh.png"></p><p>然后是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cart-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是配置文件，同样可以拷贝自 <code>item-service</code>，不过其中的 <code>application.yaml</code> 需要修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;db.host&#125;:3306/hm-cart?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">商品服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.cart.controller</span></span><br></pre></td></tr></table></figure><p>最后，把 hm-service 中的与购物车有关功能拷贝过来，最终的项目结构如下：</p><p><img src="/post/e13c0f67/DJnebpjAwo0oTlxfCP3cyKcynHc.png"></p><p>特别注意的是 <code>com.hmall.cart.service.impl.CartServiceImpl</code>，其中有两个地方需要处理：</p><ul><li>需要<strong>获取登录用户信息</strong>，但登录校验功能目前没有复制过来，先写死固定用户 id</li><li>查询购物车时需要<strong>查询商品信息</strong>，而商品信息不在当前服务，需要先将这部分代码注释</li></ul><p><img src="/post/e13c0f67/GmFBbUceXoafnWxq3dtcFsqanlk.png"></p><p>我们对这部分代码做如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.dto.CartFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.po.Cart;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.vo.CartVO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.mapper.CartMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.service.ICartService;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BizIllegalException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 订单详情表 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-05-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="keyword">implements</span> <span class="title class_">ICartService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private final IItemService itemService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem2Cart</span><span class="params">(CartFormDTO cartFormDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断是否已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (checkItemExists(cartFormDTO.getItemId(), userId)) &#123;</span><br><span class="line">            <span class="comment">// 2.1.存在，则更新数量</span></span><br><span class="line">            baseMapper.updateNum(cartFormDTO.getItemId(), userId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.不存在，判断是否超过购物车数量</span></span><br><span class="line">        checkCartsFull(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.新增购物车条目</span></span><br><span class="line">        <span class="comment">// 3.1.转换PO</span></span><br><span class="line">        <span class="type">Cart</span> <span class="variable">cart</span> <span class="operator">=</span> BeanUtils.copyBean(cartFormDTO, Cart.class);</span><br><span class="line">        <span class="comment">// 3.2.保存当前用户</span></span><br><span class="line">        cart.setUserId(userId);</span><br><span class="line">        <span class="comment">// 3.3.保存到数据库</span></span><br><span class="line">        save(cart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CartVO&gt; <span class="title function_">queryMyCarts</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询我的购物车列表</span></span><br><span class="line">        List&lt;Cart&gt; carts = lambdaQuery().eq(Cart::getUserId, <span class="number">1L</span> <span class="comment">/*TODO UserContext.getUser()*/</span>).list();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(carts)) &#123;</span><br><span class="line">            <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.转换VO</span></span><br><span class="line">        List&lt;CartVO&gt; vos = BeanUtils.copyList(carts, CartVO.class);</span><br><span class="line">        <span class="comment">// 3.处理VO中的商品信息</span></span><br><span class="line">        handleCartItems(vos);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> vos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取商品id TODO 处理商品信息</span></span><br><span class="line">        <span class="comment">/*Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span></span><br><span class="line"><span class="comment">        // 2.查询商品</span></span><br><span class="line"><span class="comment">        List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span></span><br><span class="line"><span class="comment">        if (CollUtils.isEmpty(items)) &#123;</span></span><br><span class="line"><span class="comment">            throw new BadRequestException(&quot;购物车中商品不存在！&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 3.转为 id 到 item的map</span></span><br><span class="line"><span class="comment">        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));</span></span><br><span class="line"><span class="comment">        // 4.写入vo</span></span><br><span class="line"><span class="comment">        for (CartVO v : vos) &#123;</span></span><br><span class="line"><span class="comment">            ItemDTO item = itemMap.get(v.getItemId());</span></span><br><span class="line"><span class="comment">            if (item == null) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            v.setNewPrice(item.getPrice());</span></span><br><span class="line"><span class="comment">            v.setStatus(item.getStatus());</span></span><br><span class="line"><span class="comment">            v.setStock(item.getStock());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeByItemIds</span><span class="params">(Collection&lt;Long&gt; itemIds)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.构建删除条件，userId和itemId</span></span><br><span class="line">        QueryWrapper&lt;Cart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Cart&gt;();</span><br><span class="line">        queryWrapper.lambda()</span><br><span class="line">                .eq(Cart::getUserId, UserContext.getUser())</span><br><span class="line">                .in(Cart::getItemId, itemIds);</span><br><span class="line">        <span class="comment">// 2.删除</span></span><br><span class="line">        remove(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkCartsFull</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery().eq(Cart::getUserId, userId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(StrUtil.format(<span class="string">&quot;用户购物车课程不能超过&#123;&#125;&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkItemExists</span><span class="params">(Long itemId, Long userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">                .eq(Cart::getUserId, userId)</span><br><span class="line">                .eq(Cart::getItemId, itemId)</span><br><span class="line">                .count();</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，还是要导入数据库表，在本地数据库直接执行课前资料对应的 SQL 文件：</p><p><img src="/post/e13c0f67/XQq8bgrVOoKJ6pxcjYEcqwXYnnf.png"></p><p>在数据库中会出现名为 <code>hm-cart</code> 的 <code>database</code>，以及其中的 <code>cart</code> 表，代表购物车：</p><p><img src="/post/e13c0f67/KP5obMzEEoeYdZxEbI8cblurnDb.png"></p><p>接下来，就可以测试了。不过在启动前，同样要配置启动项的 <code>active profile</code> 为 <code>local</code>：</p><p><img src="/post/e13c0f67/VqFzbjTn0ota9fxtk2qcUTf9nkc.png"></p><p>然后启动 <code>CartApplication</code>，访问 swagger 文档页面：<a href="http://localhost:8082/doc.html">http://localhost:8082/doc.html</a></p><p>我们测试其中的 <code>查询我的购物车列表</code> 接口：</p><p><img src="/post/e13c0f67/QmptbOZSyobQfSxrdiQcOMxGnLg.png"></p><p>无需填写参数，直接访问：</p><p><img src="/post/e13c0f67/KxfvbMiFLo1OScx5PsrcffiBngf.png"></p><p>我们注意到，其中与商品有关的几个字段值都为空！这就是因为刚才我们注释掉了查询购物车时，查询商品信息的相关代码。</p><p>那么，我们该如何在 <code>cart-service</code> 服务中实现对 <code>item-service</code> 服务的查询呢？</p><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>在拆分的时候，我们发现一个问题：就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了 <code>item-service</code> 服务，导致我们无法查询。</p><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（RPC，即 <strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p><p>因此，现在查询购物车列表的流程变成了这样：</p><p>代码中需要变化的就是这一步：</p><p><img src="/post/e13c0f67/AaGVbAsK7o66RGxjrJ3czUk9nOh.png"></p><p>那么问题来了：我们该如何跨服务调用，准确的说，如何在 <code>cart-service</code> 中获取 <code>item-service</code> 服务中的提供的商品数据呢？</p><p>大家思考一下，我们以前有没有实现过类似的远程查询的功能呢？</p><p>答案是肯定的，我们前端向服务端查询数据，其实就是从浏览器远程查询服务端数据。比如我们刚才通过 Swagger 测试商品查询接口，就是向 <code>http://localhost:8081/items</code> 这个接口发起的请求：</p><p><img src="/post/e13c0f67/UsFTbZnfgo3QxIxsCdVcOEhinwc.png"></p><p>而这种查询就是通过 http 请求的方式来完成的，不仅仅可以实现远程查询，还可以实现新增、删除等各种远程请求。</p><p>那么：我们该如何用 Java 代码发送 Http 的请求呢？</p><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>Spring 给我们提供了一个 RestTemplate 的 API，可以方便的实现 Http 请求的发送。</p><blockquote><p>org.springframework.web.client public class RestTemplate<br>extends InterceptingHttpAccessor<br>implements RestOperations</p><hr><p>同步客户端执行 HTTP 请求，在底层 HTTP 客户端库(如 JDK HttpURLConnection、Apache HttpComponents 等)上公开一个简单的模板方法 API。RestTemplate 通过 HTTP 方法为常见场景提供了模板，此外还提供了支持不太常见情况的通用交换和执行方法。 RestTemplate 通常用作共享组件。然而，它的配置不支持并发修改，因此它的配置通常是在启动时准备的。如果需要，您可以在启动时创建多个不同配置的 RestTemplate 实例。如果这些实例需要共享 HTTP 客户端资源，它们可以使用相同的底层 ClientHttpRequestFactory。 注意:从 5.0 开始，这个类处于维护模式，只有对更改和错误的小请求才会被接受。请考虑使用 org.springframework.web.react .client. webclient，它有更现代的 API，支持同步、异步和流场景。</p><hr><p>自: 3.0 参见: HttpMessageConverter, RequestCallback, ResponseExtractor, ResponseErrorHandler</p></blockquote><p>其中提供了大量的方法，方便我们发送 Http 请求，例如：</p><p><img src="/post/e13c0f67/R5WdbKFgXo653KxTQCVcrhx4nog.png"></p><p>可以看到常见的 Get、Post、Put、Delete 请求都支持，如果请求参数比较复杂，还可以使用 exchange 方法来构造请求。</p><p>我们在 <code>cart-service</code> 服务中定义一个配置类：</p><p><img src="/post/e13c0f67/CsXtbN111ofE07xGLDkcItEvndb.png"></p><p>先将 RestTemplate 注册为一个 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><p>接下来，我们修改 <code>cart-service</code> 中的 <code>com.hmall.cart.service.impl.CartServiceImpl</code> 的 <code>handleCartItems</code> 方法，发送 http 请求到 <code>item-service</code>：</p><p><img src="/post/e13c0f67/Nlotba4gWoG3Wcxhgl2cZFyLnkb.png"></p><p>可以看到，利用 RestTemplate 发送 http 请求与前端 ajax 发送请求非常相似，都包含四部分信息：</p><ul><li>① 请求方式</li><li>② 请求路径</li><li>③ 请求参数</li><li>④  返回值类型</li></ul><p><code>handleCartItems</code> 方法的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 1.获取商品id</span></span><br><span class="line">    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">// 2.查询商品</span></span><br><span class="line">    <span class="comment">// List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span></span><br><span class="line">    <span class="comment">// 2.1.利用RestTemplate发起http请求，得到http的响应</span></span><br><span class="line">    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">            <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">            HttpMethod.GET,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.2.解析响应</span></span><br><span class="line">    <span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">        <span class="comment">// 查询失败，直接结束</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ItemDTO&gt; items = response.getBody();</span><br><span class="line">    <span class="keyword">if</span> (CollUtils.isEmpty(items)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.转为 id 到 item的map</span></span><br><span class="line">    Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));</span><br><span class="line">    <span class="comment">// 4.写入vo</span></span><br><span class="line">    <span class="keyword">for</span> (CartVO v : vos) &#123;</span><br><span class="line">        <span class="type">ItemDTO</span> <span class="variable">item</span> <span class="operator">=</span> itemMap.get(v.getItemId());</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v.setNewPrice(item.getPrice());</span><br><span class="line">        v.setStatus(item.getStatus());</span><br><span class="line">        v.setStock(item.getStock());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在重启 <code>cart-service</code>，再次测试查询我的购物车列表接口：</p><p><img src="/post/e13c0f67/NRt1brweVoTsHhxNWRBcauzCnhg.png"></p><p>可以发现，所有商品相关数据都已经查询到了。</p><p>在这个过程中，<code>item-service</code> 提供了查询接口，<code>cart-service</code> 利用 Http 请求调用该接口。因此 <code>item-service</code> 可以称为服务的提供者，而 <code>cart-service</code> 则称为服务的消费者或服务调用者。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么时候需要拆分微服务？</p><ul><li>如果是创业型公司，最好先用单体架构快速迭代开发，验证市场运作模型，快速试错。当业务跑通以后，随着业务规模扩大、人员规模增加，再考虑拆分微服务。</li><li>如果是大型企业，有充足的资源，可以在项目开始之初就搭建微服务架构。</li></ul><p>如何拆分？</p><ul><li>首先要做到高内聚、低耦合</li><li>从拆分方式来说，有横向拆分和纵向拆分两种。纵向就是按照业务功能模块，横向则是拆分通用性业务，提高复用性</li></ul><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为 RPC，即远程过程调用。RPC 的实现方式有很多，比如：</p><ul><li>基于 Http 协议</li><li>基于 Dubbo 协议</li></ul><p>我们课堂中使用的是 Http 方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露 Http 接口即可，更符合微服务的需要。</p><p>Java 发送 http 请求可以使用 Spring 提供的 RestTemplate，使用的基本步骤如下：</p><ul><li><p>注册 RestTemplate 到 Spring 容器</p></li><li><p>调用 RestTemplate 的 API 发送请求，常见方法有：</p><ul><li>getForObject：发送 Get 请求并返回指定类型对象</li><li>PostForObject：发送 Post 请求并返回指定类型对象</li><li>put：发送 PUT 请求</li><li>delete：发送 Delete 请求</li><li>exchange：发送任意类型请求，返回 ResponseEntity</li></ul></li></ul><h1 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h1><p>在上一章我们实现了微服务拆分，并且通过 Http 请求实现了跨微服务的远程调用。不过这种手动发送 Http 请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，我们进行了多实例部署，如图：</p><p>此时，每个 <code>item-service</code> 的实例其 IP 或端口不同，问题来了：</p><ul><li>item-service 这么多实例，cart-service 如何知道每一个实例的地址？</li><li>http 请求要写 url 地址，<code>cart-service</code> 服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个 <code>item-service</code> 实例宕机，<code>cart-service</code> 依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code> 临时多部署了 N 台实例，<code>cart-service</code> 如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h2 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h2><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如 <code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如 <code>cart-service</code></li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="/post/e13c0f67/I585bymUMoaPSBxmzdUcoxf6ncf.jpeg"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1 个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="Nacos-注册中心"><a href="#Nacos-注册中心" class="headerlink" title="Nacos 注册中心"></a>Nacos 注册中心</h2><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix 公司出品，目前被集成在 SpringCloud 当中，一般用于 Java 应用</li><li>Nacos：Alibaba 公司出品，目前被集成在 SpringCloudAlibaba 中，一般用于 Java 应用</li><li>Consul：HashiCorp 公司出品，目前集成在 SpringCloud 中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循 SpringCloud 中的 API 规范，因此在业务开发使用上没有太大差异。由于 Nacos 是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多，课堂中我们会 Nacos 为例来学习。</p><p>官方网站如下：</p><p>我们基于 Docker 来部署 Nacos 的注册中心，首先我们要准备 MySQL 数据库表，用来存储 Nacos 的数据。由于是 Docker 部署，所以大家需要将资料中的 SQL 文件导入到你 <strong>Docker 中的 MySQL 容器</strong>中：</p><p><img src="/post/e13c0f67/HVYJbIn5jol9rPxrgYCcy2aCnih.png"></p><p>最终表结构如下：</p><p><img src="/post/e13c0f67/X3DbbkptNowBVFxxcXgco71TnYb.png"></p><p>然后，找到课前资料下的 nacos 文件夹：</p><p><img src="/post/e13c0f67/Xma8b1fjvoMcTqxjxR6cLC7mn5e.png"></p><p>其中的 <code>nacos/custom.env</code> 文件中，有一个 MYSQL_SERVICE_HOST 也就是 mysql 地址，需要修改为你自己的虚拟机 IP 地址：</p><p><img src="/post/e13c0f67/WVigbed6UoFZa1xnfoHceP2aneh.png"></p><p>然后，将课前资料中的 <code>nacos</code> 目录上传至虚拟机的 <code>/root</code> 目录。</p><p>进入 root 目录，然后执行下面的 docker 命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br></pre></td></tr></table></figure><p>启动完成后，访问下面地址：<a href="http://192.168.150.101:8848/nacos/">http://192.168.150.101:8848/nacos/</a>，注意将 <code>192.168.150.101</code> 替换为你自己的虚拟机 IP 地址。</p><p>首次访问会跳转到登录页，<strong>账号密码都是 nacos</strong></p><p><img src="/post/e13c0f67/Lu31bphUQo6CDVxBK7mcqUaynVh.png"></p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>接下来，我们把 <code>item-service</code> 注册到 Nacos，步骤如下：</p><ul><li>引入依赖</li><li>配置 Nacos 地址</li><li>重启</li></ul><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在 <code>item-service</code> 的 <code>pom.xml</code> 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-Nacos"><a href="#配置-Nacos" class="headerlink" title="配置 Nacos"></a>配置 Nacos</h3><p>在 <code>item-service</code> 的 <code>application.yml</code> 中添加 nacos 地址配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><h3 id="启动服务实例"><a href="#启动服务实例" class="headerlink" title="启动服务实例"></a>启动服务实例</h3><p>为了测试一个服务多个实例的情况，我们再配置一个 <code>item-service</code> 的部署实例：</p><p><img src="/post/e13c0f67/AlBlbtkUKoTE48xfsyFceRO0nDh.png"></p><p>然后配置启动项，注意重命名并且配置新的端口，避免冲突：</p><p><img src="/post/e13c0f67/ZqNjb9lCkoXhbUxvAE1cDOa5n6d.png"></p><p>重启 <code>item-service</code> 的两个实例：</p><p><img src="/post/e13c0f67/WUqwbFz2EoG8QwxfqUTc4AqhnbE.png"></p><p>访问 nacos 控制台，可以发现服务注册成功：</p><p><img src="/post/e13c0f67/XcghblCOJoOTayxSAA4ckACynJe.png"></p><p>点击详情，可以查看到 <code>item-service</code> 服务的两个实例信息：</p><p><img src="/post/e13c0f67/CgHsb5suQoIbg4xczhJcURzAnlc.png"></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务的消费者要去 nacos 订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置 Nacos 地址</li><li>发现并调用服务</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>服务发现除了要引入 nacos 依赖以外，由于还需要负载均衡，因此要引入 SpringCloud 提供的 LoadBalancer 依赖。</p><p>我们在 <code>cart-service</code> 中的 <code>pom.xml</code> 中添加下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，这里 Nacos 的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><p>因此，等一会儿 <code>cart-service</code> 启动，同样会注册到 Nacos</p><h3 id="配置-Nacos-地址"><a href="#配置-Nacos-地址" class="headerlink" title="配置 Nacos 地址"></a>配置 Nacos 地址</h3><p>在 <code>cart-service</code> 的 <code>application.yml</code> 中添加 nacos 地址配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h3 id="发现并调用服务"><a href="#发现并调用服务" class="headerlink" title="发现并调用服务"></a>发现并调用服务</h3><p>接下来，服务调用者 <code>cart-service</code> 就可以去订阅 <code>item-service</code> 服务了。不过 item-service 有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IP 的 hash</li><li>最近最少访问</li><li>…</li></ul><p>这里我们可以选择最简单的随机负载均衡。</p><p>另外，服务发现需要用到一个工具，DiscoveryClient，SpringCloud 已经帮我们自动装配，我们可以直接注入使用：</p><p><img src="/post/e13c0f67/MXrtbHXsDoRDSJxqwQCcl49Unme.png"></p><p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的 IP 和端口：</p><p><img src="/post/e13c0f67/YpuKb3Zr8ojuU0xKEeFcGbxlnXg.png"></p><p>但现在不需要了，我们通过 DiscoveryClient 发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p><p><img src="/post/e13c0f67/OxcNbMlX2ooAX6xeL7YcssZhnkd.png"></p><p>经过 swagger 测试，发现没有任何问题。</p><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><p>在上一章，我们利用 Nacos 实现了服务的治理，利用 RestTemplate 实现了服务的远程调用。但是远程调用的代码太复杂了：</p><p><img src="/post/e13c0f67/JegybnZSIoiH1YxEEJOcCSVQncd.png"></p><p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到 OpenFeign 组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign 就利用 SpringMVC 的相关注解来声明上述 4 个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><p>接下来，我们就通过一个快速入门的案例来体验一下 OpenFeign 的便捷吧。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>我们还是以 cart-service 中的查询我的购物车为例。因此下面的操作都是在 cart-service 中进行。</p><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在 <code>cart-service</code> 服务的 pom.xml 中引入 <code>OpenFeign</code> 的依赖和 <code>loadBalancer</code> 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启用-OpenFeign"><a href="#启用-OpenFeign" class="headerlink" title="启用 OpenFeign"></a>启用 OpenFeign</h3><p>接下来，我们在 <code>cart-service</code> 的 <code>CartApplication</code> 启动类上添加注解，启动 OpenFeign 功能：</p><p><img src="/post/e13c0f67/JsglbS4nDo9xFuxKbPBcLbDnn1f.png"></p><h3 id="编写-OpenFeign-客户端"><a href="#编写-OpenFeign-客户端" class="headerlink" title="编写 OpenFeign 客户端"></a>编写 OpenFeign 客户端</h3><p>在 <code>cart-service</code> 中，定义一个新的接口，编写 Feign 客户端：</p><p>其中代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.dto.ItemDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient(&quot;item-service&quot;)</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;/items&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign 就可以利用动态代理帮我们实现这个方法，并且向 <code>http://item-service/items</code> 发送一个 <code>GET</code> 请求，携带 ids 为请求参数，并自动将返回值处理为 <code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h3 id="使用-FeignClient"><a href="#使用-FeignClient" class="headerlink" title="使用 FeignClient"></a>使用 FeignClient</h3><p>最后，我们在 <code>cart-service</code> 的 <code>com.hmall.cart.service.impl.CartServiceImpl</code> 中改造代码，直接调用 <code>ItemClient</code> 的方法：</p><p><img src="/post/e13c0f67/Hk7XbAcd8o7g8KxyTYhcECs2nsf.png"></p><p>feign 替我们完成了服务拉取、负载均衡、发送 http 请求的所有工作，是不是看起来优雅多了。</p><p>而且，这里我们不再需要 RestTemplate 了，还省去了 RestTemplate 的注册。</p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层支持的 http 客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的 HttpURLConnection。比如，我们使用 OK Http.</p><h3 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在 <code>cart-service</code> 的 <code>pom.xml</code> 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启连接池"><a href="#开启连接池" class="headerlink" title="开启连接池"></a>开启连接池</h3><p>在 <code>cart-service</code> 的 <code>application.yml</code> 配置文件中开启 Feign 的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><p>重启服务，连接池就生效了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>我们可以打断点验证连接池是否生效，在 <code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code> 中的 <code>execute</code> 方法中打断点：</p><p><img src="/post/e13c0f67/Mktsb2k8Io1tgZxrBfacEGXPnEf.png"></p><p>Debug 方式启动 cart-service，请求一次查询我的购物车方法，进入断点：</p><p><img src="/post/e13c0f67/LHk6bXmxfoxzs1x6oUFcdgInnsh.png"></p><p>可以发现这里底层的实现已经改为 <code>OkHttpClient</code></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>将来我们要把与下单有关的业务抽取为一个独立微服务:<code>trade-service</code>，不过我们先来看一下 <code>hm-service</code> 中原本与下单有关的业务逻辑。</p><p>入口在 <code>com.hmall.controller.OrderController</code> 的 <code>createOrder</code> 方法，然后调用了 <code>IOrderService</code> 中的 <code>createOrder</code> 方法。</p><p>由于下单时前端提交了商品 id，为了计算订单总价，需要查询商品信息：</p><p><img src="/post/e13c0f67/CZnybhZ6JocGY4xGjmOcjlAOnMd.png"></p><p>也就是说，如果拆分了交易微服务（<code>trade-service</code>），它也需要远程调用 <code>item-service</code> 中的根据 id 批量查询商品功能。这个需求与 <code>cart-service</code> 中是一样的。</p><p>因此，我们就需要在 <code>trade-service</code> 中再次定义 <code>ItemClient</code> 接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>相信大家都能想到，避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p><ul><li>思路 1：抽取到微服务之外的公共 module</li><li>思路 2：每个微服务自己抽取一个 module</li></ul><p>如图：</p><p><img src="/post/e13c0f67/Ol77bM8FboZf7dxh4yvcNYTAnQh.jpeg"></p><p>方案 1 抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方案 2 抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><p>由于 item-service 已经创建好，无法继续拆分，因此这里我们采用方案 1.</p><h3 id="抽取-Feign-客户端"><a href="#抽取-Feign-客户端" class="headerlink" title="抽取 Feign 客户端"></a>抽取 Feign 客户端</h3><p>在 <code>hmall</code> 下定义一个新的 module，命名为 hm-api</p><p><img src="/post/e13c0f67/DYjDbC29voxH2ox0zxEcSsTGnJe.png"></p><p>其依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--open feign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- load balancer--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- swagger 注解依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把 ItemDTO 和 ItemClient 都拷贝过来，最终结构如下：</p><p><img src="/post/e13c0f67/LalGbIXsloExXbxKjc1ccP1PnGb.png"></p><p>现在，任何微服务要调用 <code>item-service</code> 中的接口，只需要引入 <code>hm-api</code> 模块依赖即可，无需自己编写 Feign 客户端了。</p><h3 id="扫描包"><a href="#扫描包" class="headerlink" title="扫描包"></a>扫描包</h3><p>接下来，我们在 <code>cart-service</code> 的 <code>pom.xml</code> 中引入 <code>hm-api</code> 模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--feign模块--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除 <code>cart-service</code> 中原来的 ItemDTO 和 ItemClient，重启项目，发现报错了：</p><p><img src="/post/e13c0f67/JxTpbn4Pgoasl9x6YLbcVSNHnXe.png"></p><p>这里因为 <code>ItemClient</code> 现在定义到了 <code>com.hmall.api.client</code> 包下，而 cart-service 的启动类定义在 <code>com.hmall.cart</code> 包下，扫描不到 <code>ItemClient</code>，所以报错了。</p><p>解决办法很简单，在 cart-service 的启动类上添加声明即可，两种方式：</p><ul><li>方式 1：声明扫描包：</li></ul><p><img src="/post/e13c0f67/HHGtblxUaorotaxo3p4cLkFsnEc.png"></p><ul><li>方式 2：声明要用的 FeignClient</li></ul><p><img src="/post/e13c0f67/Ne49bVSuho9Jcvx2CNycOwI2nyg.png"></p><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>OpenFeign 只会在 FeignClient 所在包的日志级别为 <strong>DEBUG</strong> 时，才会输出日志。而且其日志级别有 4 级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL 以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在 BASIC 的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>Feign 默认的日志级别就是 NONE，所以默认我们看不到请求日志。</p><h3 id="定义日志级别"><a href="#定义日志级别" class="headerlink" title="定义日志级别"></a>定义日志级别</h3><p>在 hm-api 模块下新建一个配置类，定义 Feign 的日志级别：</p><p><img src="/post/e13c0f67/P3tfbZBB7od5W2xYPbncOkiUnvd.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>接下来，要让日志级别生效，还需要配置这个类。有两种方式：</p><ul><li><strong>局部</strong>生效：在某个 <code>FeignClient</code> 中配置，只对当前 <code>FeignClient</code> 生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><ul><li><strong>全局</strong>生效：在 <code>@EnableFeignClients</code> 中配置，针对所有 <code>FeignClient</code> 生效。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><p>日志格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; GET http://item-service/items?ids=100000006163 HTTP/1.1</span><br><span class="line">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; END HTTP (0-byte body)</span><br><span class="line">17:35:32:278 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- HTTP/1.1 200  (127ms)</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] connection: keep-alive</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] content-type: application/json</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] date: Fri, 26 May 2023 09:35:32 GMT</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] keep-alive: timeout=60</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] transfer-encoding: chunked</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] </span><br><span class="line">17:35:32:280 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] [&#123;&quot;id&quot;:100000006163,&quot;name&quot;:&quot;巴布豆(BOBDOG)柔薄悦动婴儿拉拉裤XXL码80片(15kg以上)&quot;,&quot;price&quot;:67100,&quot;stock&quot;:10000,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t23998/350/2363990466/222391/a6e9581d/5b7cba5bN0c18fb4f.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉拉裤&quot;,&quot;brand&quot;:&quot;巴布豆&quot;,&quot;spec&quot;:&quot;&#123;&#125;&quot;,&quot;sold&quot;:11,&quot;commentCount&quot;:33343434,&quot;isAD&quot;:false,&quot;status&quot;:2&#125;]</span><br><span class="line">17:35:32:281 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- END HTTP (369-byte body)</span><br></pre></td></tr></table></figure><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="拆分微服务"><a href="#拆分微服务" class="headerlink" title="拆分微服务"></a>拆分微服务</h2><p>将 hm-service 中的其它业务也都拆分为微服务，包括：</p><ul><li>user-service：用户微服务，包含用户登录、管理等功能</li><li>trade-service：交易微服务，包含订单相关功能</li><li>pay-service：支付微服务，包含支付相关功能</li></ul><p>其中交易服务、支付服务、用户服务中的业务都需要知道当前登录用户是谁，目前暂未实现，先将用户 id 写死。</p><p><strong>思考</strong>：如何才能在每个微服务中都拿到用户信息？如何在微服务之间传递用户信息？</p><h2 id="定义-FeignClient"><a href="#定义-FeignClient" class="headerlink" title="定义 FeignClient"></a>定义 FeignClient</h2><p>在上述业务中，包含大量的微服务调用，将被调用的接口全部定义为 FeignClient，将其与对应的 DTO 放在 hm-api 模块</p><h2 id="将微服务与前端联调"><a href="#将微服务与前端联调" class="headerlink" title="将微服务与前端联调"></a>将微服务与前端联调</h2><p>课前资料提供了一个 <code>hmall-nginx</code> 目录，其中包含了 Nginx 以及我们的前端代码：</p><p><img src="/post/e13c0f67/GWv1bekgyoi2csxYRYpcX4V7nXd.png"></p><p>将其拷贝到一个不包含中文、空格、特殊字符的目录，启动后即可访问到页面：</p><ul><li>18080 是用户端页面</li><li>18081 是管理端页面</li></ul><p>之前 <code>nginx</code> 内部会将发向服务端请求全部代理到 8080 端口，但是现在拆分了 N 个微服务，8080 不可用了。请通过 <code>Nginx</code> 配置，完成对不同微服务的反向代理。</p><p><strong>认真思考这种方式存在哪些问题</strong>，<strong>有什么好的解决方案</strong>？</p>]]></content>
    
    
    <summary type="html">微服务学习笔记1</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="Java" scheme="https://threewood1.top/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://threewood1.top/tags/SpringBoot/"/>
    
    <category term="Microservice Architecture" scheme="https://threewood1.top/tags/Microservice-Architecture/"/>
    
    <category term="SpringCloud" scheme="https://threewood1.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习</title>
    <link href="https://threewood1.top/post/6782be63.html"/>
    <id>https://threewood1.top/post/6782be63.html</id>
    <published>2024-01-04T06:48:27.000Z</published>
    <updated>2024-01-04T07:01:01.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>要想让 Docker 帮我们安装和部署软件，肯定要保证你的机器上有 Docker. 由于大家的操作系统各不相同，安装方式也不同。为了便于大家学习，我们统一在 CentOS 的虚拟机中安装 Docker，统一学习环境。</p><p>安装方式参考文档：《安装 Docker》</p><h2 id="部署-MySQL"><a href="#部署-MySQL" class="headerlink" title="部署 MySQL"></a>部署 MySQL</h2><p>首先，我们利用 Docker 来安装一个 MySQL 软件，大家可以对比一下之前传统的安装方式，看看哪个效率更高一些。</p><p>如果是利用传统方式部署 MySQL，大概的步骤有：</p><ul><li>搜索并下载 MySQL 安装包</li><li>上传至 Linux 环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用 Docker 安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用 CV 大法）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>运行效果如图：</p><p><img src="/post/6782be63/UxK2beI0ros8O1xf2IJcWMvQnVb.png"></p><p>MySQL 安装完毕！通过任意客户端工具即可连接到 MySQL.</p><p>大家可以发现，当我们执行命令后，Docker 做的第一件事情，是去自动搜索并下载了 MySQL，然后会自动运行 MySQL，我们完全不用插手，是不是非常方便。</p><p>而且，这种安装方式你完全不用考虑运行的操作系统环境，它不仅仅在 CentOS 系统是这样，在 Ubuntu 系统、macOS 系统、甚至是装了 WSL 的 Windows 下，都可以使用这条命令来安装 MySQL。</p><p>要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p><p>而使用 Docker，这些完全不用考虑。就是因为 Docker 会自动搜索并下载 MySQL。注意：这里下载的不是安装包，而是<strong>镜像。</strong>镜像中不仅包含了 MySQL 本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p><p>说明：</p><ul><li>镜像：英文是 image</li><li>容器：英文是 container</li></ul><p>Docker 会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</p><p>Docker 官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker 官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了 Docker 镜像交流的社区：</p><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p>像这种提供存储、管理 Docker 镜像的服务器，被称为 DockerRegistry，可以翻译为镜像仓库。DockerHub 网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库。</p><p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。而企业内部的机密项目，往往会采用私有镜像仓库。</p><p>总之，镜像的来源有两种：</p><ul><li>基于官方基础镜像自己制作</li><li>直接去 DockerRegistry 下载</li></ul><p>用一幅图标示如下：</p><h2 id="命令解读"><a href="#命令解读" class="headerlink" title="命令解读"></a>命令解读</h2><p>利用 Docker 快速的安装了 MySQL，非常的方便，不过我们执行的命令到底是什么意思呢？</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><blockquote><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code> 则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫 <code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将<strong><strong>宿主机</strong></strong>端口****映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如 MySQL 进程默认端口是 3306，因此容器内端口一定是 3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的 3306 映射到容器内的 3306 端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY 和 VALUE 都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code> 是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code> 是设置 MySQL 默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker 会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如 <code>mysql:8.0</code>，其中 <code>REPOSITORY</code> 可以理解为镜像名，<code>TAG</code> 是版本号</li><li>在未指定 <code>TAG</code> 的情况下，默认是最新版本，也就是 <code>mysql:latest</code></li></ul></li></ul></blockquote><p>镜像的名称不是随意的，而是要到 DockerRegistry 中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在 DockerHub 网站或者软件的官方网站中都能找到。</p><p>如果我们要安装其它软件，也可以到 DockerRegistry 中寻找对应的镜像名称和版本，阅读相关配置即可。</p><h1 id="Docker-基础"><a href="#Docker-基础" class="headerlink" title="Docker 基础"></a>Docker 基础</h1><p>接下来，我们一起来学习 Docker 使用的一些基础知识，为将来部署项目打下基础。具体用法可以参考 Docker 官方文档：</p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p>首先我们来学习 Docker 中的常见命令，可以参考官方文档：</p><h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><p>其中，比较常见的命令有：</p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker pull</td><td>拉取镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td>docker push</td><td>推送镜像到 DockerRegistry</td><td><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td>docker images</td><td>查看本地镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td>docker rmi</td><td>删除本地镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td>docker run</td><td>创建并运行容器（不能重复创建）</td><td><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td>docker stop</td><td>停止指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td>docker start</td><td>启动指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td>docker restart</td><td>重新启动容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td>docker rm</td><td>删除指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td>docker ps</td><td>查看容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td>docker logs</td><td>查看容器运行日志</td><td><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td>docker exec</td><td>进入容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td>docker save</td><td>保存镜像到本地压缩文件</td><td><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td>docker load</td><td>加载本地压缩文件到镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td>docker inspect</td><td>查看容器详细信息</td><td><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p>用一副图来表示这些命令的关系：</p><p>补充：</p><p>默认情况下，每次重启虚拟机我们都需要手动启动 Docker 和 Docker 中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>教学环节说明：我们以 Nginx 为例给大家演示上述命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">_REPOSITORY   TAG       IMAGE ID       CREATED         SIZE_</span><br><span class="line">_nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB_</span><br><span class="line">_mysql        latest    <span class="number">3218</span>b38490ce   <span class="number">17</span> months ago   <span class="number">516</span>MB_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>给常用 Docker 命令起别名，方便我们访问：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">_alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span>_</span><br><span class="line">_alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span>_</span><br><span class="line">_alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span>_</span><br><span class="line">_alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span>_</span><br><span class="line">_alias dis=<span class="string">&#x27;docker images&#x27;</span>_</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line">_if [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then_</span><br><span class="line">_        . /etc/bashrc_</span><br><span class="line">_fi_</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><p>接下来，试试看新的命令吧。</p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p><ul><li>如果要升级 MySQL 版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx 容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让 Nginx 代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器****解耦</strong>。</p><h3 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机****目录</strong>之间映射的桥梁。</p><p>以 Nginx 为例，我们知道 Nginx 中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果我们要让 Nginx 代理我们的静态资源，最好是放到 <code>html</code> 目录；如果我们要修改 Nginx 的配置，最好是找到 <code>conf</code> 下的 <code>nginx.conf</code> 文件。</p><p>但遗憾的是，容器运行的 Nginx 所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx 容器内部的 <code>conf</code> 目录和 <code>html</code> 目录分别与两个数据卷关联。</li><li>而数据卷 conf 和 html 分别指向了宿主机的 <code>/var/lib/docker/volumes/conf/_data</code> 目录和 <code>/var/lib/docker/volumes/html/_data</code> 目录</li></ul><p>这样以来，容器内的 <code>conf</code> 和 <code>html</code> 目录就 与宿主机的 <code>conf</code> 和 <code>html</code> 目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的 <code>/var/lib/docker/volumes/html/_data</code> 就是在操作容器内的 <code>/usr/share/nginx/html/_data</code> 目录。只要我们将静态资源放入宿主机对应目录，就可以被 Nginx 代理了。</p><h3 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h3><p>数据卷的相关命令有：</p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker volume create</td><td>创建数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td>docker volume ls</td><td>查看所有数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td>docker volume prune</td><td>清除数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><p>教学<strong>演示环节</strong>：演示一下 nginx 的 html 目录挂载</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_DRIVER    VOLUME NAME_</span><br><span class="line">_local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f_</span><br><span class="line">_local     html_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_[<span class="type">_</span></span><br><span class="line"><span class="type">_</span>    &#123;<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,<span class="type">_</span></span><br><span class="line"><span class="type">_</span>        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span><span class="type">_</span></span><br><span class="line"><span class="type">_</span>    &#125;<span class="type">_</span></span><br><span class="line"><span class="type">_</span>]_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">_总用量 __8_</span><br><span class="line">_<span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html_</span><br><span class="line">_<span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><p>教学<strong>演示环节</strong>：演示一下 MySQL 的匿名数据卷</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看MySQL容器详细信息</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 关注其中.Config.Volumes部分和.Mounts部分</span></span><br></pre></td></tr></table></figure><p>我们关注两部分内容，第一是 <code>.Config.Volumes</code> 部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;/var/lib/mysql&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>。这就是匿名卷。</p><p>然后，我们再看结果中的 <code>.Mounts</code> 部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现，其中有几个关键属性：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串 hash 值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul><p>上述配置是将容器内的 <code>/var/lib/mysql</code> 这个目录，与数据卷 <code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code> 挂载。于是在宿主机中就有了 <code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code> 这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><p>接下来，可以查看该目录下的 MySQL 的 data 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</span><br></pre></td></tr></table></figure><p>注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考 DockerHub 对应的页面</p><h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code> 开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><p><strong>教学演示</strong>，删除并重新创建 mysql 容器，并完成本地目录挂载：</p><ul><li>挂载 <code>/root/mysql/data</code> 到容器内的 <code>/var/lib/mysql</code> 目录</li><li>挂载 <code>/root/mysql/init</code> 到容器内的 <code>/docker-entrypoint-initdb.d</code> 目录（初始化的 SQL 脚本目录）</li><li>挂载 <code>/root/mysql/conf</code> 到容器内的 <code>/etc/mysql/conf.d</code> 目录（这个是 MySQL 配置文件目录）</li></ul><p>在课前资料中已经准备好了 mysql 的 <code>init</code> 目录和 <code>conf</code> 目录：</p><p><img src="/post/6782be63/KPD5btJQ1oYNJ0x4Dqnc7AjCn7g.png"></p><p>以及对应的初始化 SQL 脚本和配置文件：</p><p><img src="/post/6782be63/MC3Xb7gcYo3IAix5wHMcfdImnKd.png"></p><p><img src="/post/6782be63/TWpQbXl6wod9pVxc0iRctpCinUh.png"></p><p>其中，hm.cnf 主要是配置了 MySQL 的默认编码，改为 utf8mb4；而 hmall.sql 则是后面我们要用到的黑马商城项目的初始化 SQL 脚本。</p><p>我们直接将整个 mysql 目录上传至虚拟机的 <code>/root</code> 目录下：</p><p><img src="/post/6782be63/PZNBbbpDEoK1fCxI0ygcXbUfnGb.png"></p><p>接下来，我们演示本地目录挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.删除原来的MySQL容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行新mysql容器，挂载本地目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span></span><br><span class="line"><span class="built_in">ls</span> -l mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">_总用量 4_</span><br><span class="line">_drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf_</span><br><span class="line">_drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data_</span><br><span class="line">_drwxr-xr-x. 2 root    root   23 5月  19 15:11 init_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span></span><br><span class="line"><span class="built_in">ls</span> -l data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看MySQL容器内数据</span></span><br><span class="line"><span class="comment"># 5.1.进入MySQL</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123</span><br><span class="line"><span class="comment"># 5.2.查看编码表</span></span><br><span class="line">show variables like <span class="string">&quot;%char%&quot;</span>;</span><br><span class="line"><span class="comment"># 5.3.结果，发现编码是utf8mb4没有问题</span></span><br><span class="line">_+--------------------------+--------------------------------+_</span><br><span class="line">_| Variable_name            | Value                          |_</span><br><span class="line">_+--------------------------+--------------------------------+_</span><br><span class="line">_| character_set_client     | utf8mb4                        |_</span><br><span class="line">_| character_set_connection | utf8mb4                        |_</span><br><span class="line">_| character_set_database   | utf8mb4                        |_</span><br><span class="line">_| character_set_filesystem | binary                         |_</span><br><span class="line">_| character_set_results    | utf8mb4                        |_</span><br><span class="line">_| character_set_server     | utf8mb4                        |_</span><br><span class="line">_| character_set_system     | utf8mb3                        |_</span><br><span class="line">_| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |_</span><br><span class="line">+--------------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看数据</span></span><br><span class="line"><span class="comment"># 6.1.查看数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="comment"># 结果，hmall是黑马商城数据库</span></span><br><span class="line">_+--------------------+_</span><br><span class="line">_| Database           |_</span><br><span class="line">_+--------------------+_</span><br><span class="line">_| hmall              |_</span><br><span class="line">_| information_schema |_</span><br><span class="line">_| mysql              |_</span><br><span class="line">_| performance_schema |_</span><br><span class="line">_| sys                |_</span><br><span class="line">_+--------------------+_</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment"># 6.2.切换到hmall数据库</span></span><br><span class="line">use hmall;</span><br><span class="line"><span class="comment"># 6.3.查看表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">_+-----------------+_</span><br><span class="line">_| Tables_in_hmall |_</span><br><span class="line">_+-----------------+_</span><br><span class="line">_| address         |_</span><br><span class="line">_| cart            |_</span><br><span class="line">_| item            |_</span><br><span class="line">_| order           |_</span><br><span class="line">_| order_detail    |_</span><br><span class="line">_| order_logistics |_</span><br><span class="line">_| pay_order       |_</span><br><span class="line">_| user            |_</span><br><span class="line">_+-----------------+_</span><br><span class="line"><span class="comment"># 6.4.查看address表数据</span></span><br><span class="line">_+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+_</span><br><span class="line">_| <span class="built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |_</span><br><span class="line">_+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+_</span><br><span class="line">_| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |_</span><br><span class="line">_| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |_</span><br><span class="line">_| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |_</span><br><span class="line">_| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |_</span><br><span class="line">_+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+_</span><br><span class="line">_4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)_</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个 Java 项目，把它打包为一个镜像该怎么做呢？</p><h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h3><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从 0 部署一个 Java 应用，大概流程是这样：</p><ul><li>准备一个 linux 服务（CentOS 或者 Ubuntu 均可）</li><li>安装并配置 JDK</li><li>上传 Jar 包</li><li>运行 jar 包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备 Linux 运行环境（java 项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置 JDK</li><li>拷贝 jar 包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一 id，称为 <strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的 Linux 运行环境，通用性就很强，所以 Docker 官方就制作了这样的只包含 Linux 运行环境的镜像。我们在制作 java 镜像时，就无需重复制作，直接使用 Docker 官方提供的 CentOS 或 Ubuntu 镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个 Java 项目的镜像结构如图所示：</p><p><img src="/post/6782be63/HMEkbXMRyoVCY9xk7Kec3QqunOd.png"></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以 Docker 就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给 Docker 去执行即可。</p><p>而这种记录镜像结构的文件就称为 <strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td>指定基础镜像</td><td><code>FROM centos:6</code></td></tr><tr><td><strong>ENV</strong></td><td>设置环境变量，可在后面指令使用</td><td><code>ENV key value</code></td></tr><tr><td><strong>COPY</strong></td><td>拷贝本地文件到镜像的指定目录</td><td><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td><strong>RUN</strong></td><td>执行 Linux 的 shell 命令，一般是安装过程的命令</td><td><code>RUN yum install gcc</code></td></tr><tr><td><strong>EXPOSE</strong></td><td>指定容器运行时监听的端口，是给镜像使用者看的</td><td>EXPOSE 8080</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td>镜像中应用的启动命令，容器运行时调用</td><td>ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于 Ubuntu 镜像来构建一个 Java 应用，其 Dockerfile 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>同学们思考一下：以后我们会有很多很多 java 项目需要打包为镜像，他们都需要 Linux 系统环境、JDK 环境这两层，只有上面的 3 层不同（因为 jar 包不同）。如果每次制作 java 镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加 JDK 环境，我们在此基础上制作 java 镜像，就可以省去 JDK 的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>是不是简单多了。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>当 Dockerfile 文件写好以后，就可以利用命令来构建镜像了。</p><p>在课前资料中，我们准备好了一个 demo 项目及对应的 Dockerfile：</p><p><img src="/post/6782be63/IaXXbRyruofsyqxkXy3cuJBinuf.png"></p><p>首先，我们将课前资料提供的 <code>docker-demo.jar</code> 包以及 <code>Dockerfile</code> 拷贝到虚拟机的 <code>/root/demo</code> 目录：</p><p><img src="/post/6782be63/DaNxbwN84o7mElx7p48cQSSSnre.png"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p><code>docker build </code>: 就是构建一个 docker 镜像</p></li><li><p><code>-t docker-demo:1.0</code> ：<code>-t</code> 参数是指定镜像的名称（<code>repository</code> 和 <code>tag</code>）</p></li><li><p><code>.</code> : 最后的点是指构建时 Dockerfile 所在路径，由于我们进入了 demo 目录，所以指定的是 <code>.</code> 代表当前目录，也可以直接指定 Dockerfile 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接指定 Dockerfile 目录</span></span><br><span class="line"></span><br><span class="line">docker build -t docker-demo:1.0 /root/demo</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![](dockerLearning/GDj2bsx1soD4yux7xKZcWpz1nhe.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>查看镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看镜像列表：</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_REPOSITORY    TAG       IMAGE ID       CREATED          SIZE_</span><br><span class="line">_docker-demo   1.0       d6ab0b9e64b9   27 minutes ago   327MB_</span><br><span class="line">_nginx         latest    605c77e624dd   16 months ago    141MB_</span><br><span class="line">_mysql         latest    3218b38490ce   17 months ago    516MB_</span><br></pre></td></tr></table></figure><p>然后尝试运行该镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run -d --name <span class="built_in">dd</span> -p 8090:8090 docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">dps</span><br><span class="line">_<span class="comment"># 结果_</span></span><br><span class="line">_CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES_</span><br><span class="line">_78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   dd_</span><br><span class="line">_f63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">curl localhost:8080/hello/count</span><br><span class="line">_<span class="comment"># 结果：_</span></span><br><span class="line">_&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;_</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>上节课我们创建了一个 Java 项目的容器，而 Java 项目往往需要访问其它各种中间件，例如 MySQL、Redis 等。现在，我们的容器之间能否互相访问呢？我们来测试一下</p><p>首先，我们查看下 MySQL 容器的详细信息，重点关注其中的网络 IP 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 也可以使用format过滤结果</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mysql</span><br><span class="line"><span class="comment"># 得到IP地址如下：</span></span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后通过命令进入dd容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在容器内，通过ping命令测试网络</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line">_<span class="comment"># 结果_</span></span><br><span class="line">_PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data._</span><br><span class="line">_64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms_</span><br><span class="line">_64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms_</span><br><span class="line">_64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms_</span><br></pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络 IP 其实是一个虚拟的 IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个 IP，而在部署时很可能 MySQL 容器的 IP 会发生变化，连接会失败。</p><p>所以，我们必须借助于 docker 的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker network create</td><td>创建一个网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td>docker network ls</td><td>查看所有网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td>docker network rm</td><td>删除指定网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td>docker network prune</td><td>清除未使用的网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td>docker network connect</td><td>使指定容器连接加入某网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td>docker network disconnect</td><td>使指定容器连接离开某网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td>docker network inspect</td><td>查看网络详细信息</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><p>教学演示：自定义网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">_NETWORK ID     NAME      DRIVER    SCOPE_</span><br><span class="line">_639bc44d0a87   bridge    bridge    local_</span><br><span class="line">_403f16ec62a2   hmall     bridge    local_</span><br><span class="line">_0dc0f72a0fbb   host      host      local_</span><br><span class="line">_cd8d3e8df47b   none      null      local_</span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_PING db (172.18.0.2) 56(84) bytes of data._</span><br><span class="line">_64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms_</span><br><span class="line">_64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms_</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">_PING mysql (172.18.0.2) 56(84) bytes of data._</span><br><span class="line">_64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms_</span><br><span class="line">_64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms_</span><br></pre></td></tr></table></figure><p>OK，现在无需记住 IP 地址也可以实现容器互联了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><p>好了，我们已经熟悉了 Docker 的基本用法，接下来可以尝试部署项目了。</p><p>在课前资料中已经提供了一个黑马商城项目给大家，如图：</p><p>项目说明：</p><ul><li>hmall：商城的后端代码</li><li>hmall-portal：商城用户端的前端代码</li><li>hmall-admin：商城管理端的前端代码</li></ul><p>部署的容器及端口说明：</p><table><thead><tr><th><strong>项目</strong></th><th><strong>容器名</strong></th><th><strong>端口</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>hmall</td><td>hmall</td><td>8080</td><td>黑马商城后端 API 入口</td></tr><tr><td>hmall-portal</td><td>nginx</td><td>18080</td><td>黑马商城用户端入口</td></tr><tr><td>hmall-admin</td><td></td><td>18081</td><td>黑马商城管理端入口</td></tr><tr><td>mysql</td><td>mysql</td><td>3306</td><td>数据库</td></tr></tbody></table><p>在正式部署前，我们先删除之前的 nginx、dd 两个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f nginx <span class="built_in">dd</span></span><br></pre></td></tr></table></figure><p>mysql 容器中已经准备好了商城的数据，所以就不再删除了。</p><h2 id="部署-Java-项目"><a href="#部署-Java-项目" class="headerlink" title="部署 Java 项目"></a>部署 Java 项目</h2><p><code>hmall</code> 项目是一个 maven 聚合项目，使用 IDEA 打开 <code>hmall</code> 项目，查看项目结构如图：</p><p><img src="/post/6782be63/V7MybuaHiojLOWxslgHcoKLUn5g.png"></p><p>我们要部署的就是其中的 <code>hm-service</code>，其中的配置文件采用了多环境的方式：</p><p><img src="/post/6782be63/VNT8b35FPoLTRDxUVCCcnajInqg.png"></p><p>其中的 <code>application-dev.yaml</code> 是部署到开发环境的配置，<code>application-local.yaml</code> 是本地运行时的配置。</p><p>查看 application.yaml，你会发现其中的 JDBC 地址并未写死，而是读取变量：</p><p><img src="/post/6782be63/IyBgbEaacoUfNixEyF1c5jrFnvb.png"></p><p>这两个变量在 <code>application-dev.yaml</code> 和 <code>application-local.yaml</code> 中并不相同：</p><p><img src="/post/6782be63/OtehbBAzWoqbmLxa1G3cHR0ZnZe.png"></p><p>在 dev 开发环境（也就是 Docker 部署时）采用了 mysql 作为地址，刚好是我们的 mysql 容器名，只要两者在一个网络，就一定能互相访问。</p><p>我们将项目打包：</p><p><img src="/post/6782be63/LxmKbKFQSoa2LPxlzspcBVylned.png"></p><p>结果：</p><p><img src="/post/6782be63/AXBFbYXBBoAUqsxp0QEcTrHynYg.png"></p><p>将 <code>hm-service</code> 目录下的 <code>Dockerfile</code> 和 <code>hm-service/target</code> 目录下的 <code>hm-service.jar</code> 一起上传到虚拟机的 <code>root</code> 目录：</p><p><img src="/post/6782be63/PcgLb31fAo4qonxi2wJcIi6pnEc.png"></p><p>部署项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.构建项目镜像，不指定tag，则默认为latest</span></span><br><span class="line">docker build -t hmall .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_REPOSITORY    TAG       IMAGE ID       CREATED          SIZE_</span><br><span class="line">_hmall         latest    0bb07b2c34b9   43 seconds ago   362MB_</span><br><span class="line">_docker-demo   1.0       49743484da68   24 hours ago     327MB_</span><br><span class="line">_nginx         latest    605c77e624dd   16 months ago    141MB_</span><br><span class="line">_mysql         latest    3218b38490ce   17 months ago    516MB_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行容器，并通过--network将其加入hmall网络，这样才能通过容器名访问mysql</span></span><br><span class="line">docker run -d --name hmall --network hmall -p 8080:8080 hmall</span><br></pre></td></tr></table></figure><p>测试，通过浏览器访问：http:&#x2F;&#x2F;你的虚拟机地址:8080&#x2F;search&#x2F;list</p><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><p><code>hmall-portal</code> 和 <code>hmall-admin</code> 是前端代码，需要基于 nginx 部署。在课前资料中已经给大家提供了 nginx 的部署目录：</p><p><img src="/post/6782be63/XTnPbyODZo7C8DxMr9ccwBGgnOh.png"></p><p>其中：</p><ul><li><code>html</code> 是静态资源目录，我们需要把 <code>hmall-portal</code> 以及 <code>hmall-admin</code> 都复制进去</li><li><code>nginx.conf</code> 是 nginx 的配置文件，主要是完成对 <code>html</code> 下的两个静态资源目录做代理</li></ul><p>我们现在要做的就是把整个 nginx 目录上传到虚拟机的 <code>/root</code> 目录下：</p><p><img src="/post/6782be63/WGLnbPIkJoHNslx6tnDctAvKnpf.png"></p><p>然后创建 nginx 容器并完成两个挂载：</p><ul><li>把 <code>/root/nginx/nginx.conf</code> 挂载到 <code>/etc/nginx/nginx.conf</code></li><li>把 <code>/root/nginx/html</code> 挂载到 <code>/usr/share/nginx/html</code></li></ul><p>由于需要让 nginx 同时代理 hmall-portal 和 hmall-admin 两套前端资源，因此我们需要暴露两个端口：</p><ul><li>18080：对应 hmall-portal</li><li>18081：对应 hmall-admin</li></ul><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 18080:18080 \</span><br><span class="line">  -p 18081:18081 \</span><br><span class="line">  -v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  --network hmall \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p>测试，通过浏览器访问：http:&#x2F;&#x2F;你的虚拟机 ip:18080</p><p><img src="/post/6782be63/TnmSbedFgoj4K2xUR4RcfkIbnof.png"></p><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>大家可以看到，我们部署一个简单的 java 项目，其中包含 3 个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java 项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止 3 个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而 Docker Compose 就可以帮助我们实现<strong>多个相互关联的 Docker 容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>docker-compose.yml 文件的基本语法可以参考官方文档：</p><p>docker-compose 文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于 service 就是在定义某个应用的运行时参数，因此与 <code>docker run</code> 参数非常相似。</p><p>举例来说，用 docker run 部署 MySQL 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用 <code>docker-compose.yml</code> 文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th><strong>docker run 参数</strong></th><th><strong>docker compose 指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>–name</td><td>container_name</td><td>容器名称</td></tr><tr><td>-p</td><td>ports</td><td>端口映射</td></tr><tr><td>-e</td><td>environment</td><td>环境变量</td></tr><tr><td>-v</td><td>volumes</td><td>数据卷配置</td></tr><tr><td>–network</td><td>networks</td><td>网络</td></tr></tbody></table><p>明白了其中的对应关系，相信编写 <code>docker-compose</code> 文件应该难不倒大家。</p><p>黑马商城部署文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>编写好 docker-compose.yml 文件，就可以部署项目了。常见的命令：</p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS 和 COMMAND 都是可选参数，比较常见的有：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>参数或指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Options</td><td>-f</td><td>指定 compose 文件的路径和名称</td></tr><tr><td></td><td>-p</td><td>指定 project 名称。project 就是当前 compose 文件中设置的多个 service 的集合，是逻辑概念</td></tr><tr><td>Commands</td><td>up</td><td>创建并启动所有 service 容器</td></tr><tr><td></td><td>down</td><td>停止并移除所有容器、网络</td></tr><tr><td></td><td>ps</td><td>列出所有启动的容器</td></tr><tr><td></td><td>logs</td><td>查看指定容器的日志</td></tr><tr><td></td><td>stop</td><td>停止容器</td></tr><tr><td></td><td>start</td><td>启动容器</td></tr><tr><td></td><td>restart</td><td>重启容器</td></tr><tr><td></td><td>top</td><td>查看运行的进程</td></tr><tr><td></td><td>exec</td><td>在指定的运行中容器中执行命令</td></tr></tbody></table><p>教学演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">_[+] Building 15.5s (8/8) FINISHED_</span><br><span class="line">_ =&gt; [internal] load build definition from Dockerfile                                    0.0s_</span><br><span class="line">_ =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s_</span><br><span class="line">_ =&gt; [internal] load .dockerignore                                                       0.0s_</span><br><span class="line">_ =&gt; =&gt; transferring context: 2B                                                         0.0s_</span><br><span class="line">_ =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s_</span><br><span class="line">_ =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s_</span><br><span class="line">_ =&gt; [internal] load build context                                                       0.0s_</span><br><span class="line">_ =&gt; =&gt; transferring context: 98B                                                        0.0s_</span><br><span class="line">_ =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s_</span><br><span class="line">_ =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s_</span><br><span class="line">_ =&gt; exporting to image                                                                  0.0s_</span><br><span class="line">_ =&gt; =&gt; exporting layers                                                                 0.0s_</span><br><span class="line">_ =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s_</span><br><span class="line">_ =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s_</span><br><span class="line">_[+] Running 4/4_</span><br><span class="line">_ ✔ Network hmall    Created                                                             0.2s_</span><br><span class="line">_ ✔ Container mysql  Started                                                             0.5s_</span><br><span class="line">_ ✔ Container hmall  Started                                                             0.9s_</span><br><span class="line">_ ✔ Container nginx  Started     _                                                        1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE_</span><br><span class="line">_hmall               root-hmall          latest              32eebee16acd        362MB_</span><br><span class="line">_mysql               mysql               latest              3218b38490ce        516MB_</span><br><span class="line">_nginx               nginx               latest              605c77e624dd        141MB_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">_NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS_</span><br><span class="line">_hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp_</span><br><span class="line">_mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp_</span><br><span class="line">_nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp_</span><br></pre></td></tr></table></figure><p>打开浏览器，访问：<a href="http://yourip:8080/">http://yourIp:8080</a></p>]]></content>
    
    
    <summary type="html">Docker学习笔记</summary>
    
    
    
    <category term="Learning" scheme="https://threewood1.top/categories/Learning/"/>
    
    
    <category term="Docker" scheme="https://threewood1.top/tags/Docker/"/>
    
  </entry>
  
</feed>
