<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>面试八股 | Threewood</title><meta name="author" content="三木,959335709@qq.com"><meta name="copyright" content="三木"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常见面试问题"><meta property="og:type" content="article"><meta property="og:title" content="面试八股"><meta property="og:url" content="https://threewood1.top/post/f4c4d599.html"><meta property="og:site_name" content="Threewood"><meta property="og:description" content="常见面试问题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png"><meta property="article:published_time" content="2024-07-09T05:18:17.000Z"><meta property="article:modified_time" content="2024-09-03T11:44:20.956Z"><meta property="article:author" content="三木"><meta property="article:tag" content="Java"><meta property="article:tag" content="Interviews"><meta property="article:tag" content="MySQL"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png"><link rel="shortcut icon" href="/img/paw-solid.svg"><link rel="canonical" href="https://threewood1.top/post/f4c4d599.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media=&quot;all&quot;"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 三木","link":"链接: ","source":"来源: Threewood","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试八股",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-09-03 19:44:20"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/font.css"><script src="/live2d-widget/autoload.js"></script></head><body><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Threewood" type="application/atom+xml"><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myPic.png" onerror="onerror=null,src=&quot;/img/friend_404.gif&quot;" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-area-chart"></i><span> 相冊/壁紙</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> ToU:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/HTML/Eluvletter/index.html"><i class="fa-fw fas fa-envelope"></i><span> Eluvletter</span></a></li><li><a class="site-page child" href="/HTML/LoveTime/index.html"><i class="fa-fw fas fa-heart"></i><span> LoveTime</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png)"><nav id="nav"><span id="blog-info"><a href="/" title="Threewood"><span class="site-name">Threewood</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-area-chart"></i><span> 相冊/壁紙</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> ToU:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/HTML/Eluvletter/index.html"><i class="fa-fw fas fa-envelope"></i><span> Eluvletter</span></a></li><li><a class="site-page child" href="/HTML/LoveTime/index.html"><i class="fa-fw fas fa-heart"></i><span> LoveTime</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-09T05:18:17.000Z" title="发表于 2024-07-09 13:18:17">2024-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-03T11:44:20.956Z" title="更新于 2024-09-03 19:44:20">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面试八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url(https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png);"></div><article class="post-content" id="article-container"><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="Day1√"><a href="#Day1√" class="headerlink" title="Day1√"></a>Day1√</h3><p><strong>String、StringBuffer、StringBuilder的区别？</strong>**</p><p>这三者的区别主要集中在不可变性、线程安全和性能方面。</p><ol><li>String是<strong>不可变且线程安全</strong>的，因为String类型的字符串一旦创建就不可修改，因此，String类型的字符串是线程安全的，可以由多个线程同时调用，但是一旦对它有修改操作则会创建新的字符串对象，这会影响性能；</li><li>StringBuffer是<strong>可变且线程安全</strong>的，它在修改时是在同一对象上进行的，不会创建新的对象；因为StringBuffer的方法是<strong>同步</strong>的，所以它在使用时是线程安全的。由此可见StringBuffer适用于<strong>多线程</strong>环境，在单线程环境中使用会产生额外的性能开销；</li><li>StringBuilder是<strong>可变但线程不安全</strong>的，它的方法没有同步，因此线程不安全，适用于<strong>单线程</strong>环境的字符串操作。</li></ol><p>总之，String适用于不经常修改字符串的情况，StringBuffer和StringBuilder适用于经常修改的情况，并且要根据是否需要线程安全以及性能考量来选择。</p><p><strong>接口和抽象类的区别？</strong>**</p><p><strong>相同点：都不能直接被实例化，需要继承或实现后才能使用</strong></p><p><strong>不同点：</strong></p><ol><li>从<strong>定义</strong>上说：接⼝是⼀种抽象类型，它定义了⼀组方法（方法签名）但没有实现任何⽅法的具体代码。接口中的方法默认是抽象的，且接口中只能包含常量（static final变量）和抽象方法。抽象类是⼀个类，可以包含抽象方法和具体方法。抽象类中的抽象方法是没有实现的方法，而具体方法则包含实现代码。</li><li><strong>定义的关键字不同</strong>：定义的关键字不同(abstract/Interface)，子类继承或实现的关键字也不同(extends/implements)。</li><li><strong>类型扩展不同</strong>：抽象类是单继承，而接口是多实现。</li><li><strong>构造器</strong>：接口没有构造器，抽象类可以有构造器，当子类实例化时，会调用父类的构造器。</li><li><strong>访问修饰符</strong>：接口中的方法默认是public abstract，变量默认是public static final；抽象类中的抽象方法默认是protected，并且不能被private修饰。</li></ol><p><strong>Java常见的异常类有哪些？</strong>**</p><p>Java的异常类主要分为两大类：Error 和 Exception。Error表示程序无法处理的异常，通常是由JVM或底层系统引起的，如<strong>内存溢出</strong>或<strong>系统错误</strong>，而Exception则表示程序可以处理的异常，通常由程序员编写的代码引起的，并且可以通过异常处理机制捕获和处理。</p><p>Exception又分为两种主要类型：</p><ol><li><strong>Checked Exception（受检异常）</strong>：是指在<strong>编译时</strong>必须进行处理的异常。如果有一个方法抛出这类异常，则要么在方法类使用<strong>try-catch块</strong>捕获，要么在方法签名中使用<strong>throws关键字</strong>声明该异常。常见的Checked Exception包括<strong>IOException、SQLException</strong>、ClassNotFoundException、InterruptException等。</li><li><strong>Unchecked Exception（非受检异常，也称运行时异常）</strong>：是指在编译时不需要进行处理的异常，他们通常是由<strong>程序的逻辑错误</strong>引起的。例如<strong>NullPointerException</strong>、<strong>ArrayIndexOutOfBoundsException</strong>等。</li></ol><h3 id="Day2√"><a href="#Day2√" class="headerlink" title="Day2√"></a>Day2√</h3><p><strong>说一说Java面向对象三大特性？</strong>***</p><ol><li><strong>封装</strong>：指隐藏对象的内部细节，封装将对象内部状态（字段、属性）隐藏起来，并通过定义公共的方法（接口）来操作对象，外部代码只需要知道如何使用这些方法而无需了解内部实现，提高了代码的<strong>安全性</strong>和<strong>可维护性</strong>。</li><li><strong>继承</strong>：是一种通过已有的类（父类）创建新类（子类）的方式。子类可以继承父类的属性和方法，并且可以通过重写父类的方法来改变或扩展其行为，提高了代码的<strong>可重用性</strong>和<strong>可扩展性</strong>。</li><li><strong>多态</strong>：是指相同的操作或方法可以在不同的对象上产生不同的行为，通过方法的<strong>重载</strong>和<strong>重写</strong>来实现，提高了代码的<strong>灵活性</strong>。</li></ol><p><strong>说一说你对Java多态的理解？</strong>**</p><p>多态有两种形式：编译时多态和运行时多态。</p><ol><li><strong>编译时多态</strong>也称为静态多态，是通过方法的<strong>重载</strong>实现。编译器在编译时根据方法的签名（方法名和参数列表）来选择调用合适的方法。</li><li><strong>运行时多态</strong>也称为动态多态，是通过方法的<strong>重写</strong>实现。在运行时，通过对象的实际类型来确定调用的方法。</li></ol><p><strong>重写和重载的区别？</strong>**</p><p>重写和重载都是实现多态的方式，其中，<strong>重写是运行时多态，重载是编译时多态</strong>。</p><ol><li>重写发生在子类和父类之间，重写要求子类重写的方法与父类被重写的方法具有相同的参数列表（即参数类型、数量、顺序相同）和相同的返回类型。</li><li>重载是指在一个类中定义多个同名方法，这些方法的参数列表不同，返回类型可以相同也可以不相同。</li></ol><h3 id="Day3√"><a href="#Day3√" class="headerlink" title="Day3√"></a>Day3√</h3><p><strong>static和final的作用？</strong>**</p><ol><li><strong>static</strong>用于声明<strong>静态成员</strong>，即<strong>静态变量和方法</strong>。其中静态变量属于类而不属于实例对象，所有实例对象都共享相同的静态变量。静态方法也一样，属于类，可以通过类名直接调用而不需要创建类的实例。</li><li><strong>final</strong>用于修饰<strong>不可改变的变量、方法和类</strong>。对于变量，一旦赋值后就不可修改；对于方法，表示不可被子类重写；对于类，表示该类不能被继承。</li></ol><p><strong>java 中 == 和 equals() 的区别？</strong>**</p><ol><li><strong>“==”运算符</strong>是比较两个对象的引用（内存地址），即检查它们是否指向相同的内存地址。</li><li>**equals()**通常用于比较两个对象的内容。默认情况下equals()也是比较对象的引用，但是很多类都重写了这个方法以比较对象的内容。</li></ol><p><strong>为什么重写equals()时也要重写hashcode()方法？</strong>***</p><p>因为原始的equals()是比较两个对象的引用，但是我们经常用它比较两个对象是否一样，所以通常需要重写equals()。hashcode()方法返回的是对象的<strong>哈希码值</strong>，用于确定对象在哈希表中的<strong>存储位置</strong>。在集合类中，如果两个对象被认为是相等的，那么它们的哈希码应该相同。但是哈希码相等的两个对象不一定相等。遵守以下规定：</p><ol><li><strong>两个对象是相等的，即equals()返回为true，那么它们的哈希码也一定相同；</strong></li><li><strong>两个对象的哈希码相同，但这两个对象不一定相等。</strong></li></ol><h3 id="Day4√"><a href="#Day4√" class="headerlink" title="Day4√"></a>Day4√</h3><p><strong>Java的集合类有哪些，哪些是线程安全的，哪些是线程不安全的？</strong>***</p><p>Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection又派生出Set、List、Queue这三个子接口。所有Java集合类都是Set、List、Queue、Map这四个接口的实现类。其中，</p><p><strong>List接口</strong>：有序集合，允许重复元素。常见实现类有<strong>ArrayList、LinkedList、Vector</strong>等；</p><p><strong>Set接口</strong>：不允许重复元素的集合。常见实现类有<strong>HashSet、LinkedHashSet、TreeSet</strong>等；</p><p><strong>Queue接口</strong>：表示队列的数据结构。常见的实现类有<strong>LinckedList、PriorityQueue</strong>等；</p><p><strong>Map接口</strong>：表示键值对的集合。常见实现类有<strong>HashMap、LinkedHashMap、TreeMap、Hashtable</strong>等。</p><p><strong>线程安全的集合</strong>包括Vector、Hashtable、ConcurrentHashMap、Collections.synchronizedList、Collections.synchronizedSet 、Collections.synchronizedMap<strong>。</strong></p><p><strong>ArrayList 和 Array 有什么区别？</strong>***</p><ol><li><strong>大小和自动扩容</strong></li></ol><ul><li>Array数组在创建时必须指定大小，且大小是固定的。一旦数组被创建，其大小不能更改；</li><li>ArrayList是动态数组实现的，它的大小可以动态增长或缩小。在不断添加元素时，ArrayList 会自动进行扩容。</li></ul><ol start="2"><li><strong>支持泛型</strong></li></ol><ul><li>Array数组可以存储任何类型的元素，但不支持泛型；</li><li>ArrayList支持泛型，也可以指定存储的元素类型。</li></ul><ol start="3"><li><strong>存储对象</strong></li></ol><ul><li>Array数组可以直接存储基本类型数据，也可以存储对象；</li><li>ArrayList中只能存储对象。对于基本类型数据，需要使用其对应的包装类。</li></ul><ol start="4"><li><strong>集合功能</strong></li></ol><ul><li>Array数组是一个简单的数据结构，不提供额外的方法来对元素进行增删查改操作；</li><li>ArrayList是集合框架的一部分，提供了丰富的方法，如添加、删除、查找等。</li></ul><p><strong>ArrayList 和 LinkedList 的区别是什么?</strong>***</p><ol><li><strong>内部数据结构</strong></li></ol><ul><li>ArrayList基于动态数组实现；</li><li>LinkedList基于双向链表实现。</li></ul><ol start="2"><li><strong>遍历性能</strong></li></ol><ul><li>ArrayList支持快速的随机访问和遍历，因为可以直接通过索引访问元素；</li><li>LinkedList随机访问性能较差，因为必须从链表的头部或尾部开始遍历寻找目标索引。</li></ul><ol start="3"><li><strong>插入和删除</strong></li></ol><ul><li>ArrayList在末尾进行插入和删除操作是高效的，但在中间或开头插入和删除需要移动元素，性能较差。</li><li>LinkedList插入和删除元素的性能相对较好，特别是在链表中间或头尾插入和删除元素时。</li></ul><ol start="4"><li><strong>使用场景</strong></li></ol><ul><li>ArrayList适用于需要频繁随机访问元素，而对插入和删除操作要求不那么严格的场景。</li><li>LinkedList适用于需要频繁插入和删除操作，而对随机访问的需求较少的场景。</li></ul><p><strong>ArrayList的扩容机制？</strong>***</p><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。(不是原数组，而是新数组然后给予数组对象地址)。</p><p>默认情况下，<strong>新的容量会是原容量的1.5倍</strong>。新容量=旧容量右移一位(相当于除于2)在加上旧容量</p><p>ArrayList 的底层是用动态数组来实现的。我们初始化一个ArrayList 集合并且没有指定容量时，其实它是个空数组，只有当我们添加第一个元素时，会<strong>初始化容量为10</strong>。当添加第11个元素时，便开始可以扩容了，新数组大小是旧数组的1.5倍，然后将旧数组的元素copy到新数组中，最后将ArrayList内部指向旧数组的引用更新为指向新数组的引用。</p><h3 id="Day5√"><a href="#Day5√" class="headerlink" title="Day5√"></a>Day5√</h3><p><strong>Java中的HashMap了解吗？HashMap 的底层实现是什么？</strong>***</p><p>在Java中，HashMap是Map接口的实现类，其数据是以键值对的形式存储，Key只允许有一个null值，value可以有多个null值；是线程不安全的。</p><p>在JDK1.8之前HashMap底层是由<strong>数组+链表</strong>的形式构成的；JDK1.8之后，底层是由<strong>数组+链表/红黑树</strong>构成的。</p><p><strong>解决 Hash 冲突的方法有哪些？HashMap 是如何解决 hash 冲突的？</strong>***</p><p>解决hash冲突一般有<strong>开放定址法、链地址法、再哈希法、建立公共溢出区，</strong>其中HashMap使用链地址法解决哈希冲突。具体如下：</p><ol><li><strong>开放定址法：</strong>遇到hash冲突时，去寻找一个新的且空闲的哈希地址。寻找新的位置有以下几种方法：</li></ol><ol><li><p><strong>线性探测</strong>：当发生冲突时，线性地检查下一个槽位直到找到空闲地位置。（问题：会出现元素堆积现象）</p></li><li><p><strong>二次探测：</strong>与线性探测法不同的是每次增加的步长为平方数，以减少聚集现象。</p></li><li><p><strong>双重哈希：</strong>第一个哈希函数计算原始哈希值，使用第二个哈希函数来计算增量步长。发生冲突时，使用第 一个哈希函数计算得到的值加上第二个哈希函数得到的步长来计算下一个探测位置。</p></li><li><p><strong>随机探测：</strong>使用随机的方式选择下一个探测位置。</p></li></ol><blockquote><p>二次探测的计算公式：<font style="color:#2c2c36">(</font><em><font style="color:#2c2c36">h</font></em><font style="color:#2c2c36">1(</font><em><font style="color:#2c2c36">key</font></em><font style="color:#2c2c36">)+</font><em><font style="color:#2c2c36">i</font></em><font style="color:#2c2c36">⋅</font><em><font style="color:#2c2c36">i</font></em><font style="color:#2c2c36">) mod </font><em><font style="color:#2c2c36">M</font></em></p><p>双重哈希的计算公式：<font style="color:#2c2c36">(</font><em><font style="color:#2c2c36">h</font></em><font style="color:#2c2c36">1(</font><em><font style="color:#2c2c36">key</font></em><font style="color:#2c2c36">)+</font><em><font style="color:#2c2c36">i</font></em><font style="color:#2c2c36">⋅</font><em><font style="color:#2c2c36">h</font></em><font style="color:#2c2c36">2(</font><em><font style="color:#2c2c36">key</font></em><font style="color:#2c2c36">)) mod </font><em><font style="color:#2c2c36">M</font></em><font style="color:#2c2c36">，其中</font><em><font style="color:#2c2c36">M</font></em><font style="color:#2c2c36"> 是哈希表的大小，</font><em><font style="color:#2c2c36">i</font></em><font style="color:#2c2c36"> 是冲突次数。</font></p></blockquote><ol start="2"><li><strong>再哈希法：</strong>构造多个不同的哈希函数，当发生冲突时就是用第二个、第三个。。。直到不发生冲突为止。</li><li><strong>链地址法：</strong>将所有哈希地址相同的元素都连接在一条链表中。</li><li><strong>建立公共溢出区：</strong>将哈希表分为基本表和溢出表，将发生哈希冲突的元素都放在溢出表中。</li></ol><p><strong>HashMap 的 put 方法流程？</strong>***</p><p>首先使用键所在类的hashCode()方法计算键的哈希码，然后对该哈希码进行扰动处理以减少哈希冲突的可能性。然后使用哈希码和当前哈希表的长度计算键值应该放入的位置。如果该位置为空，那么就创建一个新的键值对节点将元素放在此处。如果不为空，就需要遍历该位置上的链表，检查要插入的键是否已经存在。如果要插入的键存在，就修改键对应的值；如果要插入的键不存在，就在链表的末尾添加新的键值对节点。</p><p><strong>HashMap的扩容机制？</strong>***</p><p>HashMap的扩容机制在jdk1.8的前后有些许不同。</p><p>** jdk1.8 之前要满足以下两个条件：**</p><ol><li>存放新值的时候当前已有的元素个数必须大于等于一个阈值，该阈值等于当前table的容量 * 负载因子，初始化时table的长度为16，负载因子为0.75，那么阈值就是12。</li><li>存放新值的时候发生哈希碰撞。</li></ol><p>特点：先判断扩容，再添加（扩容使用头插法）</p><p><strong>jdk1.8之后满足以下条件之一：</strong></p><ol><li>当前存储的数量大于等于阈值。</li><li>当某个链表长度 &gt;= 8，但是数组的长度 &lt; 64时。</li></ol><p>特点：先添加，再判断扩容（扩容使用尾插法）</p><p><strong>扩容之后对table的调整：</strong></p><p>扩容会创建一个新的数组，长度为原来的<strong>两倍</strong>。然后重新计算元素的位置并插入。</p><blockquote><p>链表与红黑树相互转换的条件：</p><p>链表转红黑树：某个链表长度 &gt; 8，且HashMap的数组长度 &gt;= 64。</p><p>红黑树转链表：1. 扩容resize()时，红黑树拆分成的树的节点数 &lt;= 6 个，则退化成链表。2. 删除元素remove()时，如果红黑树根节点root为空，或者root的左/右子树为空，root.left.left为空，都会发生红黑树退化成链表。</p></blockquote><h3 id="Day6√"><a href="#Day6√" class="headerlink" title="Day6√"></a>Day6√</h3><p><strong>HashMap 为什么是线程不安全的？如何实现线程安全？</strong>***</p><p>主要原因是它的操作不是原子的，在多线程环境下，可能出现数据不一致的情况。</p><p>实现线程安全的HashMap，有以下几种方式：</p><ol><li><font style="color:#333">使用Hashtable代替Hashmap。</font></li><li><font style="color:#333">使用Map map = </font><strong><font style="color:#333">Collections.synchronizedMap</font></strong><font style="color:#333">(new HashMap());</font></li><li><strong><font style="color:#333">使用ConcurrentHashmap。</font></strong></li></ol><p><font style="color:#333">在jdk1.8之前使用的是分段锁，它将哈希表分成多个段，每个段都有自己的锁。</font></p><p><font style="color:#333">在jdk1.8之后，ConcurrentHashMap通过CAS+synchronized实现线程安全，相比分段锁，锁的粒度更小。</font></p><ol start="4"><li><font style="color:#333">使用</font><strong><font style="color:#333">ReentrantLock</font></strong><font style="color:#333">锁来保证线程安全。</font></li></ol><p><strong>concurrentHashMap 如何保证线程安全？</strong>**</p><p><font style="color:#333">在jdk1.8之前使用的是</font><strong><font style="color:#333">分段锁</font></strong><font style="color:#333">，它将哈希表分成多个段（Segment数组），每个段都由一个ReetrantLock保护，默认Segment数组长度为16，这意味着最多可以支持16个线程并发写。</font></p><p><font style="color:#333">在jdk1.8之后，ConcurrentHashMap通过</font><strong><font style="color:#333">Node + CAS + synchronized</font></strong><font style="color:#333">实现线程安全，synchronized 只锁定当前链表或红黑树的首节点，相比分段锁，锁的粒度更小。</font></p><p><strong>HashMap和ConcurrentHashMap的区别？</strong>**</p><ol><li>HashMap不是线程安全的，而ConcurrentHashMap是线程安全的；</li><li>HashMap适用于单线程环境，不需要考虑同步操作；ConcurrentHashMap适用于多线程环境。</li></ol><h3 id="Day7√"><a href="#Day7√" class="headerlink" title="Day7√"></a>Day7√</h3><p><strong>HashSet 和 HashMap 的区别？</strong>**</p><ol><li><strong>实现接口：</strong>HashSet实现Set接口，HashMap实现Map接口；</li><li><strong>存储类型：</strong>HashSet存储无序不重复的元素，HashMap存储无序不重复的键值对；</li><li><strong>实现方式：</strong>HashSet底层使用HashMap实现，HashSet中的每个元素之际上都是HashMap的一个键，每个键映射的值为一个Object类型的静态对象，名为<code>PRESENT</code>。</li></ol><p><strong>HashMap 和 HashTable 的区别？</strong>**</p><ol><li><strong>线程安全：</strong>HashMap线程不安全。Hashtable是线程安全的，因为它在每个方法上添加 synchronized 关键字保证每个操作都是同步的。</li><li><strong>是否支持 null：</strong>HashMap允许一个键和任意数量的值为为null<strong>。</strong>而Hashtable不允许键或值为null。</li><li><strong>性能：</strong>HashMap因为没有同步开销，在单线程环境中性能更好。尽管Hashtable是同步的，但由于实现的效率低下，它在多线程环境下性能也可能比HashMap底。</li><li><strong>继承关系：</strong>HashMap继承自AbstractMap类，而Hashtable继承自Dictionary类，但它们都实现了Map接口。</li><li><strong>初始容量和扩容大小：</strong>HashMap初始容量为16，每次扩容都为原来的2倍；Hashtable初始容量为11，每次扩容都为原来的2倍+1。</li><li>迭代器：HashMap使用Iterator迭代器，Hashtable使用Enumerator迭代器，后者在迭代时如果Hashtable被修改，会抛出ConcurrentModificationException异常。</li></ol><p><strong>浅拷贝和深拷贝的区别？</strong>**</p><ul><li><strong>浅拷贝</strong>是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。</li><li><strong><font style="color:#010101">深拷贝</font></strong><font style="color:#010101">是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</font></li></ul><h3 id="Day8√"><a href="#Day8√" class="headerlink" title="Day8√"></a>Day8√</h3><p><strong>Java创建线程的方式？</strong>***</p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！ (qq.com)</a></p><ol><li><strong>继承自Thread类：</strong>创建一个新的类，该类继承Thread类，然后重写run()方法定义要执行的任务，最后调用start()方法启动线程。</li><li><strong>实现Runnable接口：</strong>创建一个新的类，该类实现Runnable接口，然后重写run()方法，最后创建Thread对象时传递Runnable实例，并调用start()方法。</li><li><strong>实现Callable接口：</strong>创建一个新的类，该类实现 Callable 接口，实现 call()方法以定义线程要执行的任务，使用 ExecutorService 和 Future 来获取任务的结果。</li><li><strong>使用ExecutorService线程池</strong></li><li><strong>使用CompletableFuture类</strong></li></ol><p><strong>总结：这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。严格来说，Java 就只有一种方式可以创建线程，那就是通过new Thread().start()创建。不管是哪种方式，最终还是依赖于new Thread().start()。</strong></p><p><strong>线程 start 和 run 的区别？</strong>**</p><ul><li>start()方法用于启动一个新线程，并且会在新线程中执行run()方法的代码。</li><li>run()方法只是普通的方法调用，不会启动新线程，而是直接在当前线程中执行 run() 方法的内容。</li></ul><h3 id="Day9√"><a href="#Day9√" class="headerlink" title="Day9√"></a>Day9√</h3><p><strong>线程间的通信方式有些？</strong>***</p><p>线程间的通信方式主要有两种，分别是<strong>共享变量</strong>和<strong>消息传递</strong>。详细如下：</p><ol><li><strong>共享变量</strong>：通过共享变量（volatile修饰的变量），多个线程可以访问和修改同一个对象的状态。这种方法要求保证对共享变量的访问是线程安全的，通常通过同步（synchronized）代码块或方法来实现。</li><li><strong>消息传递</strong>：通过Object类的wait()、notify()、notifyAll()方法实现等待/通知机制。这些方法必须在同步代码块或方法中调用，以确保对共享资源的访问是线程安全的。</li><li><strong>ReentrantLock和Condition</strong>：ReenTrantLock锁的实现原理虽然和synchronized不同，但是它和synchronized一样都是<strong>通过建立线程间的互斥访问临界区</strong>，来保证线程安全，实现线程间的通信。相比于synchronized使用Object类的三个方法来实现线程的阻塞和运行两个状态的切换，ReentrantLock使用Condition阻塞队列的await()、signal()、signalAll()三个方法来实现线程阻塞和运行两个状态的切换，进而实现线程间的通信。</li></ol><p><strong>你知道Java中有哪些锁吗？</strong>***</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coderacademy/p/18093724"><strong>阿里二面：Java中锁的分类有哪些？你能说全吗？ - 码农Academy - 博客园 (cnblogs.com)</strong></a></p><p><img src="/post/f4c4d599/1723792877398-faa03987-3963-45c0-bdfc-7138e6a1ac04.jpeg"></p><ol><li><strong>基于锁的获取与释放方式可以分为显示锁和隐式锁</strong></li></ol><ul><li>隐式锁：是通过synchronized关键字实现的一种线程同步机制。当一个线程进入被synchronized修饰的方法或代码块时，它会自动获得对象级别的锁，退出该方法或代码块时则会自动释放这把锁。</li><li>显示锁：显式锁是由 java.util.concurrent.locks.Lock 接口及其诸多实现类提供的同步机制，相较于通过synchronized关键字实现的隐式锁机制，显式锁提供了更为多样化的锁操作选项，包括但不限于支持线程在等待锁时可被中断、根据先后顺序分配锁资源的公平锁与非*<em><strong>公平锁机制，以及能够设定锁获取等待时间的定时锁功能。</strong>常见的显示锁有ReentrantLock、ReentrantReadWriteLock、StampedLock等。</em>*</li></ul><ol start="2"><li><strong>基于对资源的访问权限可以分为独占锁和共享锁</strong></li></ol><ul><li>独占锁：又称为<strong>排他锁或写锁</strong>，它确保在任一时刻最多只有一个线程可以获得锁并对受保护的资源进行访问或修改。独占锁可以通过synchronized关键字或ReentrantLock实现。</li><li>共享锁：也成为<strong>读锁</strong>，允许多个线程同时读取共享资源，但不允许任何线程修改资源。可通过读写锁（ReadWriteLock）中的读锁实现。</li></ul><ol start="3"><li><strong>基于锁的占有权是否可重入分为可重入锁和非可重入锁</strong></li></ol><ul><li>可重入锁：又称为<strong>递归锁</strong>，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁，从而避免了在递归调用或嵌套同步块中产生的死锁风险。其中synchronized实现的隐式锁和ReentrantLock都是可重入锁。</li><li>不可重入锁：与可重入锁相反。</li></ul><ol start="4"><li><strong>基于锁的公平性可以分为公平锁和非公平锁</strong></li></ol><ul><li>公平锁：在多线程环境中，锁的分配遵循“先请求先服务”的原则，即按照线程请求锁的顺序分配锁资源。公平锁可以有效避免某个线程长期得不到锁而导致的饥饿现象。在实现时可以通过向ReentrantLock中传入true参数获得。</li><li>非公平锁：与公平锁相反，不遵循“先请求先服务”的原则。非公平锁在某些场景下可以提高系统的并发性能，因为它允许刚释放锁的线程或者其他新到达的线程立刻获取锁，而不是强制排队等待，避免了线程切换的开销和等待时间。在实现时可以通过向ReentrantLock中传入false参数获得。</li></ul><ol start="5"><li><strong>基于对共享资源的访问方式可以分为悲观锁和乐观锁</strong></li></ol><ul><li>悲观锁：悲观锁认为在多线程环境下对共享资源的访问极有可能发生冲突，因此在访问资源之前，先尝试获取锁并锁定资源，直到该线程完成对资源的访问并释放锁，其他线程才能继续访问。</li><li>乐观锁：乐观锁认为在访问数据时，不会有其他线程来修改该数据。因此，乐观锁在操作数据的时候不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。乐观锁通过CAS算法实现。</li></ul><p>因此，悲观锁适合写操作较多且读操作较少的并发场景，乐观锁适用于读多写少的场景或者并发较少的场景。</p><ol start="6"><li><strong>基于锁的升级以及优化可分为偏向锁、轻量级锁和重量级锁</strong></li></ol><ul><li>偏向锁：偏向锁是指⼀段同步代码⼀直被⼀个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li><li>轻量级锁：轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁：重量级锁是指当锁为轻量级锁的时候，另⼀个线程虽然是自旋，但自旋不会⼀直持续下去，当自旋⼀定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><ol start="7"><li><strong>自旋锁：</strong>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，该线程不会进入阻塞状态，而是不断循环检查锁是否已经被释放，直到获取到锁为止。</li><li><strong>分段锁：</strong>是一种将数据或资源划分为多个段（segments），并对每个段分配单独锁的锁机制，可以减少锁的粒度从而减少锁冲突。在jdk1.8之前的ConcurrentHashMap就是使用分段锁来保证自身的线程安全。</li></ol><p><strong>说说你对 synchronized 的理解？</strong>***</p><p>synchronized关键字是Java中的一种同步锁，主要用于多线程环境下保证线程的安全性。当一个方法或一个代码块被synchronized修饰时，它被称为<strong>同步方法</strong>或<strong>同步代码块</strong>。这意味着每次只有一个线程可以进入该方法或代码块，其他线程必须等待，直到当前线程执行完毕并释放锁。synchronized具有<strong>原子性、可见性、有序性和可重入性</strong>。</p><hr><h3 id="Day10√"><a href="#Day10√" class="headerlink" title="Day10√"></a>Day10√</h3><p><strong>synchronized 和 Lock 的区别是什么？</strong>**</p><p>synchronized和Lock都是Java中用于实现线程同步的机制，都可以保证线程安全。它们的区别主要如下：</p><ol><li><strong>来源不同：</strong>synchronized是Java内置的一个关键字，而Lock是一个接口，它下面有很多实现类，例如ReentrantLock就是它的一个实现类。</li><li><strong>用法和获取方式不同：</strong></li></ol><ul><li><strong>synchronized</strong>可以写在需要同步的对象、方法或者是特定代的码块中，是隐式获取锁。主要有两种用法，一种是把synchronized修饰在方法上，一种是把synchronized修饰在代码块上。</li><li><strong>Lock</strong>控制锁的粒度是通过lock()方法和unlock()方法来实现的，是显示地获取锁，这两个方法之间地代码是线程安全的。</li></ul><p>由此可见，Lock比synchronized在使用上相对来说要更加灵活一些。Lock可以自主地去决定什么时候加锁，什么时候释放锁。只需要调用lock()和unlock()这两个方法就可以了。需要注意的是，为了避免死锁，一般我们<strong>unlock()方法写在finally块中</strong>，而synchronized只有代码块执行结束或者代码抛出异常时才会释放锁。</p><ol start="3"><li><strong>性能区别：</strong>在低并发情况下，synchronized 的性能优于 Lock，因为 Lock 需要显式地获取和释放锁，而 synchronized 是在 JVM 层面实现的；在高并发的情况下，Lock 的性能要远远优于 synchronized，因为 Lock 可以更好地支持高并发和读写分离的场景。</li><li><strong>使用场景不同：</strong>synchronized和Lock在一般情况下没有什么区别，但是在非常复杂的同步应用中，建议使用Lock。因为synchronized只提供了非公平锁的实现，而Lock提供了公平所和非公平锁的机制。</li></ol><blockquote><p><strong>公平锁</strong>是指线程竞争锁资源的时候，如果已经有其他线程正在排队或者等待锁释放，那么当前竞争锁的线程是无法去插队的。</p><p><strong>非公平锁</strong>就是不管是否线程再排队等待锁，它都会去尝试竞争一次锁。</p></blockquote><p><strong>synchronized 和 ReentrantLock 的区别是什么？</strong>**</p><p>在Java中，synchronized（内置锁）和 ReentrantLock（可重入锁）是两种常用的锁。它们的区别如下：</p><ol><li>用法和获取方式不同：同上</li><li>锁的类型不同：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。</li><li>使用场景：同上</li><li>锁的灵活性：ReentrantLock相对于Synchronized提供了更多的功能。例如，可以设置超时时间，以避免线程无限期地等待锁；可以判断锁是否被其他线程持有，从而进行相应的处理；还可以使用Condition类实现线程等待/通知机制，以支持更复杂的并发控制。</li></ol><h3 id="Day11√"><a href="#Day11√" class="headerlink" title="Day11√"></a>Day11√</h3><p><strong>volatile 关键字的作用有哪些？</strong>***</p><p>volatile 是 Java 中的一个关键字，用于修饰变量，它的主要作用是保证变量在多线程环境下的<strong>可见性</strong>和<strong>禁止指令重排序</strong>，但它不保证原子性。</p><ul><li><strong>可见性</strong>：指当一个线程修改了一个被volatile关键字修饰的变量时，其他线程能立即看到修改的值。</li><li><strong>禁止指令重排序：</strong>指确保对volatile变量的读写操作不会被编译器或处理器随意重新排序，从而确保了程序执行的有序性。</li><li><strong>不保证原子性：</strong>volatile不保证操作的原子性。synchronized可以同时保证可见性和原子性。</li></ul><blockquote><ol><li>可见性（Visibility）</li></ol><ul><li>在多线程环境中，线程通常会将变量的值从主内存复制到自己的工作内存（CPU 缓存）中进行操作。如果一个线程修改了变量的值，但其他线程仍然从自己的工作内存中读取该变量的旧值，就会导致数据不一致的问题。</li><li>当一个变量被声明为 volatile 时，Java 内存模型确保该变量的所有读操作都会直接从主内存中读取，而写操作会直接写入主内存。因此，volatile 变量对所有线程都是可见的。</li></ul><ol start="2"><li>有序性（Ordering）</li></ol><ul><li>Java 内存模型允许编译器和处理器对指令进行重排序，以优化性能。但这种重排序可能导致线程间的执行顺序不一致，从而引发潜在的并发问题。</li><li>使用 volatile 修饰的变量可以禁止指令重排序。具体来说，Java 在 volatile 变量的读/写操作时会插入内存屏障（Memory Barrier），从而保证在 volatile 变量的操作前后的代码执行顺序不会被重排序。</li></ul></blockquote><p><strong>volatile 与 synchronized 的对比？</strong>**</p><ol><li><strong>机制与用途</strong></li></ol><ul><li>synchronized：它是Java的一个关键字，用于提供线程间的同步机制。当一个线程进入一个由synchronized修饰的代码块或方法时，它会获取一个监视器锁（monitor lock），这保证了同一时间只有一个线程可以执行这段代码。其主要用途是确保数据的一致性和线程安全性。</li><li>volatile：这是Java的一个关键字，用于修饰变量。volatile的主要作用是确保变量在多线程环境中的<strong>可见性和有序性</strong>，即当一个线程修改了一个volatile变量的值，其他线程能够立即看到这个修改。此外，它还可以<strong>防止指令重排序</strong>。但是，volatile并<strong>不能保证复合操作的原子性</strong>。</li></ul><ol start="2"><li><strong>原子性：</strong></li></ol><ul><li>synchronized：它可以保证被其修饰的代码块的原子性，即这段代码在执行过程中不会被其他线程打断。</li><li>volatile：只能保证单个读写操作的原子性，对于复合操作（如自增、自减等）则无法保证原子性。</li></ul><ol start="3"><li><strong>互斥性：</strong>synchronized：提供了互斥性，即同一时间只有一个线程可以执行被其修饰的代码块或方法。volatile：不提供互斥性，只是确保变量的可见性。</li><li><strong>性能：</strong>volatile通常比synchronized更轻量级，因为它不涉及锁的获取和释放。但是，这也意味着它提供的同步级别较低。</li></ol><p><strong>JDK8新特性？</strong>***</p><ol><li><strong>Lambda表达式：</strong>Lambda表达式是一个匿名函数，Java8允许把函数作为参数传递进方法中。</li><li><strong>Stream API：</strong>提供了一种处理集合数据流的方式，支持并行操作和链式调用，简化了集合数据的过滤、映射、排序等操作。它可以提高代码的可读性和简洁性。</li><li><strong>函数式接口：</strong>包含一个抽象方法的接口，可以使用<code>@FunctionalInterface</code>注解来明确表示它是一个函数式接口，这样就可以用lambda表达式或方法引用来实现。</li><li><strong>默认方法：</strong>在接口中允许定义具有具体实现的方法，从而解决了接口演化时向后兼容的问题。</li><li><strong>Optional类：</strong>用于防止空指针异常，提供了更好的空值处理方式，避免了NullPointerException。</li><li><strong>新的日期和时间API：</strong>包括<code>java.time</code>包，提供了一系列全新的日期、时间、时区以及持续时间的API，替代了旧的<code>java.util.Date</code>和<code>Calendar</code>类。</li></ol><h3 id="Day12√"><a href="#Day12√" class="headerlink" title="Day12√"></a>Day12√</h3><p><strong>什么是线程池？为什么需要线程池？</strong>**</p><p><strong>线程池（Thread Pool）</strong> 是一种管理和重用线程的机制，用于提高多线程应用程序的性能和效率。线程池在程序启动时创建一定数量的线程，将它们放入池中，并在需要时重复使用这些线程，而不是为每个任务都创建新线程。这有助于减少线程创建和销毁的开销，提高资源利用率，并且可以更好地控制并发线程数量。</p><ul><li><strong>降低资源消耗：</strong>通过重复利用已创建的线程<strong>减少线程创建和销毁造成的消耗</strong>。</li><li><strong>提高响应速度：</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性：</strong>线程池可以限制并发线程的数量，防止系统过载，提高系统稳定性。</li></ul><p><strong>常见的几种线程池：</strong></p><ol><li><strong>FixedThreadPool：固定大小的线程池</strong>，可控制线程最大并发数，超过核心线程数的任务将会进入队列排队等待执行，<strong>通常用于负载较重且稳定的场景</strong>。</li><li><strong>CacheThreadPoll： 可根据实际情况调整线程数量的线程池。</strong>线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</li><li><strong>SingleThreadExecutor：单线程的线程池</strong>，只有一个工作线程，保证所有任务按照提交顺序执行，常用于执行串行化任务或者需要顺序执行的任务。</li><li><strong>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池</strong>。</li></ol><p><strong>说一说线程池有哪些常用参数？</strong>**</p><ol><li><strong>corePoolSize（核心线程数）：线程池维护的最小线程数量，核心线程创建后不会被回收</strong>（注意：设置allowCoreThreadTimeout=true后，空闲的核心线程超过存活时间也会被回收）。大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收。</li><li><strong>maximumPoolSize（线程池最大线程数）：线程池允许创建的最大线程数量</strong>。当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。</li><li><strong>keepAliveTime（空闲线程存活时间）：当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收。</strong>可被回收的线程：设置allowCoreThreadTimeout=true的核心线程；大于核心线程数的线程（非核心线程）。</li><li><strong>unit（空闲线程存活时间单位）：keepAliveTime的时间单位。</strong></li><li><strong>workQueue（工作队列）：存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在工作队列，任务调度时再从队列中取出任务。</strong>它仅仅用来存放被execute()方法提交的Runnable任务。工作队列实现了BlockingQueue接口，常见的工作队列有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue。</li><li><strong>threadFactory（线程工厂）：创建线程的工厂，可以设定线程名、线程编号等。</strong></li><li><strong>handler（拒绝策略）：当线程池线程数已满，并且工作队列达到限制，新提交的任务使用拒绝策略处理。可以自定义拒绝策略，拒绝策略需要实现RejectedExecutionHandler接口。</strong></li></ol><p><strong>BIO、NIO、AIO 的区别？</strong>**</p><ol><li><strong>BIO：</strong>同步阻塞 I/O 模型中，当一个线程执行 I/O 操作时，它会被阻塞直到 I/O 操作完成。这会导致线程无法执行其他任务。</li></ol><p><strong>适用场景：</strong>适用于连接次数比较少、并发不高的场景，例如传统的 Socket 编程。</p><ol start="2"><li><strong>NIO：</strong>同步非阻塞 I/O 模型中，一个线程执行一个 I/O 操作时不会等待，而是继续执行其他任务，线程需要通过轮询（polling）或者选择器（Selector）来检查哪些连接已经准备好进行 I/O 操作。核心组件包括通道（Channel）、缓冲区（Buffer）和选择器（Selector）</li></ol><p><strong>适用场景：</strong>适用于高并发、连接次数比较多的场景。</p><blockquote><ul><li>Channel(通道)：通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</li><li>Buffer(缓冲区)：Buffer是一个对象，它包含一些要写入或者要读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</li><li>Selector(选择器)：选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</li></ul></blockquote><ol start="3"><li><strong>AIO：</strong>异步非阻塞 I/O 模型是在 NIO 上进一步发展的， 提供了异步操作的能力。在进行 I/O 操作时，可以注册一个回调函数，当IO操作完成时，系统会调用回调函数通知应用程序。</li></ol><p><strong>适用场景：</strong>适用于处理大量并发连接的场景，并且希望充分利用系统资源。</p><h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><p><strong>Java内存区域？</strong>**</p><p><strong>有哪些垃圾回收算法？</strong>***</p><p><strong>有哪些垃圾回收器？</strong>***</p><h3 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h3><p><strong>介绍一下什么是强引用、软引用、弱引用、虚引用？</strong>**</p><p><strong>类加载机制介绍一下？</strong>**</p><p><strong>双亲委派机制是什么？</strong>**</p><h3 id="Day14-5√"><a href="#Day14-5√" class="headerlink" title="Day14.5√"></a>Day14.5√</h3><p><strong>说一说你对Spring AOP的理解？</strong>**</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cy973071263/article/details/105429453">【Spring】面试官：谈一谈你对spring AOP的理解_spring 面试中,谈谈你对spring aop的理解-CSDN博客</a></p><p>AOP称为面向切面编程。AOP是一种编程思想，是对面向对象编程（OOP）的一种补充。传统OOP开发中的代码逻辑是自上而下的，而在开发过程会产生一些横切性的问题，例如事务管理、记录日志、权限控制等。这些横切性的问题和主业务逻辑关系不大，但是会散落到代码的各个部分，难以维护。AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。提到了代码的可重用性和可维护性。</p><p><strong>AOP实现</strong>的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和Cglib动态代理。如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</p><blockquote><p>这里顺带总结一下 AOP 关键术语（不理解也没关系，可以继续往下看）：</p><ul><li><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</li><li><strong>切面（Aspect）</strong>：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</li><li><strong>连接点（JoinPoint）</strong>：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</li><li><strong>通知（Advice）</strong>：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。</li><li><strong>切点（Pointcut）</strong>：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 <code>execution(* com.xyz.service..*(..))</code>匹配 <code>com.xyz.service</code> 包及其子包下的类或接口。</li><li><strong>织入（Weaving）</strong>：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（AspectJ）和运行期织入（AspectJ）。</li></ul></blockquote><p><strong>说一说你对 Spring中IOC的理解？</strong>***</p><p>IOC称为控制反转。IOC是一种设计思想，是指在开发中将设计好的对象交给容器管理，而不是传统的在对象内部直接控制，这样会大大降低代码的耦合性。有了IOC容器后，我们把创建和查找依赖对象的控制权交给容器，容器初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象进行依赖注入（DI）。</p><p>依赖注入的三种方式：</p><p><a target="_blank" rel="noopener" href="https://developer.baidu.com/article/details/3254022">Spring基础——深入理解依赖注入的三种方式-百度开发者中心 (baidu.com)</a></p><ol><li><strong>构造函数注入</strong></li></ol><p>构造函数注入是通过在类的构造函数中声明依赖项来实现的。当Spring容器创建对象时，它会使用构造函数参数来注入依赖项。这种方式被认为是最佳实践，因为它可以确保依赖项在对象创建时就被初始化，并且对象在整个生命周期中始终保持不变。</p><p><font style="color:#191a24">优点：</font></p><ul><li><font style="color:#191a24">确保依赖项在对象创建时就被初始化。</font></li><li><font style="color:#191a24">可以设置依赖项为final，确保它们不会被修改。</font></li><li><font style="color:#191a24">支持不可变对象。</font></li></ul><p><font style="color:#191a24">缺点：</font></p><ul><li><font style="color:#191a24">如果类有很多依赖项，构造函数可能会变得很长且难以阅读。</font></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyRepository repository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository repository)</span> {</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>Setter方法注入</strong></li></ol><p>Setter方法注入是通过在类中提供setter方法来注入依赖项的。Spring容器会调用这些setter方法来设置依赖项的值。这种方式更加灵活，因为可以在对象创建后的任何时候注入依赖项。</p><p><font style="color:#191a24">优点：</font></p><ul><li><font style="color:#191a24">可以在对象创建后的任何时候注入依赖项。</font></li><li><font style="color:#191a24">可以重新配置已存在的对象。</font></li></ul><p><font style="color:#191a24">缺点：</font></p><ul><li><font style="color:#191a24">可能导致对象状态的不确定性，因为依赖项可以在任何时候被更改。</font></li><li><font style="color:#191a24">不支持不可变对象。</font></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> {</span><br><span class="line">    <span class="keyword">private</span> MyRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRepository</span><span class="params">(MyRepository repository)</span> {</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>字段(Field)注入</strong></li></ol><p>字段注入是通过在类的字段上使用注解来实现的。Spring容器会自动注入依赖项到这些字段中。这种方式相对简单，但通常不是最佳实践，因为它可能会导致代码难以阅读和维护。</p><p><font style="color:#191a24">优点：</font></p><ul><li><font style="color:#191a24">代码简单明了，易于实现。</font></li></ul><p><font style="color:#191a24">缺点：</font></p><ul><li><font style="color:#191a24">不支持不可变对象。</font></li><li><font style="color:#191a24">可能导致代码难以阅读和维护。</font></li><li><font style="color:#191a24">依赖项的生命周期可能不明确。</font></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository repository;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Spring AOP的通知类型有哪些？</strong>**</p><p>Spring AOP有五种通知类型，分别是前置通知<code>Before</code>、返回通知<code>After returning</code>、环绕通知<code>Around</code>、异常通知<code>After throwing</code>、后置通知<code>After</code>。</p><ul><li><strong>前置通知</strong><code>**Before**</code><strong>：</strong>在连接点前面执行但不会影响连接点的执行，除非它引发异常。</li><li><strong>返回通知</strong><code>**After returning**</code><strong>：</strong>在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。</li><li><strong>环绕通知</strong><code>**Around**</code><strong>：****这是最强大的通知类型</strong>。环绕通知可以在方法调用前后完成自定义行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或者抛出异常将执行结束。</li><li><strong>异常通知</strong><code>**After throwing**</code><strong>：</strong>在连接点抛出异常后执行。</li><li><strong>后置通知</strong><code>**After(finally)**</code><strong>：</strong>在连接点执行完成后执行，不管连接点是正常执行完成，还是抛出异常，都会执行通知内容。</li></ul><p><strong>@Resource和@Autowired的区别是什么？</strong>**</p><p><strong>共同点：</strong><code>@Autowired</code>和<code>@Resource</code>都是 Spring/Spring Boot 项目中，用来进行依赖注入的注解。在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</p><p><strong>区别：</strong></p><ol><li><strong>来源不同</strong>：@Resource是Java定义的注解，来自于 JSR-250 （Java 250 规范提案）；而@Autowired注解是Spring框架提供的。</li><li><strong>依赖查找的顺序不同</strong>：@Resource注解默认按照名称进行匹配查找，如果找不到，则按照类型进行匹配。而@Autowired注解默认是按照类型进行匹配，如果出现多个类型一致的实例对象，则需要指定名称。</li><li><strong>支持参数不同</strong>：@Autowired 只支持设置一个 required 的参数，required属性表示是否必须注入该属性；@Resource 支持包括 name 和 type 等 7 个参数。</li><li><strong>依赖注入的用法不同</strong>：@Autowired 既支持构造方法注入，又支持 Field 注入和 Setter 注入，而 @Resource 只支持 Field 注入和 Setter 注入。</li></ol><h3 id="Day15√"><a href="#Day15√" class="headerlink" title="Day15√"></a>Day15√</h3><p><strong>Bean的作用域？</strong>**</p><p>在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。目前Spring Bean的作用域主要有六种。</p><table><thead><tr><th><strong><font style="color:#000">Scope</font></strong></th><th><strong><font style="color:#000">Description</font></strong></th></tr></thead><tbody><tr><td>singleton</td><td>（默认的）在Spring IoC容器中，一个bean定义对应只会有唯一的一个bean实例，bean以单例方式存在。</td></tr><tr><td>prototype</td><td>一个bean定义可以有多个bean实例。每次从容器中调用bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td></tr><tr><td>request</td><td>一个bean定义对应于单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个bean实例，且该实例仅在这个HTTP请求的生命周期里有效。该作用域仅适用于WebApplicationContext环境。</td></tr><tr><td>session</td><td>一个bean定义对应于单个HTTP Session的生命周期。也就是说，每个HTTP Session都有一个bean实例，且该实例仅在这个HTTP Session的生命周期里有效。该作用域仅适用于WebApplicationContext环境。</td></tr><tr><td>application</td><td>一个bean定义对应于单个ServletContext的生命周期。该作用域仅适用于WebApplicationContext环境。</td></tr><tr><td>websocket</td><td>一个bean 定义对应于单个websocket 的生命周期。该作用域仅适用于WebApplicationContext环境。</td></tr></tbody></table><p><strong>Bean的生命周期？</strong>**</p><p>在 Java 中，Bean 就是一个由 Spring IOC 容器初始化、管理和维护的普通Java对象。通过 Spring 容器，我们可以方便的创建和获取这些对象，并且可以配置它们的行为与属性。它的生命周期如下：</p><ol><li><strong>创建 Bean 的实例：实例化一个 Bean 对象。</strong>Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</li><li><strong>Bean 属性赋值/填充：为 Bean 设置相关属性和依赖</strong>，例如<code>@Autowired</code>等注解注入的对象、<code>@Value</code>注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li><li><strong>Bean 初始化：</strong></li></ol><ul><li>如果 Bean 实现了<code>BeanNameAware</code>接口，调用<code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了<code>BeanClassLoaderAware</code>接口，调用<code>setBeanClassLoader()</code>方法，传入<code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了<code>BeanFactoryAware</code>接口，调用<code>setBeanFactory()</code>方法，传入<code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他<code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessBeforeInitialization()</code>方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含<code>init-method</code>属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessAfterInitialization()</code>方法。</li></ul><ol start="4"><li><strong>销毁 Bean：</strong>销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。</li></ol><ul><li>如果 Bean 实现了<code>DisposableBean</code>接口，执行<code>destroy()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含<code>destroy-method</code>属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code>注解标记 Bean 销毁之前执行的方法。</li></ul><p><img src="/post/f4c4d599/1724750996737-f9b18f2b-36d0-49fb-afa6-0ca1d40dc58a.png"></p><p><strong>Spring循环依赖是怎么解决的？</strong>**</p><p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">Spring常见面试题总结 | JavaGuide</a></p><p><strong>Spring中用到了那些设计模式？</strong>**</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33204709/article/details/136465784">Spring(22) Spring中的9种设计模式_spring有些什么设计模式-CSDN博客</a></p><ol><li><strong>工厂设计模式：</strong>Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li><strong>代理设计模式：</strong>Spring AOP 就是基于动态代理的实现。为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>单例设计模式：</strong>Spring 中的 Bean 默认都是单例的。确保某一个类只有一个实例。</li><li><strong>模板方法模式：</strong>Spring中jdbcTemplate、hibernateTemplate 等以Template结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式：</strong>我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。<strong>Spring 事件驱动模型就是观察者模式很经典的一个应用。</strong></li><li><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li></ol><h3 id="Day16√"><a href="#Day16√" class="headerlink" title="Day16√"></a>Day16√</h3><p><strong>描述一下 SpringMVC 的执行流程？</strong>**</p><ol><li>客户端发送请求：客户端（浏览器）发送请求到前端控制器（DispatcherServlet），请求被Servlet拦截以后，转发给SpringMVC框架</li><li>DispatcherServlet处理请求：SpingMVC中的DispatcherServlet核心控制器会接收到请求，并转发给HandlerMapping</li><li>HandlerMapping负责解析请求，根据请求信息和配置信息(xml配置，注解)找到对应的Controller类，如果有配置拦截器，会按照顺序执行拦截器里面的PreHandler方法。</li><li>找到匹配的Controller后，会把请求参数传给Controller里面的方法。</li><li>Controller方法执行完后，会返回一个ModeAndView,其中包括视图名称和需要传递给视图的模型数据。</li><li>视图解析器会根据名字找到视图，然后把视图模型填充到视图里面，再渲染成html内容，返回给客户端</li></ol><p><strong>SpringBoot Starter有什么用？</strong>**</p><p>Spring Boot Starter的作用是简化和加速项目的配置和依赖管理。</p><ul><li>Spring Boot Starter可以理解为一种预配置的模块，它封装了特定功能的依赖项和配置，开发者只需引入相关的Starter依赖，无需手动配置大量的参数和依赖项。</li><li>Starter还管理了相关功能的依赖项，包括其他Starter和第三方库，确保它们能够良好地协同工作，避免版本冲突和依赖问题。</li><li>Spring Boot Starter的设计使得应用可以通过引入不同的Starter来实现模块化的开发。每个Starter都关注一个特定的功能领域，如数据库访问、消息队列、Web开发等。</li><li>开发者可以创建自定义的Starter，以便在项目中共享和重用特定功能的配置和依赖项。</li></ul><p><strong>SpringBoot常用注解？</strong>**</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7179038534711967800?searchId=20240115143538F00BA9AA4E6EA715EBA3">肝了一周总结的SpringBoot常用注解大全，一目了然！平时使用SpringBoot开发项目，少不了要使用到它的注解。 - 掘金 (juejin.cn)</a></p><ol><li><strong>@SpringBootApplication：</strong>是Spring Boot的核心注解，主要目的是开启自动配置。这个注解包含了**@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这三个注解。**</li><li><strong>@SpringBootConfiguration：</strong>该注解继承自@Configuration，二者功能基本一致，标注当前类是配置类。</li><li><strong>@EnableAutoConfiguration：</strong>用于启用Spring Boot的自动配置机制，根据项目的依赖和配置自动配置Spring应用程序。</li><li><strong>@ComponentScan：</strong>1）告诉Spring哪个package的用注解标识的类会被Spring自动扫描并且装入IoC容器中。2）自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些Bean加载到IoC容器中。</li><li><strong>@Controller：</strong>用于标识类作为Spring MVC的Controller。</li><li><strong>@RestController：</strong>类似于@Controller，但它是专门用于RESTful web服务的。它包含了@Controller和@ResponseBody。</li><li><strong>@RequestMapping：</strong>用于将HTTP请求映射到controller的处理方法。可以用在类级别和方法级别。</li><li><strong>@Autowired：</strong>用于自动注入Spring容器中的Bean，可以用在构造方法、字段、Setter方法上。</li><li><strong>@Service：</strong>用于标识类作为服务层的Bean。</li><li><strong>@Repository：</strong>用于标识类作为数据访问层的Bean，通常用于与数据库交互。</li><li><strong>@Component：</strong>通用的组件注解，用于标识任何spring托管的Bean。</li><li><strong>@Configuration：</strong>用于定义配置类，类中可能包含一些@Bean注解用于定义Bean。</li><li><strong>@Value：</strong>用于从属性文件或配置中读取值，将值注入到成员变量中。</li><li><strong>@Qualifier：</strong>与@Autowired一起使用，指定注入时使用的Bean名称。</li><li><strong>@ConfigurationProperties：</strong>用于将配置文件中的属性映射到Java Bean。</li><li><strong>@Profile：</strong>用于定义不同环境下的配置，可以标识在类或方法上。</li><li><strong>@Async：</strong>用于将方法标记为异步执行。</li></ol><p><strong>Spring和SpingBoot的区别？</strong>**</p><p>Spring 框架是一个广泛应用于企业级 Java 开发的开源框架，为开发Java应用程序提供了全面的基础架构支持。Spring Boot 则是在 Spring 框架基础上的一种简化配置、快速开发的框架。</p><ul><li><strong><font style="color:#000">环境配置不同</font></strong><font style="color:#010101">：</font><strong><font style="color:#010101">Spring的环境配置相对较为繁琐，需要手动进行配置</font></strong><font style="color:#010101">，例如配置数据源、配置日志、配置Servlet等等。而</font><strong><font style="color:#010101">Spring Boot则是提供了一套自动配置机制</font></strong><font style="color:#010101">，</font><strong><font style="color:#010101">通过约定大于配置的方式</font></strong><font style="color:#010101">，可以减少开发者的环境配置工作量，从而快速构建应用程序。</font></li><li><strong><font style="color:#000">启动方式不同</font></strong><font style="color:#010101">：</font><strong><font style="color:#010101">Spring的启动方式是通过XML配置文件或Java配置类来配置应用程序，然后通过ApplicationContext来启动应用程序</font></strong><font style="color:#010101">。而</font><strong><font style="color:#010101">Spring Boot则是通过内嵌的Tomcat</font></strong><font style="color:#010101">、Jetty、Undertow等容器，可以直接使用java -jar命令启动应用程序。</font></li><li><strong><font style="color:#000">依赖管理不同</font></strong><font style="color:#010101">：</font><strong><font style="color:#010101">在Spring中，需要手动添加各种依赖库</font></strong><font style="color:#010101">，例如Spring MVC、Spring Security等等。而</font><strong><font style="color:#010101">在Spring Boot中，则是通过Spring Boot Starter依赖，可以一次性添加一系列的依赖库</font></strong><font style="color:#010101">，从而简化依赖管理的工作量。</font></li><li><strong><font style="color:#000">默认配置不同</font></strong><font style="color:#010101">：Spring Boot为开发者提供了一系列的默认配置，例如日志、数据源等，大多数情况下可以直接使用默认配置来构建应用程序。而在Spring中，需要手动配置这些内容，增加了开发者的工作量。</font></li><li><strong><font style="color:#000">微服务支持：</font></strong><font style="color:#010101">Spring 虽然可以用于构建微服务，但需要额外的配置和集成工作。</font><strong><font style="color:#010101">Spring Boot 提供了对微服务架构的内置支持</font></strong><font style="color:#010101">，如服务发现、负载均衡、配置管理等，</font><strong><font style="color:#010101">与Spring Cloud紧密集成，更易于构建微服务应用。</font></strong></li></ul><p><font style="color:#010101">总结：Spring Boot就是Spring的完善和扩展，就是为我们便捷开发，方便测试和部署，提高效率而诞生的框架技术。</font></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Day17√"><a href="#Day17√" class="headerlink" title="Day17√"></a>Day17√</h3><p><strong>一条SQL查询语句是如何执行的？</strong>**</p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352806837">一条SQL查询语句是如何执行的？ - 知乎 (zhihu.com)</a></p><ul><li><strong>连接器：</strong>跟客户端建立连接、获取权限、维持和管理连接；</li><li><strong>查询缓存：</strong>查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li><strong>解析 SQL：</strong>通过分析器对 SQL 查询语句进行<strong>词法分析</strong>、<strong>语法分析</strong>，然后构建语法树；</li><li><strong>执行 SQL：</strong>执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将<code>select *</code>中的<code>*</code>符号扩展为表上的所有列；</li><li>优化阶段：基于查询成本的考虑，<strong>优化器</strong>会选择查询成本最小的执行计划；</li><li>执行阶段：<strong>执行器</strong>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</li></ul></li></ul><p><img src="/post/f4c4d599/1725097285837-e04a47a8-9473-4167-ba78-f11741c75cd7.png"></p><p><strong>数据库的事务隔离级别有哪些？</strong>***</p><p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)<strong>的问题，为了解决这些问题，就有了“</strong>隔离级别</strong>”的概念。</p><blockquote><ul><li><strong>脏读(Dity Read)：</strong>指一个事务读取了另一个事务未提交的数据。当一个事务修改了某个数据，但还未提交时，另一个事务读取了这个未提交的数据，如果第一个事务回滚了，那么第二个事务读取到的数据就是无效的。脏读会导致数据的不一致性。</li><li><strong>幻读(Phantom Read)：</strong>指一个事务在读取某个范围的数据时，另一个事务插入了新的数据，导致第一个事务再次读取同样的范围时，发现有新的数据出现。幻读主要发生在并发的插入操作中，会导致第一个事务读取到不一致的数据。</li><li><strong>不可重复读 (Non-repeatable Read)：</strong>指一个事务在读取某个数据后，再次读取同样的数据时，发现数据已经发生了变化。不可重复读主要发生在并发的更新操作中，会导致事务之间读取到不一致的数据。</li></ul></blockquote><ol><li><strong>读未提交(Read Uncommitted)</strong></li></ol><ul><li>允许一个事务读取另一个事务尚未提交的数据修改。</li><li>最低的隔离级别，存在脏读、不可重复读和幻读的问题。</li></ul><ol start="2"><li><strong>读已提交(Read Committed)</strong></li></ol><ul><li>一个事务只能读取已经提交的数据。其他事务的修改在该事务提交之后才可见。</li><li>解决了脏读问题，但仍可能出现不可重复读和幻读。</li></ul><ol start="3"><li><strong>可重复读(Repeatable Read)</strong></li></ol><ul><li>事务执行期间，多次读取同一数据会得到相同的结果，即在事务开始和结束之间，其他事务对数据的修改不可见。</li><li>解决了不可重复读问题，但仍可能出现幻读。</li></ul><ol start="4"><li><strong>序列化(Serializable)</strong></li></ol><ul><li>最高的隔离级别，确保事务之间的并发执行效果与串行执行的效果相同，即不会出现脏读、不可重复读和幻读。</li></ul><p><strong>事务的四大特性有哪些？</strong>***</p><p>事务的四大特性通常被称为 <strong>ACID</strong> 特性</p><ol><li><strong>原子性(Atomicity)：</strong>确保事务的所有操作要么全部执行成功，要么全部失败回滚，不存在部分成功的情况。</li><li><strong>一致性(Consistency)：</strong>事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。</li><li><strong>隔离性(Isolation)：</strong>多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响其他事务的执行。</li><li><strong>持久性(Durability)：</strong>一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持。</li></ol><h3 id="Day18√"><a href="#Day18√" class="headerlink" title="Day18√"></a>Day18√</h3><p><strong>MySQL的执行引擎有哪些？</strong>**</p><p>主要有InnoDB、MyISAM、Memery等引擎：</p><ul><li><code>**InnoDB**</code> 引擎<strong>提供了对事务ACID四大特性的支持，还提供了行级锁和外键约束</strong>。是MySQL默认存储引擎，适用于需要事务支持、高并发性、高写入需求的应用。</li><li><code>**MyISAM**</code> 引擎<strong>使用表级锁，支持全文索引，但不支持事务，也不支持行级锁和外键约束</strong>。MySQL最早提供的存储引擎，适用于以读操作为主的应用。</li><li><code>**Memery**</code> 就是<strong>将数据放在内存中，数据处理速度很快，但是安全性不高</strong>（一旦数据库崩溃，数据就会丢失）。常应用于临时表中。</li><li><code>Merge</code>将多个相同的MyISAM表合并为一个虚表，常应用于日志和数据仓库。</li></ul><p><strong>MySQL为什么使用B+树来作索引？B树与B+树的区别？</strong>***</p><ol><li><strong>单点查询：</strong>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就査到，而从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。<strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</strong></li><li><strong>插入和删除效率：</strong>B+ 树有大量的冗余节点（非叶子节点），删除一个数据的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+树的插入也是一样，有冗余节点，插入可能存在节点的分裂(如果节点饱和)，但是最多只涉及树的一条路径。B树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。</li><li><strong>范围查询：</strong>B+ 树所有叶子节点之间用链表连接了起来，有利于范围查询，而 B树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。B+ 树的插入和删除效率更高。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB。</li></ol><p><img src="/post/f4c4d599/1725257864329-f3bf9061-e0f1-493c-be7b-38db4342f5f2.webp"></p><p><strong>说一下索引失效的场景？</strong>**</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46224056/article/details/137597431"><strong>索引失效的10种场景，你知道几个呢？（面试必刷!）_索引失效的场景-CSDN博客</strong></a></p><ul><li><strong>使用左或者左右模糊匹配：</strong>比如	<code>LIKE '%abc'</code> 这样的查询会导致索引失效。</li><li><strong>在索引列上使用函数或表达式：</strong>索引列上参与计算，索引失效。</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(<span class="keyword">column</span>) <span class="operator">=</span> <span class="string">'VALUE'</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>OR 条件：</strong>当查询中使用多个 OR 条件时，如果这些条件不涉及同一列（例如在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列），那么索引会失效。数据库可能会选择全表扫描而不是使用多个索引。</li><li><strong>违背最左匹配原则</strong>，索引失效。</li></ul><blockquote><p>在使用联合索引进行查询时，查询条件需要遵循索引中列的顺序，从左到右进行匹配。</p></blockquote><ul><li><strong>不等号条件：</strong>通常情况下，索引只能用于等值比较。当查询中包含不等号条件(如&gt;, &lt;, between, in)时，索引可能会失效。</li><li><strong>隐式类型转换：</strong>如果查询中的条件涉及到隐式类型转换，例如将字符串与数字比较，索引可能无法被使用。</li></ul><h3 id="Day19√"><a href="#Day19√" class="headerlink" title="Day19√"></a>Day19√</h3><p><strong>MySQL 的日志文件有哪几种？</strong>**</p><ul><li><code>**undo log**</code><strong>（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和MVCC</strong>。</li><li><code>**redo log**</code><strong>（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障后的数据恢复</strong>。</li><li><code>**binlog**</code><strong>（归档日志）</strong>：是 MySQL Server 层生成的一种二进制日志，主要<strong>用于数据备份和主从复制</strong>。<font style="color:#191b1f">用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句，并以 “事务”的形式保存在磁盘中。</font></li><li><code>**relay log**</code><strong>（中继日志）</strong>：用于<strong>主从复制</strong>场景下，<strong>从服务器通过 I/O 线程拷贝主服务器的 <strong><code>**binlog**</code></strong> 后本地生成的日志</strong>，然后从服务器 SQL 线程会读取<code>relay log</code>的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</li></ul><p><strong>什么是慢查询？原因是什么？可以怎么优化？</strong>**</p><p>慢查询是指<strong>数据库查询的执行时间超过指定的超时时间时(long_query_time：默认10秒 )。</strong></p><p><strong>原因：</strong></p><ul><li>查询语句比较复杂：查询涉及多个表，包含复杂的连接和子查询，可能导致执行时间较长。</li><li>查询数据量大：当查询的数据量庞大时，即使查询本身并不复杂，也可能导致较长的执行时间。</li><li>缺少索引：如果查询的表没有合适的索引，需要遍历整张表才能找到结果，查询速度较慢。</li><li>数据库设计不合理：数据库表设计庞大，查询时可能需要较多时间。</li><li>并发冲突：当多个查询同时访问相同的资源时，可能发生并发冲突，导致查询变慢。</li><li>硬件资源不足：如果MVSQL服务器上同时运行了太多的查询，会导致服务器负载过高，从而导致查询变慢</li></ul><p><strong>优化：</strong></p><ol><li><strong>不使用子查询</strong></li><li><strong>分组统计可以禁止排序：</strong>默认情况下，MySQL对所有GROUP BY col1，col2…的字段进⾏排序。如果查询包括GROUP BY，想要避免排序结果的消耗，则可以指定<strong>ORDER BY NULL禁止排序。</strong></li><li><strong>禁止不必要的ORDER BY排序</strong></li><li><strong>尽量不要超过三个表join</strong></li><li>**不要使用 select ***</li><li><strong>排序请尽量使用升序</strong></li><li><strong>尽量使用数字型字段</strong></li><li><strong>避免索引失效</strong></li></ol><p><strong>可以对数据库表做那些优化？</strong>**</p><ol><li><strong>合理使用数据库分表</strong></li></ol><p>对于一些特别大的表，可以考虑将其拆分成多个子表，从而更好地管理数据</p><ol start="2"><li><strong>建立索引</strong></li></ol><p>在经常被查询的列上建立索引，提高查询性能。但是也要注意过多的索引影响插入、更新和删除的性能</p><ol start="3"><li>**避免使用 **<code>select</code></li></ol><p>只选择需要的列而不是使用 <code>SELECT</code></p><ol start="4"><li><strong>选择合适的数据类型：</strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</li></ol><ul><li>尽量使用TINYINT，SMALLINT，MEDIUM INT替代INT类型，如果是非负则加上UNSIGNED</li><li>VARCHAR的长度只分配真正需要的空间</li><li>尽量使用整数或者枚举替代字符串类型，因为数值型数据被处理起来的速度要比文本类型要快得多。</li><li>时间类型尽量使用TIMESTAMP而ETIME</li><li>单表不要放太多字段</li><li>尽量少使用NULL，很难查询优化而且占用额外索引空间</li></ul><ol start="5"><li><strong>尽量把字段设置为NOT NULL</strong></li><li><strong>使用连接(JOIN)来代替子查询(Sub-Queries)</strong></li></ol><p>连接(JOIN)之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p><ol start="7"><li><strong>避免全表扫描</strong></li></ol><p><font style="color:#212529">当表中数据量巨大时，全表扫描会非常耗时。通过使用合适的查询条件来避免全表扫描，可以显著提高查询效率。</font></p><ol start="8"><li><strong>使用查询缓存</strong></li></ol><p><font style="color:#212529">当相同的查询被频繁执行时，使用查询缓存可以避免重复的数据库扫描。</font></p><h3 id="Day20√"><a href="#Day20√" class="headerlink" title="Day20√"></a>Day20√</h3><p><strong>说一说你了解的 MVCC 机制？</strong></p><p>MVCC（Multi-Version Concurrency Control，<strong>多版本并发控制</strong>），用于管理多个事务同时访问和修改数据库的数据，而不会导致数据不一致或冲突。MVCC 的核心思想是每个事务在数据库中看到的数据版本是事务开始时的一个快照，而不是实际的最新版本。这使得多个事务可以并发执行，而不会互相干扰。<strong>使用 MVCC 和锁可以实现事务的隔离性。</strong></p><p><strong>MySQL 和 Redis 的区别？</strong>**</p><ol><li><strong>存储方式</strong>：redis基于键值对，支持多种数据结构；而MySQL是一种关系型数据库，使用表来组织数据。</li><li><strong>持久化</strong>：redis将数据存在内存中，通过持久化机制将数据写入磁盘；MySQL通常将数据存储在磁盘上。</li><li><strong>复杂查询支持</strong>：redis不使用SQL，而是使用自己的命令集，不支持复杂的查询；MySQL使用SQL语言，可以进行复杂的查询操作。</li><li><strong>应用场景</strong>：redis以高性能能低延迟为目标，适用于读多写少的应用场景；MySQL适用于需要复杂查询、事务处理和大规模数据存储的应用场景。</li></ol><p><strong>Redis有什么优缺点？为什么用Redis查询会比较快？</strong>**</p><p><strong>优点：</strong>Redis是一个基于<strong>内存</strong>的数据库，读写速度非常快，通常被用作<strong>缓存、消息队列、分布式锁和键值存储数据库</strong>。常支持多种数据类型，如<strong>字符串、哈希表、列表、集合、有序集合</strong>等，Redis还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。</p><p><strong>缺点：</strong>1.<strong>内存限制</strong>，redis将数据存储在内存中，因此它受到物理内存大小限制；2.<strong>单线程模型</strong>，redis使用单线程处理客户端请求，这限制了他在高并发场景下的吞吐量；3.redis不支持SQL数据库那样的<strong>复杂查询</strong>操作。</p><p>redis查询速度快的原因：</p><ol><li><strong>基于内存</strong>：内存的本身的读写速度很快，这是redis速度快的主要原因；</li><li><strong>高效的数据结构</strong>：redis专门设计了STRING、LIST、HASH等高效数据结构，依赖各种数据结构提升了读写的效率；</li><li><strong>单线程</strong>：单线程操作避免了多线程资源竞争和上下文切换带来的性能损失；</li><li><strong>I/O多路复用</strong>：采用I/O多路复用同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。</li></ol><h3 id="Day21√"><a href="#Day21√" class="headerlink" title="Day21√"></a>Day21√</h3><p><strong>Redis的基本数据类型有那些？有哪些使用场景</strong>***</p><p><img src="/post/f4c4d599/1722415900660-9d12da28-9f81-48d4-8bb2-bda50188e9f6.png"></p><p>Redis是一个基于<strong>内存</strong>的数据库，读写速度非常快，通常被用作<strong>缓存、消息队列、分布式锁和键值存储数据库</strong>。常见的数据类型有<strong>String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、Zset（有序集合）</strong>。</p><ul><li>字符串：存储<strong>字符串</strong>数据，也可以存储<strong>整数、浮点数</strong>，是最基本的数据类型，常用于<strong>缓存对象、常规计数、分布式锁、共享Session信息</strong>等；</li><li>哈希表：存储<strong>字段和值的映射</strong>，常用于<strong>缓存对象、购物车</strong>等；</li><li>列表：存储<strong>有序的字符串元素</strong>，常用于<strong>消息队列</strong>（有两个问题：1. ⽣产者需要自行实现全局唯⼀ ID；2. 不能以消费组形式消费数据）；</li><li>集合：存储<strong>无序不重复的字符串元素</strong>，常用于<strong>聚合运算场景</strong>（<strong>并集、交集、差集</strong>），如<strong>点赞、共同关注、抽奖活动</strong>；</li><li>有序集合：类似于集合，但是可以根据元素所关联的分数进行排序，常用于<strong>排序场景</strong>，如<strong>排行榜</strong>。</li></ul><p>随着Redis版本更新，又更新了这些数据类型：</p><ul><li>BitMap：存储位的数据结构，可以处理一些位运算操作，比如签到、登录状态等；</li><li>HyperLogLog：用于基数估算的数据结构，用于统计元素的唯⼀数量，如海量数据基数统计的场景；</li><li>GEO：存储地理位置信息的数据结构；</li><li>Stream：专门为消息队列设计的数据类型。</li></ul><p><strong>Redis是单线程的还是多线程的，为什么？</strong>***</p><p>Redis是<strong>单线程</strong>的，redis的单线程指的是<strong>网络请求模块使用单线程</strong>进行处理，其他模块仍用多个线程 原因如下：</p><ol><li>CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。</li><li>单线程容易实现，并且单线程避免了多线程的资源竞争和上下文切换的开销。</li></ol><h3 id="day22√"><a href="#day22√" class="headerlink" title="day22√"></a>day22√</h3><p><strong>Redis持久化机制有哪些？</strong>***</p><ol><li><strong>AOF日志</strong>：每次执行一条写操作指令，就把该指令以追加的方式写入到一个文件里；</li><li><strong>RDB快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：工作在AOF日志重写的过程中，集成了前两种的优点。在 AOF 日志重写过程中，Redis 会先将当前内存中的数据以 RDB 的形式写入到 AOF 文件的开头，然后再将后续的写入命令以 AOF 形式追加到文件中。</li></ol><blockquote><p>AOF优点是服务器宕机时<strong>丢失数据少</strong>，但是数据恢复不够快；RDB的优点是<strong>数据恢复快</strong>，但是保存快照的频率不好把握，频率高会影响性能，频率低会丢失的数据较多。</p></blockquote><p><strong>缓存雪崩、击穿、穿透和解决办法？</strong>***</p><p><img src="/post/f4c4d599/1722424007103-690d2433-e03a-4981-a216-b5c648308789.png"></p><ul><li><strong><font style="color:#333">缓存雪崩</font></strong><font style="color:#333">：指的是在某个时间点，缓存中大量数据同时失效，导致请求直接访问数据库或其他后端系统，增加了系统的负载。</font></li></ul><p><strong><font style="color:#333">原因</font></strong><font style="color:#333">：大量数据的过期时间相近或者Redis服务器故障宕机。</font></p><p><strong><font style="color:#333">解决方法</font></strong><font style="color:#333">：对于第一种情况可以</font><strong><font style="color:#333">均匀设置过期时间</font></strong><font style="color:#333">、</font><strong><font style="color:#333">加互斥锁</font></strong><font style="color:#333">、</font><strong><font style="color:#333">后台更新缓存</font></strong><font style="color:#333">（让缓存“永久有效”，并将更新缓存的⼯作交由后台线程定时更新）等策略；对于第二种情况可以采用</font><strong><font style="color:#333">服务熔断</font></strong><font style="color:#333">或</font><strong><font style="color:#333">请求限流机制</font></strong><font style="color:#333">，还有</font><strong><font style="color:#333">构建Redis缓存高可用集群</font></strong><font style="color:#333">等方法。</font></p><ul><li><strong><font style="color:#333">缓存击穿</font></strong><font style="color:#333">：指的是有大量请求查询一个缓存中不存在但数据库中存在的数据时，这些请求直接访问到数据库，增加数据库的负载。</font></li></ul><p><strong>原因</strong>：单个热点数据的缓存失效，短时间内大量的请求直接访问数据库。</p><p><strong><font style="color:#333">解决方法</font></strong><font style="color:#333">：缓存击穿是缓存雪崩的一个</font><strong><font style="color:#333">子集</font></strong><font style="color:#333">，可以采用</font><strong><font style="color:#333">互斥锁</font></strong><font style="color:#333">和</font><strong><font style="color:#333">后台更新缓存</font></strong><font style="color:#333">等策略。</font></p><ul><li><strong><font style="color:#333">缓存穿透</font></strong><font style="color:#333">：指的是查询一个缓存和数据库都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。</font></li></ul><p><strong><font style="color:#333">原因</font></strong><font style="color:#333">：恶意攻击、业务误操作，缓存和数据库中的数据都被删除了。</font></p><p><strong><font style="color:#333">解决方法</font></strong><font style="color:#333">：</font><strong><font style="color:#333">限制非法请求</font></strong><font style="color:#333">、对查询的数据，</font><strong><font style="color:#333">在缓存中设置空值</font></strong><font style="color:#333">、使用</font><strong><font style="color:#333">布隆过滤器</font></strong><font style="color:#333">过滤恶意请求。</font></p><blockquote><p><strong>布隆过滤器</strong>是一种空间效率极高的概率型数据结构，它被用来测试一个元素是否在一个集合中。布隆过滤器可能会给出错误的正例，但永远不会给出错误的反例。也就是说，<strong>如果布隆过滤器说某个元素不在集合中，那么这个结论一定是正确的；但如果它说某个元素在集合中，那么这个结论可能是错误的</strong>。原理如下：</p><ol><li><strong>初始化</strong></li></ol><ul><li><strong><font style="color:#2c2c36">位数组</font></strong><font style="color:#2c2c36">：布隆过滤器的核心是一个很长的二进制向量（</font><strong><font style="color:#2c2c36">位数组</font></strong><font style="color:#2c2c36">），初始时所有位都是0。</font></li><li><strong><font style="color:#2c2c36">哈希函数</font></strong><font style="color:#2c2c36">：需要选择</font><strong><font style="color:#2c2c36">多个独立的哈希函数</font></strong><font style="color:#2c2c36">（通常为k个），这些函数会将输入映射到位数组中的不同位置。</font></li></ul><ol start="2"><li><strong>插入元素</strong></li></ol><ul><li><font style="color:#2c2c36">当一个元素被添加到布隆过滤器时，使用所有的哈希函数计算该元素对应的位数组的位置。</font></li><li><font style="color:#2c2c36">对于每个哈希函数计算出的位置，将位数组中对应位置的比特设为1。</font></li></ul><ol start="3"><li><strong>查询元素</strong></li></ol><ul><li><font style="color:#2c2c36">当查询一个元素是否存在时，同样使用所有的哈希函数计算该元素对应的位数组的位置。</font></li><li><font style="color:#2c2c36">如果所有计算出的位置上的比特都为1，则认为该元素</font><strong><font style="color:#2c2c36">可能</font></strong><font style="color:#2c2c36">存在于集合中。</font></li><li><font style="color:#2c2c36">如果任一位置的比特为0，则确定该元素不在集合中。</font></li></ul></blockquote><p><strong>如何保证数据库和缓存的一致性？</strong>***</p><ol><li><strong>缓存更新策略</strong></li></ol><p><strong>Cache Aside（旁路缓存）</strong></p><ul><li><strong>原理:</strong> <strong>读操作</strong>：先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；<strong>写操作</strong>：更新数据的时候先把数据持久化到数据库，然后删除缓存。</li><li><strong>问题:</strong> 假如有两个操作一个更新一个查询，第一个操作先更新数据库，还没来及删除数据库，查询操作可能拿到的就是旧的数据，更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性;还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效,然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。</li><li><strong>可行性:</strong> 出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并且在写操作之后更新，概率比较低。</li></ul><p><strong>Read/Write Through</strong></p><ul><li><strong>原理:</strong> <strong>Read/Write Through原理是把更新数据库(Repository) 的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。</strong></li><li><strong>Read Through:</strong> 应用查询缓存是否存在，存在则返回；不存在则由缓存组件去数据库加载数据到缓存。</li><li><strong>Write Through（双写法）</strong>: 先查询要写入的数据在缓存是否存在，存在则先更新缓存然后再更新数据库最后返回；如果要写入的数据在缓存不存在，则直接将数据写入数据库。</li></ul><p><strong>Write Behind(Write Back)</strong></p><ul><li><strong>原理:</strong> Write Behind 和 Read/Write Through 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。<strong>在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库</strong>。这个设计的好处就是让数据的 I/O 操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。</li><li><strong>第二步失效问题:</strong> 这种可能性极小，缓存删除只是标记一下无效的软删除，可以看作不耗时间。如果会出问题，一般程序在写数据库那里就没有完成: 故意在写完数据库后，休眠很长时间再来删除缓存。</li></ul><p><strong>哨兵的工作原理？</strong>***</p><ul><li><strong><font style="color:#333">判断节点是否存活</font></strong><font style="color:#333">：每个哨兵定期向Redis服务器发送PING命令，以检测服务器是否处于活跃状态。若哨兵在连续一定次数未收到服务器的响应，就认为该服务器主观下线。然后哨兵就会从从节点中选择一个作为主节点。</font></li><li><strong><font style="color:#333">选出新主节点</font></strong><font style="color:#333">：在发现主服务器下线后，哨兵们会协调选举一个新的主服务器。这个过程中，哨兵会考虑每个可用的从服务器，选择个作为新的主服务器，并将其他从服务器配置为复制新的主服务器。</font></li></ul><ul><li><strong>具体过程：</strong><ul><li><strong>选择候选从服务器</strong>：哨兵会从可用的从服务器中选择一组候选服务器，通常选择复制偏移量 (replicationoffset) 最大的从服务器。</li><li><strong>计算投票</strong>：每个哨兵为每个候选从服务器投票。投票的考量因素包括从服务器的复制偏移量、连接质量、优先级等。</li><li><strong>达成共识</strong>：哨兵们根据投票结果达成共识，选择一个从服务器作为新的主服务器。这通常需要获得多数哨兵的同意。</li></ul></li></ul><ul><li><strong><font style="color:#333">更新配置信息</font></strong><font style="color:#333">：一旦新的主服务器被选出，哨兵会更新 Redis 集群的配置信息，包括将新的主服务器的地址和端口通知给其他哨兵和客户端。</font></li><li><strong><font style="color:#333">通知客户端</font></strong><font style="color:#333">：哨兵会向客户端发送通知，告知客户端新的主服务器的位置，以便客户端能够重新连接。</font></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="Day23"><a href="#Day23" class="headerlink" title="Day23"></a>Day23</h3><p><strong>TCP/IP模型和OSI模型？</strong>**</p><p>OSI模型是国际标准化组织ISO制定的一个用于计算机或通信系统互联的标准体系，主要分为七个层级，从上到下依次为：应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。详细如下：</p><ol><li><strong>应用层：</strong>这一层为用户程序提供网络服务。常见的协议有FTP、SMTP、HTTP、DNS。</li><li><strong>表示层：</strong>负责数据的格式转换、加密和解密，确保数据在不同系统之间的正确解释性和呈现。也就是把计算机能够识别的东西转换为人能够识别的东西。</li><li><strong>会话层：</strong>建立、管理和终止应用程序之间的会话连接。</li><li><strong>传输层：提供端到端的数据传输服务。</strong>它使用TCP和UDP来传输管理数据。</li><li><strong>网络层：负责数据的路由和转发，</strong>选择最佳路径将数据从园主机传输到目标主机。使用IP地址来识别主机和网络，并提供逻辑地址寻址。<strong>传输单位是数据报。常见协议有ICMP、ARP、IP。</strong></li><li><strong>数据链路层：</strong>建立逻辑连接、进行硬件地址寻址、差错校验等功能。 ⽤MAC地址访问介质，<strong>传输单位是帧。</strong></li><li><strong>物理层：</strong>负责物理媒介传输的，例如电缆、光纤或无线信号。<strong>这一层的数据叫比特。</strong></li></ol><p>TCP/IP模型是是一种用于组织和描述计算机网络通信的标准协议，它是互联网最常用的协议栈。主要分为四个层级：</p><ol><li><strong>应用层：该层与OSI模型的应用层和表示层以及会话层类似，提供直接与用户应用程序交互的接口。</strong>常见的协议有电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。</li><li><strong>传输层：该层对应OSI模型的传输层。它负责端到端的数据传输服务，提供可靠的、无连接的数据传输服务。</strong>常见的协议有TCP和UDP。TCP提供面向连接且可靠的数据传输，确保数据的准确性和完整性；而UDP是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。</li><li><strong>网际层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，</strong>选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来识别主机和网络，并进行逻辑地址寻址。</li><li><strong>网络接口层：该层对应OSI模型的数据链路层和物理层。</strong>它负责物理传输媒介的传输，例如以太网、WiFi等，并提供错误检测和纠正的功能。此外该层还包括硬件地址——MAC地址的管理。</li></ol><p><strong>从输入URL到页面展示发生了什么？</strong>***</p><ol><li><strong>URL 输入</strong>：用户在浏览器的地址栏中输入URL，例如”<a target="_blank" rel="noopener" href="https://www.example.com" "="">https://www.example.com"</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>域名解析</strong>：浏览器通过域名系统(DNS)将域名解析为IP地址，以确定要连接的服务器位置。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>建立连接</strong>：浏览器使用解析得到的 IP 地址，与服务器建立网络连接。这通常涉及使用 TCP 协议进行三次握手。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>发送请求</strong>：浏览器向服务器发送 HTTP 请求，请求服务器的网页内容。请求中包含了要访问的路径、方法(GET、POST等)、头部信息等。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>服务器处理</strong>：服务器接收到请求后，根据请求的内容和路径，处理请求并返回响应。服务器可能从数据库中获取数据，生成动态内容，然后将响应发送回浏览器。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>接收响应</strong>：浏览器接收到服务器的响应，响应包含了 HTTP 状态码、头部信息和页面内容等。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>解析和渲染</strong>：浏览器开始解析响应内容，构建文档对象模型(DOM)和渲染树。它解析HTML、CSS和JavaScript，并确定页面的结构、样式和行为。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>页面渲染</strong>：浏览器使用渲染树和样式信息，将页面内容绘制到屏幕上。这包括布局、绘制和显示页面元素。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>执行JavaScript</strong>：如果页面包含JavaScript，浏览器会执行JavaScript 代码，添加交互和动态行为。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>加载资源</strong>：页面中可能包含外部资源，如图片、样式表、脚本文件等。浏览器会根据需要下载这些资源，以完整地呈现页面。</a></li><li><a target="_blank" rel="noopener" href="https://www.example.com" "=""><strong>完成页面加载</strong>：页面的所有内容和资源加载完成后，浏览器显示完整的页面。</a></li></ol><h3 id="Day24"><a href="#Day24" class="headerlink" title="Day24"></a>Day24</h3><p><strong>HTTP请求报文和响应报文是怎样的？</strong>**</p><p><strong>HTTP请求报文主要由请求行、请求头、请求体构成</strong>。下面是一个GET请求报文示例：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/example/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br><span class="line">--------------------------------------</span><br><span class="line">                    -------空白行</span><br><span class="line">                    -------body(这里没有内容)</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>请求行</strong>：（请求方法 URL 协议版本号）</li></ol><ul><li>请求方法： GET、POST、PUT、DELETE、PATCH、HEAD、CONNECT、OPTIONS、TRACE</li><li>URL：<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;</code></li><li>协议版本号：HTTP版本号</li></ul><ol start="2"><li><strong>请求头</strong>：包含请求的附加信息，由key:value组成，它可以包含很多不同的字段，用于告知服务器有关请求的详细信息。些常见的请求头部字段包括:</li></ol><ul><li>Host：指定服务器的主机名和端口号</li><li>User-Agent：标识客户端的用户代理(浏览器或其他工具)</li><li>Accept：指定客户端可以接受的响应数据类型。</li><li>Content-Type：指定请求主体的数据类型</li><li>Authorization：用于进行身份验证的凭据。</li></ul><ol start="3"><li>空行：空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。</li><li><strong>请求体</strong>：承载多个请求参数的数据，请求主体是可选的，通常在发送POST、PUT等请求时包含请求的实际数据。例如使用POST请求提交表单数据或上传文件时，请求体会包含这些数据。</li></ol><hr><p><strong>HTTP响应报文</strong>是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关数据。<strong>一个标准的HTTP响应报文通常包含状态行、响应头、响应体</strong>。</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.4.38 (Unix)</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>session_id=abcd1234; Expires=Wed, 11 Aug 2023 00:00:00 GMT</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">             ----空行</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Example Page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>状态行</strong>：（协议版本号 状态码 状态消息）</li></ol><ul><li>协议版本号：HTTP版本号</li><li>状态码：服务器处理结果的三位数字号码</li><li>状态消息：对状态码的简要描述</li></ul><ol start="2"><li><strong>响应头</strong>：响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：</li></ol><ul><li>Content-Type：指定响应主体的MIME类型:</li><li>Content-Length：指定响应主体的长度(字节数)</li><li>Server：指定服务器的信息。</li><li>Location：在重定向时指定新的资源位置。</li><li>Set-Cookie：在响应中设置Cookie。</li></ul><ol start="3"><li>空行：空行是响应头部和响应主体之间的空行，用于分隔响应头部和响应主体。</li><li><strong>响应体</strong>：响应主体包含服务器返回给客户端的实际数据。例如，当请求一个网页时，响应主体将包含HTML内容。响应主体的存在与否取决于请求的性质以及服务器的处理结果。</li></ol><p><strong>HTTP请求方式有哪些？</strong>**</p><p>HTTP1.1规定了九种标准请求方式，包括<strong>GET、POST、HEAD</strong>、PUT、DELETE、TRACE、PATCH、CONNECT、OPTIONS。其中最常用的就是<strong>GET和POST</strong>请求。详细如下：</p><ol><li><strong>GET：申请获取资源，不对服务器产生影响</strong></li><li><strong>POST：POST请求通常用于发送数据，例如提交表单数据、上传文件等，会影响服务器，服务器可能动态创建新的资源或更新原有资源。</strong></li><li><strong>HEAD：类似GET，仅要求服务器返回头部信息，不返回实际的资源内容</strong></li><li>PUT：用于更新服务器上的资源或创建新资源。（<strong>与POST的区别是：PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</strong>）</li><li>DELETE：请求服务器删除指定的资源。</li><li>TRACE：用于测试。要求目标服务器返回原始的HTTP请求内容。</li><li>PATCH：用于对资源进行部分更新。</li><li>CONNECT：用于代理服务器。</li><li>OPTIONS：用于获取服务器支持的HTTP方法列表，以及针对指定资源支持的方法。</li></ol><p><strong>GET请求和POST请求的区别？</strong>***</p><ol><li><strong>使用场景：</strong>GET请求和POST请求都是HTTP请求方法，GET请求用于从服务器<strong>获取数据</strong>，POST请求用于向服务器<strong>发送数据</strong>。</li><li><strong>传递参数</strong></li></ol><ul><li>GET请求的参数一般写在URL中，所以GET传送的数据量较小，不能大于2KB，且只接受ASCII字符</li><li>POST请求参数一般放在请求体中，所以其请求信息没有长度限制，对于数据类型也没有限制</li></ul><ol start="3"><li><strong>安全和幂等</strong></li></ol><blockquote><p><strong>安全：在HTTP协议中安全指的是请求方法不会破坏服务器上的资源。</strong></p><p><strong>幂等：多次执行相同的操作，结果都相同。</strong></p></blockquote><ul><li>GET为安全幂等的，因为它为只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的</li><li>POST因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</li></ul><ol start="4"><li><strong>缓存机制：</strong>GET请求可以被浏览器缓存，POST请求不会被缓存。</li><li><strong>时间消耗</strong></li></ol><ul><li>GET 产生一个 TCP 数据包，浏览器会把 header 和 data 一并发送出去，服务器响应 200(返回数据)</li><li>POST产生两个TCP 数据包，对于POST，浏览器先发送 Header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok(返回数据)</li></ul><ol start="6"><li><strong>编码方式</strong></li></ol><ul><li>GET 请求只能进行 URL编码 <code>application/x-www-form-urlencoded</code></li><li>POST 支持多种编码方式 <code>application/x-www-form-urlencoded</code>或 <code>multipart/form-data</code>（为二进制数据使用多种编码）。</li></ul><h3 id="Day25"><a href="#Day25" class="headerlink" title="Day25"></a>Day25</h3><p><strong>HTTP请求中常见的状态码？</strong>**</p><p><img src="/post/f4c4d599/1724768356156-4e8d7332-abcc-4e62-b65f-b03f28b61282.png"></p><p><strong>什么是强缓存和协商缓存？</strong>**</p><p><a target="_blank" rel="noopener" href="https://t.zsxq.com/12AlZ293Z">知识星球回答连接</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cuclife/article/details/136510628">强制缓存与协商缓存：概念原理、区别、适用场景和具体示例-CSDN博客</a></p><ol><li><strong>强制缓存是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</strong>其工作原理是是通过HTTP响应头中的特定字段来控制的，例如<code>Expires</code>和<code>Cache-Control</code>，它们指示了资源缓存的有效时间。当浏览器在有效时间内再次请求同一资源时，它会直接从本地缓存中获取该资源，而不会向服务器发送请求。</li></ol><ul><li><code>Expires</code><strong>强缓存</strong>：<code>Expires</code>表示未来资源会过期的时间点，当时间超过了<code>Expires</code>设置的时间点，浏览器就会重定向服务器请求资源。</li></ul><blockquote><p>因为<code>Expires</code>判断强缓存过期机制是获取本地时间戳与之前拿到资源文件中的<code>Expires</code>字段的时间做比较，来判断是否需要对服务器发起请求。<strong>这里有一个巨大的漏洞：如果本地时间不准确则会导致出现错误。</strong></p></blockquote><ul><li><code>Cache-Control</code><strong>强缓存</strong>：在HTTP1.1中增加了该字段，它提供了更灵活的缓存控制机制。例如，可以通过<code>max-age</code>参数设置缓存的最大生存时间（以秒为单位），如<code>Cache-Control: max-age=1200</code>表示缓存有效时间为1200秒。</li></ul><blockquote><p><code>Cache-Control</code>有有六个属性，分别是max-age、s-maxage、no-cache、no-store、private、public。</p><ul><li>max-age决定客户端资源被缓存多久。</li><li>s-maxage决定代理服务器缓存的时长。</li><li>no-cache表示是强制进行协商缓存。</li><li>no-store是表示禁止任何缓存策略。</li><li>public表示资源既可以被浏览器缓存也可以被代理服务器缓存。</li><li>private表示资源只能被浏览器缓存，默认为private。</li></ul></blockquote><ol start="2"><li><strong>协商缓存是浏览器与服务器之间进行通信以确认缓存资源是否仍然有效的过程。</strong></li></ol><p>协商缓存主要涉及两组HTTP头字段：<code>ETag</code>和<code>If-None-Match</code>，以及<code>Last-Modified</code>和<code>If-Modified-Since</code>。它们的工作原理如下：</p><p>ETag/If-None-Match：当浏览器第一次请求某个资源时，服务器会返回一个ETag（实体标签），它是一个资源版本的唯一标识符。浏览器在后续请求该资源时，会在请求头中携带If-None-Match字段，其值为先前接收到的ETag。服务器会根据这个值来判断资源是否有更新。如果有更新，服务器会返回新的资源和新的ETag；如果没有更新，服务器会返回304 Not Modified状态码，告诉浏览器可以使用缓存中的资源。</p><p>Last-Modified/If-Modified-Since：类似于ETag机制，但Last-Modified记录的是资源最后修改的时间。浏览器在后续请求时，会在请求头中携带If-Modified-Since字段，其值为先前接收到的Last-Modified时间。服务器会检查资源的最后修改时间是否在这个时间之后。如果是，说明资源有更新，服务器会返回新资源和新的Last-Modified时间；如果不是，服务器同样会返回304 Not Modified状态码。</p><p>todo…</p><h3 id="Day26"><a href="#Day26" class="headerlink" title="Day26"></a>Day26</h3><p><strong>HTTP1.0和HTTP1.1的区别？</strong>***</p><p><strong>HTTP2.0与HTTP1.1的区别？</strong>***</p><p><strong>HTTP3.0有了解过吗？</strong>**</p><hr><h3 id="Day27"><a href="#Day27" class="headerlink" title="Day27"></a>Day27</h3><p><strong>HTTPS和HTTP有哪些区别？</strong>***</p><p><strong>HTTPS工作原理？</strong>**</p><hr><h3 id="Day28"><a href="#Day28" class="headerlink" title="Day28"></a>Day28</h3><p><strong>TCP和UDP的区别？</strong>***</p><p><strong>TCP连接如何确保可靠性？</strong>***</p><p><strong>UDP怎么实现可靠传输？</strong>**</p><hr><h3 id="Day29"><a href="#Day29" class="headerlink" title="Day29"></a>Day29</h3><p><strong>三次握手的过程，为什么是三次？</strong>***</p><p><strong>四次挥手的过程，为什么是四次？</strong>***</p><p><strong>HTTP的Keep-Alive是什么？TCP 的Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</strong>**</p><hr><h3 id="Day30"><a href="#Day30" class="headerlink" title="Day30"></a>Day30</h3><p><strong>DNS查询过程？</strong>**</p><p><strong>CDN是什么？</strong>**</p><p><strong>Cookie和Session是什么?有什么区别？</strong>**</p><p>Cookie和Session都是Web开发中用于跟踪用户状态的技术，但它们在存储位置、数据容量、安全性以及生命周期等方面存在显著差异：</p><ol><li>存储位置：Cookie的数据存储在客户端（通常是浏览器）。当浏览器向服务器发送请求时，会自动附带Cookie中的数据。Session的数据存储在服务器端。服务器为每个用户分配一个唯一的Session ID，这个ID通常通过Cookie或URL重写的方式发送给客户端，客户端后续的请求会带上这个Session ID，服务器根据ID查找对应的Session数据。</li><li>数据容量：单个Cookie的大小限制通常在4KB左右，而且大多数浏览器对每个域名的总Cookie数量也有限制。由于Session存储在服务器上，理论上不受数据大小的限制，主要受限于服务器的内存大小。</li><li>安全性：Cookie相对不安全，因为数据存储在客户端，容易受到XSS（跨站脚本攻击）的威胁。不过，可以通过设置HttpOnly属性来防止JavaScript访问，减少XSS攻击的风险，但仍然可能受到CSRF（跨站请求伪造）的攻击。Session通常认为比Cookie更安全，因为敏感数据存储在服务器端。但仍然需要防范Session劫持（通过获取他人的Session ID）和会话固定攻击。</li><li>生命周期：Cookie可以设置过期时间，过期后自动删除。也可以设置为会话Cookie，即浏览器关闭时自动删除。Session在默认情况下，当用户关闭浏览器时，Session结束。但服务器也可以设置Session的超时时间，超过这个时间未活动，Session也会失效。</li><li>性能：使用Cookie时，因为数据随每个请求发送到服务器，可能会影响网络传输效率，尤其是在Cookie数据较大时。使用Session时，因为数据存储在服务器端，每次请求都需要查询服务器上的Session数据，这可能会增加服务器的负载，特别是在高并发场景下。</li></ol><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Day31"><a href="#Day31" class="headerlink" title="Day31"></a>Day31</h3><p><strong>进程和线程的区别？</strong>***</p><p><strong>进程是系统进行资源调度和分配的的基本单位，实现了操作系统的并发。</strong></p><p><strong>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</strong>一个进程由一个或多个线程组成，这些线程共享同一块内存。</p><p>区别：</p><ol><li><strong>资源开销</strong></li></ol><ul><li>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</li><li>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需要保存和恢复少量的线程上下文，因此上下文切换的开销较小。</li></ul><ol start="2"><li><strong>通信与同步</strong></li></ol><ul><li>进程：由于进程间相互隔离，进程之间的通信需要使用一些特殊机制，如管道、消息队列、共享内存等。</li><li>线程：由于线程共享相同的内存空间，它们之间可以直接访问共享数据，线程间通信更加方便。</li></ul><ol start="3"><li><strong>安全性</strong></li></ol><ul><li>进程：由于进程间相互隔离，一个进程的崩溃不会直接影响其他进程的稳定性。</li><li>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</li></ul><p><strong>并行和并发有什么区别？</strong>**</p><blockquote><p>并行是在同一时刻执行多个任务</p><p>并发是在相同的时间段内执行多个任务，任务可能交替执行，通过调度实现。</p></blockquote><p>并行是指在同一时刻执行多个任务，这些任务可以同时进行，每个任务都在不同的处理单元(如多个CPU核心)上执行。在并行系统中，多个处理单元可以同时处理独立的子任务，从而加速整体任务的完成。</p><p>并发是指在相同的时间段内执行多个任务，这些任务可能不是同时发生的，而是交替执行，通过时间片轮转或者事件驱动的方式。并发通常与任务之间的交替执行和任务调度有关。</p><p><strong>解释一下用户态和核心态？</strong>**</p><p>用户态 <code>User Mode</code> 和核心态 <code>Kernel Mode</code> 是操作系统中两种不同的执行模式，用于<strong>控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p><ul><li>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li><li>核心态：核心态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0的状态我们称之为内核态。</li></ul><blockquote><p>什么场景下，会发生内核态和用户态的切换</p><ul><li>系统调用：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态</li><li>异常：当程序执行过程中出现错误或异常情况时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。</li><li>中断：外部设备(如键盘、鼠标、磁盘等)产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态</li></ul></blockquote><h3 id="Day32"><a href="#Day32" class="headerlink" title="Day32"></a>Day32</h3><p><strong>进程调度算法你了解多少？</strong>**</p><p>进程调度算法是操作系统中用来管理和调度进程(也称为任务或作业)执行的方法。这些算法决定了</p><p>在多任务环境下，如何为各个进程分配 CPU 时间，以实现公平性、高吞吐量、低延迟等不同的调度</p><p>目标。</p><ol><li>先来先服务调度算法</li></ol><p>按照进程到达的先后顺序进行调度，即最早到达的进程先执行，直到完成或阻塞，</p><ol start="2"><li>最短作业优先调度算法</li></ol><p>优先选择运行时间最短的进程来运行</p><ol start="3"><li>高响应比优先调度算法</li></ol><p>综合考虑等待时间和服务时间的比率，选择具有最高响应比的进程来执行</p><ol start="4"><li>时间片轮转调度算法将CPU 时间划分为时间片(时间量)，每个进程在一个时间片内运行，然后切换到下一个进程。</li><li>最高优先级调度算法</li></ol><p>为每个进程分配一个优先级，优先级较高的进程先执行。这可能导致低优先级进程长时间等待可能引发饥饿问题。</p><ol start="6"><li>多级反馈队列调度算法</li></ol><p>将进程划分为多个队列，每个队列具有不同的优先级，进程在队列之间移动。具有更高优先级的队列的进程会更早执行，而长时间等待的进程会被提升到更高优先级队列。</p><ol start="7"><li>最短剩余时间优先</li></ol><p>每次选择剩余执行时间最短的进程来执行。</p><ol start="8"><li>最大吞吐量调度</li></ol><p>旨在最大化单位时间内完成的进程数量</p><ol start="9"><li>最大吞吐量调度</li></ol><p>旨在最大化单位时间内完成的进程数量</p><p><strong>进程间有哪些通信方式？</strong>***</p><ol><li><strong>管道：</strong>是一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。</li><li>命名管道：也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li><strong>信号量：</strong>是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>消息队列：</strong>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号：用于通知接收进程某个事件已经发生，从而迫使进程执行信号处理程序。</li><li><strong>共享内存：</strong>就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程通信方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，比如信号量配合使用，来实现进程间的同步和通信。</li><li><code>Socket</code> 套接字：是支持TCP/IP 的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。</li></ol><p><strong>解释一下进程同步和互斥，以及如何实现进程同步和互斥？</strong>**</p><p><strong>进程同步是指多个并发执行的进程之间协调和管理它们的执行顺序，以确保它们按照一定的顺序或时间间隔执行。</strong>比如说，你想要和你的队友一起完成一个副本，你们需要相互配合，有时候等待对方的信号或者消息，有时候按照对方的要求执行某些动作，这就是进程同步。</p><p><strong>互斥指的是在某一时刻只允许一个进程访问某个共享资源。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。</strong>比如说，你想要使用一个祭坛来祈愿，但是这个祭坛一次只能被一个人使用，如果有其他人也想要使用，他们就必须等待你使用完毕后再去使用，这就是进程互斥。</p><p>解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是<strong>使用信号量和 PV 操作</strong>。信号量是一种特殊的变量，它表示系统中某种资源的数量或者状态。PV 操作是一种对信号量进行增加或者减少的操作，它们可以用来控制进程之间的同步或者互斥。</p><p>举个例子，假设有一个信号量s表示一个祭坛是否可用，初始值为 1。如果 s 的值为 1，表示祭坛空闲；如果 s 的值为 0，表示祭坛被占用;如果 s 的值为 -1，表示有一个人在等待使用祭坛。那么我们可以用 PV 操作来实现对祭坛的互斥访问:</p><ul><li>如果你想要使用祭坛，你就执行 P(s)操作，将 s 的值减 1。如果结果为 0或者正数，表示你可以使用祭坛;如果结果为负数，表示有人在使用祭坛，你就必须等待。</li><li>如果你使用完了祭坛，你就执行 V(s)操作，将 s 的值加 1。如果结果为正数或者 0，表示没有人在等待使用祭坛;如果结果为负数，表示有人在等待使用祭坛，你就需要唤醒他们中的一个。</li></ul><p>这样就可以保证每次只有一个人能够使用祭坛，实现了进程互斥。</p><p>除此之外，下面的方法也可以解决进程同步和互斥问题:</p><ul><li>临界区(Critical Section)：将可能引发互斥问题的代码段称为临界区。为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。</li><li>互斥锁(Mutex)：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。</li><li>条件变量(Condition Variable)：条件变量用于在进程之间传递信息，以便它们在特定条件下等待或唤醒。通常与互斥锁一起使用，以确保等待和唤醒的操作在正确的时机执行。</li></ul><h3 id="Day33"><a href="#Day33" class="headerlink" title="Day33"></a>Day33</h3><p><strong>什么是死锁，如何预防死锁？</strong>***</p><p>死锁是指<strong>两个或多个进程在争夺系统资源时，由于互相等待对方释放资源而无法继续执行的状态。</strong></p><p>死锁只有同时满足以下四个条件才会发生:</p><ul><li><strong>互斥条件：</strong>一个进程占用了某个资源时，其他进程无法同时占用该资源</li><li><strong>请求保持条件：</strong>一个线程因为请求资源而阻塞的时候，不会释放自己的资源</li><li><strong>不可剥夺条件：</strong>资源不能被强制性地从一个进程中剥夺，只能由持有者自愿释放，</li><li><strong>环路等待条件：</strong>多个进程之间形成一个循环等待资源的链，每个进程都在等待下一个进程所占有的资源。</li></ul><p>只需要破坏上面一个条件就可以破坏死锁。</p><ul><li><strong>破坏请求与保持条件：</strong>一次性申请所有的资源，</li><li><strong>破坏不可剥夺条件：</strong>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件：</strong>靠<strong>按序申请资源</strong>来预防。让所有进程按照相同的顺序请求资源，释放资源则反序释放。</li></ul><p><strong>介绍一下几种典型的锁？</strong>**</p><p>详见day9</p><p>两个基础的锁：</p><ul><li>互斥锁：互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。</li><li>自旋锁：自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。</li></ul><p>其他的锁都是基于这两个锁的</p><ul><li>读写锁：允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读(共享)和写(排他)两种状态。</li><li>悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁</li><li>乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作</li></ul><p><strong>什么是虚拟内存？为什么需要虚拟内存？</strong>**</p><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续虚拟地址空间，<strong>它不是真实存在的</strong>，而是通过映射与实际地址空间对应，这样就可以使每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存 RAM 更大的地址空间，每个程序都可以认为它拥有足够的内存来运行。</p><p>需要虚拟内存的原因：</p><ul><li>**内存扩展: **虚拟内存使得每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据</li><li><strong>内存隔离：</strong>虚拟内存还提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存，</li><li><strong>物理内存管理：</strong>虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</li><li><strong>页面交换：</strong>当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</li><li><strong>内存映射文件：</strong>虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</li></ul><h3 id="Day34"><a href="#Day34" class="headerlink" title="Day34"></a>Day34</h3><p><strong>你知道的线程同步的方式有哪些？</strong>**</p><p>线程同步机制是指在多线程编程中，为了保证线程之间的互不干扰，而采用的一种机制。常见的线程同步机制有以下几种：</p><ol><li><strong>互斥锁：</strong>互斥锁是最常见的线程同步机制。它允许只有一个线程同时访问被保护的临界区(共享资源)。</li><li><strong>条件变量：</strong>条件变量用于线程间通信，允许一个线程等待某个条件满足，而其他线程可以发出信号通知等待线程。通常与互斥锁一起使用。</li><li><strong>读写锁：</strong>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入资源。</li><li><strong>信号量：</strong>用于控制多个线程对共享资源进行访问的工具。</li></ol><p><strong>有哪些页面置换算法？</strong>**</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leophen/p/11397699.html">页面置换算法详解 - Leophen - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_75262255/article/details/139337506">操作系统之页面置换算法——FIFO、OPT和LRU_fifo替换算法-CSDN博客</a></p><blockquote><p>页面置换算法是什么？</p><p>进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，其中选择调出页面的算法就称为<strong>页面置换算法</strong>。</p><p>好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</p></blockquote><h3 id="Day35"><a href="#Day35" class="headerlink" title="Day35"></a>Day35</h3><p><strong>熟悉哪些Linux命令？</strong>**</p><ol><li><font style="color:#010101">文件相关(mv mkdir cd ls)</font></li><li><font style="color:#010101">进程相关( ps top netstate )</font></li><li><font style="color:#010101">权限相关(chmod chown useradd groupadd)</font></li><li><font style="color:#010101">网络相关(netstat ip addr)</font></li><li><font style="color:#010101">测试相关(测试网络连通性：ping；测试端口连通性：telnet)</font></li></ol><p><strong>如何查看某个端口有没有被占用？</strong>**</p><ol><li><code>netstat</code> 或 <code>ss命令</code></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep 端口号</span><br><span class="line">ss -tuln | grep 端口号</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><code>lsof</code> 命令</li></ol><p>这个命令是查看进程占用哪些文件的</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><code>fuser</code> 命令</li></ol><p><code>fuser</code>命令和<code>lsof</code>正好相反，是查看某个文件被哪个进程占用的。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fuser 22/tcp -v</span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">22/tcp:              root       1329 F.... sshd</span><br><span class="line">                     root       1606 f.... sshd</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>nmap工具</li></ol><p>nmap默认总是会扫描端口，要扫描本机端口，很方便。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nmap localhost</span><br><span class="line"></span><br><span class="line">Starting Nmap 5.51 ( http://nmap.org ) at 2018-03-03 18:00 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> localhost (127.0.0.1)</span><br><span class="line">Host is up (0.0000020s latency).</span><br><span class="line">Other addresses <span class="keyword">for</span> localhost (not scanned): 127.0.0.1</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">25/tcp open  smtp</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 0.06 seconds</span><br></pre></td></tr></tbody></table></figure><p><strong>说一下 select、poll、epoll？了解I/O多路复用吗？</strong>**</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/flashsun/p/14591563.html">图解 | 原来这就是 IO 多路复用 - 闪客sun - 博客园 (cnblogs.com)</a></p><p>select，poll，epoll 都是 I/O 多路复用的机制。</p><p>I/O多路复用是一种在单个线程中管理多个输入/输出通道的技术。它允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程。</p><p>常见的I/O多路复用机制包括select、poll和epoll。这些机制通过将多个I/O通道注册到一个事件管理器中，然后通过阻塞方式等待事件的发生。一旦有事件发生（如有数据可读或可写），线程就会被唤醒，然后可以针对具体的事件进行处理。</p><ul><li>当我们调用 select 函数时会传入一个文件描述符集合(fd_set)，内核会根据 IO 状态对 fd_set 的内容进行修改，从而通知执行 select 函数的进程哪一个文件或者 Socket 是可读的。</li></ul><blockquote><p>select的缺点：</p><ol><li>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</li><li>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</li><li>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</li></ol></blockquote><ul><li>poll 和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</li><li>epoll 主要就是针对select的三个缺点进行了改进。改进如下：</li></ul><ol><li>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</li><li>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li><li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</li></ol><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><strong>常见的排序算法说一下？也说一下各个时间复杂度？</strong>***</p><p><img src="/post/f4c4d599/1722855291493-b9c8a325-7a8c-482b-9072-cb6d74f0e76a.webp"></p><ul><li><font style="color:#010101">冒泡排序：通过相邻元素的比较和交换，每次将最大（或最小）的元素逐步“冒泡”到最后（或最前）。时间复杂度：最好情况下O(n)，最坏情况下O(n^2)，平均情况下O(n^2)。，空间复杂度：O(1)。</font></li><li><font style="color:#010101">插入排序：将待排序元素逐个插入到已排序序列的合适位置，形成有序序列。时间复杂度：最好情况下O(n)，最坏情况下O(n^2)，平均情况下O(n^2)，空间复杂度：O(1)。</font></li><li><font style="color:#010101">选择排序（Selection Sort）：通过不断选择未排序部分的最小（或最大）元素，并将其放置在已排序部分的末尾（或开头）。时间复杂度：最好情况下O(n^2)，最坏情况下O(n^2)，平均情况下O(n^2)，空间复杂度：O(1)。</font></li><li><font style="color:#010101">快速排序（Quick Sort）：通过选择一个基准元素，将数组划分为两个子数组，使得左子数组的元素都小于（或等于）基准元素，右子数组的元素都大于（或等于）基准元素，然后对子数组进行递归排序。时间复杂度：最好情况下O(nlogn)，最坏情况下O(n^2)，平均情况下O(nlogn)，空间复杂度：最好情况下O(logn)，最坏情况下O(n)。</font></li><li><font style="color:#010101">归并排序（Merge Sort）：将数组不断分割为更小的子数组，然后将子数组进行合并，合并过程中进行排序。时间复杂度：最好情况下O(nlogn)，最坏情况下O(nlogn)，平均情况下O(nlogn)。空间复杂度：O(n)。</font></li><li><font style="color:#010101">堆排序（Heap Sort）：通过将待排序元素构建成一个最大堆（或最小堆），然后将堆顶元素与末尾元素交换，再重新调整堆，重复该过程直到排序完成。时间复杂度：最好情况下O(nlogn)，最坏情况下O(nlogn)，平均情况下O(nlogn)。空间复杂度：O(1)。</font></li></ul></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Interviews/">Interviews</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media=&quot;all&quot;"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/c257a468.html" title="JVM常见面试问题"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM常见面试问题</div></div></a></div><div class="next-post pull-right"><a href="/post/729cb619.html" title="Redis常见面试问题"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis常见面试问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/8434e219.html" title="Redis学习"><img class="cover" src="https://w.wallhaven.cc/full/rr/wallhaven-rre597.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">Redis学习</div></div></a></div><div><a href="/post/dcc6e30d.html" title="Redis实现分布式锁的方法和常见问题"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-13</div><div class="title">Redis实现分布式锁的方法和常见问题</div></div></a></div><div><a href="/post/729cb619.html" title="Redis常见面试问题"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-22</div><div class="title">Redis常见面试问题</div></div></a></div><div><a href="/post/264f303d.html" title="Java学习 | 集合框架"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-11</div><div class="title">Java学习 | 集合框架</div></div></a></div><div><a href="/post/c84b5546.html" title="Java学习 | 堆和栈的区别"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="title">Java学习 | 堆和栈的区别</div></div></a></div><div><a href="/post/dec4d43c.html" title="Java学习 | JVM的垃圾回收机制——垃圾回收算法"><img class="cover" src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-28</div><div class="title">Java学习 | JVM的垃圾回收机制——垃圾回收算法</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myPic.png" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" alt="avatar"></div><div class="author-info__name">三木</div><div class="author-info__description"><center>目前计算机研究生在读，一次偶然的机会建立了这个博客，希望能在这里记录自己的学习和生活。<br>生命不息，学习不止，大胆地向前冲吧！ (ง •̀_•́)ง<center></center></center></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/threewood1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/336738455" target="_blank" title="Bilibili"><i class="iconfont icon-bilibilia" style="color:#000"></i></a><a class="social-icon" href="/img/qq.png" target="_blank" title="QQ"><i class="iconfont icon-qq" style="color:#000"></i></a><a class="social-icon" href="/img/wechat.png" target="_blank" title="WeChat"><i class="iconfont icon-weixin" style="color:#000"></i></a><a class="social-icon" href="mailto:959335709@qq.com" target="_blank" title="有什么建议就给我发邮件吧"><i class="iconfont icon-envelope" style="color:#000"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>Welcome to my Blog.<br>由于博主囊中羞涩，租不起国内的服务器，因此访问速度可能有点慢，有条件的朋友可以使用科学上网。<br>备用地址：threewood.top<center></center></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA"><span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day1%E2%88%9A"><span class="toc-text">Day1√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day2%E2%88%9A"><span class="toc-text">Day2√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day3%E2%88%9A"><span class="toc-text">Day3√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day4%E2%88%9A"><span class="toc-text">Day4√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day5%E2%88%9A"><span class="toc-text">Day5√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day6%E2%88%9A"><span class="toc-text">Day6√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day7%E2%88%9A"><span class="toc-text">Day7√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day8%E2%88%9A"><span class="toc-text">Day8√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day9%E2%88%9A"><span class="toc-text">Day9√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day10%E2%88%9A"><span class="toc-text">Day10√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day11%E2%88%9A"><span class="toc-text">Day11√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day12%E2%88%9A"><span class="toc-text">Day12√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day13"><span class="toc-text">Day13</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day14"><span class="toc-text">Day14</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day14-5%E2%88%9A"><span class="toc-text">Day14.5√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day15%E2%88%9A"><span class="toc-text">Day15√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day16%E2%88%9A"><span class="toc-text">Day16√</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day17%E2%88%9A"><span class="toc-text">Day17√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day18%E2%88%9A"><span class="toc-text">Day18√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day19%E2%88%9A"><span class="toc-text">Day19√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day20%E2%88%9A"><span class="toc-text">Day20√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day21%E2%88%9A"><span class="toc-text">Day21√</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#day22%E2%88%9A"><span class="toc-text">day22√</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day23"><span class="toc-text">Day23</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day24"><span class="toc-text">Day24</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day25"><span class="toc-text">Day25</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day26"><span class="toc-text">Day26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day27"><span class="toc-text">Day27</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day28"><span class="toc-text">Day28</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day29"><span class="toc-text">Day29</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day30"><span class="toc-text">Day30</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day31"><span class="toc-text">Day31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day32"><span class="toc-text">Day32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day33"><span class="toc-text">Day33</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day34"><span class="toc-text">Day34</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day35"><span class="toc-text">Day35</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-text">数据结构与算法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/51af033.html" title="Springboot项目登录拦截的三种方式"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Springboot项目登录拦截的三种方式"></a><div class="content"><a class="title" href="/post/51af033.html" title="Springboot项目登录拦截的三种方式">Springboot项目登录拦截的三种方式</a><time datetime="2024-09-16T12:01:00.000Z" title="发表于 2024-09-16 20:01:00">2024-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/dcc6e30d.html" title="Redis实现分布式锁的方法和常见问题"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Redis实现分布式锁的方法和常见问题"></a><div class="content"><a class="title" href="/post/dcc6e30d.html" title="Redis实现分布式锁的方法和常见问题">Redis实现分布式锁的方法和常见问题</a><time datetime="2024-09-13T02:07:00.000Z" title="发表于 2024-09-13 10:07:00">2024-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/729cb619.html" title="Redis常见面试问题"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Redis常见面试问题"></a><div class="content"><a class="title" href="/post/729cb619.html" title="Redis常见面试问题">Redis常见面试问题</a><time datetime="2024-08-22T07:38:17.000Z" title="发表于 2024-08-22 15:38:17">2024-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f4c4d599.html" title="面试八股"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="面试八股"></a><div class="content"><a class="title" href="/post/f4c4d599.html" title="面试八股">面试八股</a><time datetime="2024-07-09T05:18:17.000Z" title="发表于 2024-07-09 13:18:17">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c257a468.html" title="JVM常见面试问题"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="JVM常见面试问题"></a><div class="content"><a class="title" href="/post/c257a468.html" title="JVM常见面试问题">JVM常见面试问题</a><time datetime="2024-06-17T06:18:17.000Z" title="发表于 2024-06-17 14:18:17">2024-06-17</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By 三木</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://threewood1.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.threewood1.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.threewood1.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/sun_moon.js" async=""></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'NSRJN7YXG6',
    apiKey: '6a47300c2d5f7cd71bfe8c828ca4ec2f',
    indexName: 'threewood1',
    container: '#docsearch',
  }, null))


  const searchClickFn = () => {
    document.querySelector('#search-button > .search').addEventListener('click', () => {
      document.querySelector('.DocSearch-Button').click()
    })
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>