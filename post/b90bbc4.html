<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>RabbitMQ高级 | Threewood</title><meta name="author" content="三木,959335709@qq.com"><meta name="copyright" content="三木"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MQ学习"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ高级"><meta property="og:url" content="https://threewood1.top/post/b90bbc4.html"><meta property="og:site_name" content="Threewood"><meta property="og:description" content="MQ学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png"><meta property="article:published_time" content="2024-01-22T09:14:38.000Z"><meta property="article:modified_time" content="2024-01-22T08:17:31.443Z"><meta property="article:author" content="三木"><meta property="article:tag" content="MQ"><meta property="article:tag" content="RabbitMQ"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png"><link rel="shortcut icon" href="/img/paw-solid.svg"><link rel="canonical" href="https://threewood1.top/post/b90bbc4.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media=&quot;all&quot;"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 三木","link":"链接: ","source":"来源: Threewood","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"RabbitMQ高级",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-22 16:17:31"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/font.css"><script src="/live2d-widget/autoload.js"></script></head><body><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Threewood" type="application/atom+xml"><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myPic.png" onerror="onerror=null,src=&quot;/img/friend_404.gif&quot;" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-area-chart"></i><span> 相冊/壁紙</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> ToU:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/HTML/Eluvletter/index.html"><i class="fa-fw fas fa-envelope"></i><span> Eluvletter</span></a></li><li><a class="site-page child" href="/HTML/LoveTime/index.html"><i class="fa-fw fas fa-heart"></i><span> LoveTime</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png)"><nav id="nav"><span id="blog-info"><a href="/" title="Threewood"><span class="site-name">Threewood</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-area-chart"></i><span> 相冊/壁紙</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> ToU:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/HTML/Eluvletter/index.html"><i class="fa-fw fas fa-envelope"></i><span> Eluvletter</span></a></li><li><a class="site-page child" href="/HTML/LoveTime/index.html"><i class="fa-fw fas fa-heart"></i><span> LoveTime</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ高级</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-22T09:14:38.000Z" title="发表于 2024-01-22 17:14:38">2024-01-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-22T08:17:31.443Z" title="更新于 2024-01-22 16:17:31">2024-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learning/">Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="RabbitMQ高级"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url(https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png);"></div><article class="post-content" id="article-container"><h1 id="MQ高级"><a href="#MQ高级" class="headerlink" title="MQ高级"></a>MQ高级</h1><p>在昨天的练习作业中，我们改造了余额支付功能，在支付成功后利用 RabbitMQ 通知交易服务，更新业务订单状态为已支付。</p><p>但是大家思考一下，如果这里 MQ 通知失败，支付服务中支付流水显示支付成功，而交易服务中的订单状态却显示未支付，数据出现了不一致。</p><p>此时前端发送请求查询支付状态时，肯定是查询交易服务状态，会发现业务订单未支付，而用户自己知道已经支付成功，这就导致用户体验不一致。</p><p>因此，这里我们必须尽可能确保 MQ 消息的可靠性，即：消息应该至少被消费者处理 1 次</p><p>那么问题来了：</p><ul><li><strong>我们该如何确保<strong><strong>MQ</strong></strong>消息的可靠性</strong>？</li><li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li></ul><p>这些问题，在今天的学习中都会找到答案。</p><h1 id="1-发送者的可靠性"><a href="#1-发送者的可靠性" class="headerlink" title="1.发送者的可靠性"></a>1.发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。</p><p>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：</p><p>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li><p>发送消息时丢失：</p><ul><li>生产者发送消息时连接 MQ 失败</li><li>生产者发送消息到达 MQ 后未找到 <code>Exchange</code></li><li>生产者发送消息到达 MQ 的 <code>Exchange</code> 后，未找到合适的 <code>Queue</code></li><li>消息到达 MQ 后，处理消息的进程发生异常</li></ul></li><li><p>MQ 导致消息丢失：</p><ul><li>消息到达 MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li><p>消费者处理消息时：</p><ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证 MQ 的可靠性，就必须从 3 个方面入手：</p><ul><li>确保生产者一定把消息发送到 MQ</li><li>确保 MQ 不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><p>这一章我们先来看如何确保生产者一定能把消息发送到 MQ。</p><h2 id="1-1-生产者重试机制"><a href="#1-1-生产者重试机制" class="headerlink" title="1.1.生产者重试机制"></a>1.1.生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与 MQ 的连接中断。</p><p>为了解决这个问题，SpringAMQP 提供的消息发送时的重试机制。即：当 <code>RabbitTemplate</code> 与 MQ 连接超时后，多次重试。</p><p>修改 <code>publisher</code> 模块的 <code>application.yaml</code> 文件，添加下面的内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></tbody></table></figure><p>我们利用命令停掉 RabbitMQ 服务：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq</span><br></pre></td></tr></tbody></table></figure><p>然后测试发送一条消息，会发现会每隔 1 秒重试 1 次，总共重试了 3 次。消息发送的超时重试机制配置成功了！</p><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过 SpringAMQP 提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h2 id="1-2-生产者确认机制"><a href="#1-2-生产者确认机制" class="headerlink" title="1.2.生产者确认机制"></a>1.2.生产者确认机制</h2><p>一般情况下，只要生产者与 MQ 之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。</p><p>不过，在少数情况下，也会出现消息发送到 MQ 之后丢失的现象，比如：</p><ul><li>MQ 内部处理消息的进程发生了异常</li><li>生产者发送消息到达 MQ 后未找到 <code>Exchange</code></li><li>生产者发送消息到达 MQ 的 <code>Exchange</code> 后，未找到合适的 <code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ 提供了生产者消息确认机制，包括 <code>Publisher Confirm</code> 和 <code>Publisher Return</code> 两种。在开启确认机制的情况下，当生产者发送消息给 MQ 后，MQ 会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p>具体如图所示：</p><p><img src="/post/b90bbc4/VohQbYwSlo8R6AxfinGcLNq6nld.png"></p><p>总结如下：</p><ul><li>当消息投递到 MQ，但是路由失败时，通过 <strong>Publisher Return</strong> 返回异常信息，同时返回 ack 的确认信息，代表投递成功</li><li>临时消息投递到了 MQ，并且入队成功，返回 ACK，告知投递成功</li><li>持久消息投递到了 MQ，并且入队完成持久化，返回 ACK ，告知投递成功</li><li>其它情况都会返回 NACK，告知投递失败</li></ul><p>其中 <code>ack</code> 和 <code>nack</code> 属于 <strong>Publisher Confirm</strong> 机制，<code>ack</code> 是投递成功；<code>nack</code> 是投递失败。而 <code>return</code> 则属于 <strong>Publisher Return</strong> 机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h2 id="1-3-实现生产者确认"><a href="#1-3-实现生产者确认" class="headerlink" title="1.3.实现生产者确认"></a>1.3.实现生产者确认</h2><h3 id="1-3-1-开启生产者确认"><a href="#1-3-1-开启生产者确认" class="headerlink" title="1.3.1.开启生产者确认"></a>1.3.1.开启生产者确认</h3><p>在 publisher 模块的 <code>application.yaml</code> 中添加配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></tbody></table></figure><p>这里 <code>publisher-confirm-type</code> 有三种模式可选：</p><ul><li><code>none</code>：关闭 confirm 机制</li><li><code>simple</code>：同步阻塞等待 MQ 的回执</li><li><code>correlated</code>：MQ 异步回调返回回执</li></ul><p>一般我们推荐使用 <code>correlated</code>，回调机制。</p><h3 id="1-3-2-定义-ReturnCallback"><a href="#1-3-2-定义-ReturnCallback" class="headerlink" title="1.3.2.定义 ReturnCallback"></a>1.3.2.定义 ReturnCallback</h3><p>每个 <code>RabbitTemplate</code> 只能配置一个 <code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在 publisher 模块定义一个配置类：</p><p><img src="/post/b90bbc4/VtLLb0dSFo6XOdx1EEiczVvbnvc.png"></p><p>内容如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ReturnedMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>{</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> {</span><br><span class="line">                log.error(<span class="string">"触发return callback,"</span>);</span><br><span class="line">                log.debug(<span class="string">"exchange: {}"</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">"routingKey: {}"</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">"message: {}"</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">"replyCode: {}"</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">"replyText: {}"</span>, returned.getReplyText());</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-3-定义-ConfirmCallback"><a href="#1-3-3-定义-ConfirmCallback" class="headerlink" title="1.3.3.定义 ConfirmCallback"></a>1.3.3.定义 ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此 ConfirmCallback 需要在每次发消息时定义。具体来说，是在调用 RabbitTemplate 中的 convertAndSend 方法时，多传递一个参数：</p><p><img src="/post/b90bbc4/E2IcbQ9bQoCDTVx8m8GciifXnKe.png"></p><p>这里的 CorrelationData 中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ 对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的 Future 对象</li></ul><p>将来 MQ 的回执就会通过这个 <code>Future</code> 来返回，我们可以提前给 <code>CorrelationData</code> 中的 <code>Future</code> 添加回调函数来处理消息回执：</p><p><img src="/post/b90bbc4/TR81bF8E3ocm72xkaqHcuN9Nnph.png"></p><p>我们新建一个测试，向系统自带的交换机发送消息，并且添加 <code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> {</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">"send message fail"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> {</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck()){ <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">"发送消息成功，收到 ack!"</span>);</span><br><span class="line">            }<span class="keyword">else</span>{ <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">"发送消息失败，收到 nack, reason : {}"</span>, result.getReason());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hmall.direct"</span>, <span class="string">"q"</span>, <span class="string">"hello"</span>, cd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果如下：</p><p><img src="/post/b90bbc4/YmF2bo8C8ot7CexZXopcsIyTnYc.png"></p><p>可以看到，由于传递的 <code>RoutingKey</code> 是错误的，路由失败后，触发了 <code>return callback</code>，同时也收到了 ack。</p><p>当我们修改为正确的 <code>RoutingKey</code> 以后，就不会触发 <code>return callback</code> 了，只收到 ack。</p><p>而如果连交换机都是错误的，则只会收到 nack。</p><h1 id="2-MQ-的可靠性"><a href="#2-MQ-的可靠性" class="headerlink" title="2.MQ 的可靠性"></a>2.MQ 的可靠性</h1><p>消息到达 MQ 以后，如果 MQ 不能及时保存，也会导致消息丢失，所以 MQ 的可靠性也非常重要。</p><h2 id="2-1-数据持久化"><a href="#2-1-数据持久化" class="headerlink" title="2.1.数据持久化"></a>2.1.数据持久化</h2><p>为了提升性能，默认情况下 MQ 的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>我们以控制台界面为例来说明。</p><h3 id="2-1-1-交换机持久化"><a href="#2-1-1-交换机持久化" class="headerlink" title="2.1.1.交换机持久化"></a>2.1.1.交换机持久化</h3><p>在控制台的 <code>Exchanges</code> 页面，添加交换机时可以配置交换机的 <code>Durability</code> 参数：</p><p><img src="/post/b90bbc4/NPr8bcUqkoNVgIxP7ePct6thn4g.png"></p><p>设置为 <code>Durable</code> 就是持久化模式，<code>Transient</code> 就是临时模式。</p><h3 id="2-1-2-队列持久化"><a href="#2-1-2-队列持久化" class="headerlink" title="2.1.2.队列持久化"></a>2.1.2.队列持久化</h3><p>在控制台的 Queues 页面，添加队列时，同样可以配置队列的 <code>Durability</code> 参数：</p><p><img src="/post/b90bbc4/CxrxbP3awotxmkxSndlcE7iKnvd.png"></p><p>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p><h3 id="2-1-3-消息持久化"><a href="#2-1-3-消息持久化" class="headerlink" title="2.1.3.消息持久化"></a>2.1.3.消息持久化</h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个 <code>properties</code>：</p><p><img src="/post/b90bbc4/SVIKbI7VXojq3ixFUd1ch5oFnkh.png"></p><h2 id="2-2-LazyQueue"><a href="#2-2-LazyQueue" class="headerlink" title="2.2.LazyQueue"></a>2.2.LazyQueue</h2><p>在默认情况下，RabbitMQ 会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ 的内存占用就会越来越高，直到触发内存预警上限。此时 RabbitMQ 会将内存消息刷到磁盘上，这个行为成为 <code>PageOut</code>. <code>PageOut</code> 会耗费一段时间，并且会阻塞队列进程。因此在这个过程中 RabbitMQ 不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从 RabbitMQ 的 3.6.0 版本开始，就增加了 Lazy Queues 的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在 3.12 版本之后，LazyQueue 已经成为所有队列的默认格式。因此官方推荐升级 MQ 为 3.12 版本或者所有队列都设置为 LazyQueue 模式。</p><h3 id="2-2-1-控制台配置-Lazy-模式"><a href="#2-2-1-控制台配置-Lazy-模式" class="headerlink" title="2.2.1.控制台配置 Lazy 模式"></a>2.2.1.控制台配置 Lazy 模式</h3><p>在添加队列的时候，添加 <code>x-queue-mod=lazy</code> 参数即可设置队列为 Lazy 模式：</p><p><img src="/post/b90bbc4/D7mmbzVySoa0VzxTQ6Ucbpl2nKb.png"></p><h3 id="2-2-2-代码配置-Lazy-模式"><a href="#2-2-2-代码配置-Lazy-模式" class="headerlink" title="2.2.2.代码配置 Lazy 模式"></a>2.2.2.代码配置 Lazy 模式</h3><p>在利用 SpringAMQP 声明队列的时候，添加 <code>x-queue-mod=lazy</code> 参数也可设置队列为 Lazy 模式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">"lazy.queue"</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里是通过 <code>QueueBuilder</code> 的 <code>lazy()</code> 函数配置 Lazy 模式，底层源码如下：</p><p><img src="/post/b90bbc4/EBkmbWPYIo1x2KxnEXUcWHcHn0U.png"></p><p>当然，我们也可以基于注解来声明队列并设置为 Lazy 模式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = "lazy.queue",</span></span><br><span class="line"><span class="meta">        durable = "true",</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = "x-queue-mode", value = "lazy")</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>{</span><br><span class="line">    log.info(<span class="string">"接收到 lazy.queue的消息：{}"</span>, msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-3-更新已有队列为-lazy-模式"><a href="#2-2-3-更新已有队列为-lazy-模式" class="headerlink" title="2.2.3.更新已有队列为 lazy 模式"></a>2.2.3.更新已有队列为 lazy 模式</h3><p>对于已经存在的队列，也可以配置为 lazy 模式，但是要通过设置 policy 实现。</p><p>可以基于命令行设置 policy：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues</span><br></pre></td></tr></tbody></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ 的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>"^lazy-queue$"</code> ：用正则表达式匹配队列的名字</li><li><code>'{"queue-mode":"lazy"}'</code> ：设置队列模式为 lazy 模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置 policy，进入在控制台的 <code>Admin</code> 页面，点击 <code>Policies</code>，即可添加配置：</p><p><img src="/post/b90bbc4/AFUlbn4sMoqeX6xbldFcQPbYnXc.png"></p><h1 id="3-消费者的可靠性"><a href="#3-消费者的可靠性" class="headerlink" title="3.消费者的可靠性"></a>3.消费者的可靠性</h1><p>当 RabbitMQ 向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>…</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ 必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><p>但问题来了：RabbitMQ 如何得知消费者的处理状态呢？</p><p>本章我们就一起研究一下消费者处理消息时的可靠性解决方案。</p><h2 id="2-1-消费者确认机制"><a href="#2-1-消费者确认机制" class="headerlink" title="2.1.消费者确认机制"></a>2.1.消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ 从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ 需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ 从队列中删除该消息</li></ul><p>一般 reject 方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过 <code>try catch</code> 机制捕获，消息处理成功时返回 ack，处理失败时返回 nack.</p><p>由于消息回执的处理代码比较统一，因此 SpringAMQP 帮我们实现了消息确认。并允许我们通过配置文件设置 ACK 处理方式，有三种模式：</p><ul><li><p><strong>none</strong>：不处理。即消息投递给消费者后立刻 ack，消息会立刻从 MQ 删除。非常不安全，不建议使用</p></li><li><p><strong>manual</strong>：手动模式。需要自己在业务代码中调用 api，发送 <code>ack</code> 或 <code>reject</code>，存在业务入侵，但更灵活</p></li><li><p><strong>auto</strong>：自动模式。SpringAMQP 利用 AOP 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 <code>ack</code>. 当业务出现异常时，根据异常判断返回不同结果：</p><ul><li>如果是<strong>业务异常</strong>，会自动返回 <code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回 <code>reject</code>;</li></ul></li></ul><p>返回 Reject 的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<foo>but Message<bar>is received.</bar></foo></li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改 SpringAMQP 的 ACK 处理方式：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></tbody></table></figure><p>修改 consumer 服务的 SpringRabbitListener 类中的方法，模拟一个消息处理的异常：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = "simple.queue")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    log.info(<span class="string">"spring 消费者接收到消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageConversionException</span>(<span class="string">"故意的"</span>);</span><br><span class="line">    }</span><br><span class="line">    log.info(<span class="string">"消息处理完成"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试可以发现：当消息处理发生异常时，消息依然被 RabbitMQ 删除了。</p><p>我们再次把确认机制修改为 auto：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></tbody></table></figure><p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code>（未确定状态）：</p><p><img src="/post/b90bbc4/MaLabMxNNoh4gMxwHDxc4MxTnoh.png"></p><p>放行以后，由于抛出的是<strong>消息转换异常</strong>，因此 Spring 会自动返回 <code>reject</code>，所以消息依然会被删除：</p><p><img src="/post/b90bbc4/OuJLbuT9eowqpaxI7TNcimyinZc.png"></p><p>我们将异常改为 RuntimeException 类型：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = "simple.queue")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    log.info(<span class="string">"spring 消费者接收到消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"故意的"</span>);</span><br><span class="line">    }</span><br><span class="line">    log.info(<span class="string">"消息处理完成"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为 <code>unacked</code>（未确定状态）：</p><p><img src="/post/b90bbc4/UkKwbmXVpoyeUyxxxxncpY5NnMg.png"></p><p>放行以后，由于抛出的是业务异常，所以 Spring 返回 <code>ack</code>，最终消息恢复至 <code>Ready</code> 状态，并且没有被 RabbitMQ 删除：</p><p><img src="/post/b90bbc4/K8qRb41Uso5Riyx95aLcGAYQnCe.png"></p><p>当我们把配置改为 <code>auto</code> 时，消息处理失败后，会回到 RabbitMQ，并重新投递到消费者。</p><h2 id="2-2-失败重试机制"><a href="#2-2-失败重试机制" class="headerlink" title="2.2.失败重试机制"></a>2.2.失败重试机制</h2><p>当消费者出现异常后，消息会不断 requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次 requeue 到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息 requeue 就会无限循环，导致 mq 的消息处理飙升，带来不必要的压力：</p><p><img src="/post/b90bbc4/B2SpbJ5Rxo78AQxuyXQcauXsn4b.png"></p><p>当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况 Spring 又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的 requeue 到 mq 队列。</p><p>修改 consumer 服务的 application.yml 文件，添加内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></tbody></table></figure><p>重启 consumer 服务，重复之前的测试。可以发现：</p><ul><li>消费者在失败后消息没有重新回到 MQ 无限重新投递，而是在本地重试了 3 次</li><li>本地重试 3 次以后，抛出了 <code>AmqpRejectAndDontRequeueException</code> 异常。查看 RabbitMQ 控制台，发现消息被删除了，说明最后 SpringAMQP 返回的是 <code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会 requeue 到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring 会返回 reject，消息会被丢弃</li></ul><h2 id="2-3-失败处理策略"><a href="#2-3-失败处理策略" class="headerlink" title="2.3.失败处理策略"></a>2.3.失败处理策略</h2><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。</p><p>因此 Spring 允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由 <code>MessageRecovery</code> 接口来定义的，它有 3 个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接 <code>reject</code>，丢弃消息。默认就是这种方式</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回 <code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是 <code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在 consumer 服务中定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">"error.direct"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">"error.queue"</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>{</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">"error"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2）定义一个 RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">"error.direct"</span>, <span class="string">"error"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = "spring.rabbitmq.listener.simple.retry.enabled", havingValue = "true")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">"error.direct"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">"error.queue"</span>, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">"error"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">"error.direct"</span>, <span class="string">"error"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-业务幂等性"><a href="#2-4-业务幂等性" class="headerlink" title="2.4.业务幂等性"></a>2.4.业务幂等性</h2><p>何为幂等性？</p><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据 id 删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ 消息的重复投递</li></ul><p>我们在用户支付成功后会发送 MQ 消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。</p><p>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li></ol><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息 ID</li><li>业务状态判断</li></ul><h3 id="2-4-1-唯一消息-ID"><a href="#2-4-1-唯一消息-ID" class="headerlink" title="2.4.1.唯一消息 ID"></a>2.4.1.唯一消息 ID</h3><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的 id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一 ID 呢？</p><p>其实很简单，SpringAMQP 的 MessageConverter 自带了 MessageID 的功能，我们只要开启这个功能即可。</p><p>以 Jackson 的消息转换器为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-2-业务判断"><a href="#2-4-2-业务判断" class="headerlink" title="2.4.2.业务判断"></a>2.4.2.业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><p>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>相比较而言，消息 ID 的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p><p>以支付修改订单的业务为例，我们需要修改 <code>OrderServiceImpl</code> 中的 <code>markOrderPaySuccess</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> {</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">        <span class="comment">// 2.判断订单状态</span></span><br><span class="line">        <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        order.setStatus(<span class="number">2</span>);</span><br><span class="line">        order.setPayTime(LocalDateTime.now());</span><br><span class="line">        updateById(order);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p><p>我们可以合并上述操作为这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> {</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意看，上述代码等同于这样的 SQL 语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>我们在 where 条件中除了判断 id 以外，还加上了 status 必须为 1 的条件。如果条件不符（说明订单已支付），则 SQL 匹配不到数据，根本不会执行。</p><h2 id="2-5-兜底方案"><a href="#2-5-兜底方案" class="headerlink" title="2.5.兜底方案"></a>2.5.兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息 100% 的可靠。万一真的 MQ 通知失败该怎么办呢？</p><p>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>其实思想很简单：既然 MQ 通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的 MQ 通知失败，我们依然能通过主动查询来保证订单状态的一致。</p><p>流程如下：</p><p>图中黄色线圈起来的部分就是 MQ 通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。</p><p>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。</p><p>那么问题来了，我们到底该在什么时间主动查询支付状态呢？</p><p>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔 20 秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。</p><p>定时任务大家之前学习过，具体的实现这里就不再赘述了。</p><p>至此，消息可靠性的问题已经解决了。</p><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用 MQ 消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证 MQ 消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便 MQ 通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h1 id="4-延迟消息"><a href="#4-延迟消息" class="headerlink" title="4.延迟消息"></a>4.延迟消息</h1><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p><p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>例如，订单支付超时时间为 30 分钟，则我们应该在用户下单后的第 30 分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p><p>但问题来了：如何才能准确的实现在下单后第 30 分钟去检查支付状态呢？</p><p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用 MQ 的延迟消息了。</p><p>在 RabbitMQ 中实现延迟消息也有两种方案：</p><ul><li>死信交换机 +TTL</li><li>延迟消息插件</li></ul><p>这一章我们就一起研究下这两种方案的实现方式，以及优缺点。</p><h2 id="4-1-死信交换机和延迟消息"><a href="#4-1-死信交换机和延迟消息" class="headerlink" title="4.1.死信交换机和延迟消息"></a>4.1.死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p><h3 id="4-1-1-死信交换机"><a href="#4-1-1-死信交换机" class="headerlink" title="4.1.1.死信交换机"></a>4.1.1.死信交换机</h3><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用 <code>basic.reject</code> 或 <code>basic.nack</code> 声明消费失败，并且消息的 <code>requeue</code> 参数设置为 false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过 <strong>dead-letter-exchange</strong> 属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因 TTL（有效期）到期的消息</li></ol><h3 id="4-1-2-延迟消息"><a href="#4-1-2-延迟消息" class="headerlink" title="4.1.2.延迟消息"></a>4.1.2.延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的 <code>RepublishMessageRecoverer</code> 作用类似。</p><p>而最后一种场景，大家设想一下这样的场景：</p><p>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是 <code>ttl.queue</code> 没有消费者监听，而是设定了死信交换机 <code>hmall.direct</code>，而队列 <code>direct.queue1</code> 则与死信交换机绑定，RoutingKey 是 blue：</p><p><img src="/post/b90bbc4/DU6Bbv9ELogXMVxjEYZcS4C4nae.png"></p><p>假如我们现在发送一条消息到 <code>ttl.fanout</code>，RoutingKey 为 blue，并设置消息的<strong>有效期</strong>为 5000 毫秒：</p><p><img src="/post/b90bbc4/IGCWbzpEKo3loaxCJWkcQukZnme.png"></p><p>消息肯定会被投递到 <code>ttl.queue</code> 之后，由于没有消费者，因此消息无人消费。5 秒之后，消息的有效期到期，成为死信：</p><p><img src="/post/b90bbc4/JLSsbX5RyoZCKTxCxhGcksRynFb.png"></p><p>死信被再次投递到死信交换机 <code>hmall.direct</code>，并沿用之前的 RoutingKey，也就是 <code>blue</code>：</p><p><img src="/post/b90bbc4/RVgSbj8otoQtKYxsd4jc2OdFnOb.png"></p><p>由于 <code>direct.queue1</code> 与 <code>hmall.direct</code> 绑定的 key 是 blue，因此最终消息被成功路由到 <code>direct.queue1</code>，如果此时有消费者与 <code>direct.queue1</code> 绑定， 也就能成功消费消息了。但此时已经是 5 秒钟以后了：</p><p><img src="/post/b90bbc4/KZx0bBSh7ofh4jxA0lTcTlL1nic.png"></p><p>也就是说，publisher 发送了一条消息，但最终 consumer 在 5 秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h3 id="4-1-3-总结"><a href="#4-1-3-总结" class="headerlink" title="4.1.3.总结"></a>4.1.3.总结</h3><h2 id="4-2-DelayExchange-插件"><a href="#4-2-DelayExchange-插件" class="headerlink" title="4.2.DelayExchange 插件"></a>4.2.DelayExchange 插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此 RabbitMQ 社区提供了一个延迟消息插件来实现相同的效果。</p><p>官方文档说明：</p><h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1.下载"></a>4.2.1.下载</h3><p>插件下载地址：</p><p>由于我们安装的 MQ 是 <code>3.8</code> 版本，因此这里下载 <code>3.8.17</code> 版本：</p><p><img src="/post/b90bbc4/KqSKbHiB5oHaCPxSVG5cBt00nac.png"></p><p>当然，也可以直接使用课前资料提供好的插件：</p><p><img src="/post/b90bbc4/U7x4bEQwcosUk2xNHdGc098znec.png"></p><h3 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2.安装"></a>4.2.2.安装</h3><p>因为我们是基于 Docker 安装，所以需要先查看 RabbitMQ 的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></tbody></table></figure><p>结果如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"CreatedAt"</span><span class="punctuation">:</span> <span class="string">"2024-06-19T09:22:59+08:00"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"Driver"</span><span class="punctuation">:</span> <span class="string">"local"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"Labels"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"Mountpoint"</span><span class="punctuation">:</span> <span class="string">"/var/lib/docker/volumes/mq-plugins/_data"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"Name"</span><span class="punctuation">:</span> <span class="string">"mq-plugins"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"Options"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"Scope"</span><span class="punctuation">:</span> <span class="string">"local"</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure><p>插件目录被挂载到了 <code>/var/lib/docker/volumes/mq-plugins/_data</code> 这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><p><img src="/post/b90bbc4/TZdFbdnG8oJ9aSxedA9cjII6n0f.png"></p><h3 id="4-2-3-声明延迟交换机"><a href="#4-2-3-声明延迟交换机" class="headerlink" title="4.2.3.声明延迟交换机"></a>4.2.3.声明延迟交换机</h3><p>基于注解方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = "delay.queue", durable = "true"),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = "delay.direct", delayed = "true"),</span></span><br><span class="line"><span class="meta">        key = "delay"</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>{</span><br><span class="line">    log.info(<span class="string">"接收到delay.queue的延迟消息：{}"</span>, msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基于 <code>@Bean</code> 的方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">"delay.direct"</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">"delay.queue"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">"delay"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-4-发送延迟消息"><a href="#4-2-4-发送延迟消息" class="headerlink" title="4.2.4.发送延迟消息"></a>4.2.4.发送延迟消息</h3><p>发送消息时，必须通过 x-delay 属性设定延迟时间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"hello, delayed message"</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"delay.direct"</span>, <span class="string">"delay"</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException {</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-超时订单问题"><a href="#4-3-超时订单问题" class="headerlink" title="4.3.超时订单问题"></a>4.3.超时订单问题</h2><p>接下来，我们就在交易服务中利用延迟消息实现订单超时取消功能。其大概思路如下：</p><p><img src="/post/b90bbc4/MIOhbsy7KomGNMxnXXIc4Tu4nXW.jpeg"></p><p>假如订单超时支付时间为 30 分钟，理论上说我们应该在下单时发送一条延迟消息，延迟时间为 30 分钟。这样就可以在接收到消息时检验订单支付状态，关闭未支付订单。</p><p>但是大多数情况下用户支付都会在 1 分钟内完成，我们发送的消息却要在 MQ 中停留 30 分钟，额外消耗了 MQ 的资源。因此，我们最好多检测几次订单支付状态，而不是在最后第 30 分钟才检测。</p><p>例如：我们在用户下单后的第 10 秒、20 秒、30 秒、45 秒、60 秒、1 分 30 秒、2 分、…30 分分别设置延迟消息，如果提前发现订单已经支付，则后续的检测取消即可。</p><p>这样就可以有效避免对 MQ 资源的浪费了。</p><p>优化后的实现思路如下：</p><p><img src="/post/b90bbc4/SmNCbfSVkoAW63x9d1McO1DEnyb.jpeg"></p><p>由于我们要多次发送延迟消息，因此需要先定义一个记录消息延迟时间的消息体，处于通用性考虑，我们将其定义到 <code>hm-common</code> 模块下：</p><p><img src="/post/b90bbc4/EpYHbvNiSovHyQxTcjwcrlAOnKb.png"></p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiDelayMessage</span>&lt;T&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录延迟时间的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; delayMillis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiDelayMessage</span><span class="params">(T data, List&lt;Long&gt; delayMillis)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.delayMillis = delayMillis;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; MultiDelayMessage&lt;T&gt; <span class="title function_">of</span><span class="params">(T data, Long ... delayMillis)</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultiDelayMessage</span>&lt;&gt;(data, CollUtils.newArrayList(delayMillis));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并移除下一个延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列中的第一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">removeNextDelay</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> delayMillis.remove(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否还有下一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNextDelay</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> !delayMillis.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-1-定义常量"><a href="#4-3-1-定义常量" class="headerlink" title="4.3.1.定义常量"></a>4.3.1.定义常量</h3><p>无论是消息发送还是接收都是在交易服务完成，因此我们在 <code>trade-service</code> 中定义一个常量类，用于记录交换机、队列、RoutingKey 等常量：</p><p><img src="/post/b90bbc4/GHBGbT2WLoreOwxwyT5cPu1anOf.png"></p><p>内容如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MqConstants</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE</span> <span class="operator">=</span> <span class="string">"trade.delay.topic"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE</span> <span class="operator">=</span> <span class="string">"trade.order.delay.queue"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">"order.query"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-2-抽取共享-mq-配置"><a href="#4-3-2-抽取共享-mq-配置" class="headerlink" title="4.3.2.抽取共享 mq 配置"></a>4.3.2.抽取共享 mq 配置</h3><p>我们将 mq 的配置抽取到 nacos 中，方便各个微服务共享配置。</p><p>在 nacos 中定义一个名为 <code>shared-mq.xml</code> 的配置文件，内容如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">${hm.mq.host:192.168.150.101}</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">${hm.mq.port:5672}</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">${hm.mq.vhost:/hmall}</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">${hm.mq.un:hmall}</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">${hm.mq.pw:123}</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></tbody></table></figure><p>这里只添加一些基础配置，至于生产者确认，消费者确认配置则由微服务根据业务自己决定。</p><p>在 <code>trade-service</code> 模块添加共享配置：</p><p><img src="/post/b90bbc4/B3AZbVyNzoVo4nxS863cyULtnyd.png"></p><h3 id="4-3-3-改造下单业务"><a href="#4-3-3-改造下单业务" class="headerlink" title="4.3.3.改造下单业务"></a>4.3.3.改造下单业务</h3><p>接下来，我们改造下单业务，在下单完成后，发送延迟消息，查询支付状态。</p><p>1）引入依赖</p><p>在 <code>trade-service</code> 模块的 <code>pom.xml</code> 中引入 amqp 的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2）改造下单业务</p><p>修改 <code>trade-service</code> 模块的 <code>com.hmall.trade.service.impl.OrderServiceImpl</code> 类的 <code>createOrder</code> 方法，添加消息发送的代码：</p><p><img src="/post/b90bbc4/EtARbmMkholu7MxCdzHcHL2hntX.png"></p><h3 id="4-3-4-编写查询支付状态接口"><a href="#4-3-4-编写查询支付状态接口" class="headerlink" title="4.3.4.编写查询支付状态接口"></a>4.3.4.编写查询支付状态接口</h3><p>由于 MQ 消息处理时需要查询支付状态，因此我们要在 pay-service 模块定义一个这样的接口，并提供对应的 FeignClient.</p><p>首先，在 hm-api 模块定义三个类：</p><p><img src="/post/b90bbc4/U4aPbhArAovCXyxs3iRcH6IUnAc.png"></p><p>说明：</p><ul><li>PayOrderDTO：支付单的数据传输实体</li><li>PayClient：支付系统的 Feign 客户端</li><li>PayClientFallback：支付系统的 fallback 逻辑</li></ul><p>PayOrderDTO 代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 支付订单</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = "支付单数据传输实体")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderDTO</span> {</span><br><span class="line">    <span class="meta">@ApiModelProperty("id")</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty("业务订单号")</span></span><br><span class="line">    <span class="keyword">private</span> Long bizOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付单号")</span></span><br><span class="line">    <span class="keyword">private</span> Long payOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付用户id")</span></span><br><span class="line">    <span class="keyword">private</span> Long bizUserId;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付渠道编码")</span></span><br><span class="line">    <span class="keyword">private</span> String payChannelCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付金额，单位分")</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    <span class="meta">@ApiModelProperty("付类型，1：h5,2:小程序，3：公众号，4：扫码，5：余额支付")</span></span><br><span class="line">    <span class="keyword">private</span> Integer payType;</span><br><span class="line">    <span class="meta">@ApiModelProperty("付状态，0：待提交，1:待支付，2：支付超时或取消，3：支付成功")</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty("拓展字段，用于传递不同渠道单独处理的字段")</span></span><br><span class="line">    <span class="keyword">private</span> String expandJson;</span><br><span class="line">    <span class="meta">@ApiModelProperty("第三方返回业务码")</span></span><br><span class="line">    <span class="keyword">private</span> String resultCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty("第三方返回提示信息")</span></span><br><span class="line">    <span class="keyword">private</span> String resultMsg;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付成功时间")</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime paySuccessTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付超时时间")</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime payOverTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty("支付二维码链接")</span></span><br><span class="line">    <span class="keyword">private</span> String qrCodeUrl;</span><br><span class="line">    <span class="meta">@ApiModelProperty("创建时间")</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty("更新时间")</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PayClient 代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.fallback.PayClientFallback;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = "pay-service", fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据交易订单id查询支付单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 业务订单id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支付单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping("/pay-orders/biz/{id}")</span></span><br><span class="line">    PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable("id")</span> Long id)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PayClientFallback 代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;PayClient&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PayClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PayClient</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(Long id)</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后，在 pay-service 模块的 PayController 中实现该接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation("根据id查询支付单")</span></span><br><span class="line"><span class="meta">@GetMapping("/biz/{id}")</span></span><br><span class="line"><span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable("id")</span> Long id)</span>{</span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> payOrderService.lambdaQuery().eq(PayOrder::getBizOrderNo, id).one();</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyBean(payOrder, PayOrderDTO.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-5-消息监听"><a href="#4-3-5-消息监听" class="headerlink" title="4.3.5.消息监听"></a>4.3.5.消息监听</h3><p>接下来，我们在 trader-service 编写一个监听器，监听延迟消息，查询订单支付状态：</p><p><img src="/post/b90bbc4/M3hMbQwIxoGRZQxrTClc7r7gnje.png"></p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.domain.MultiDelayMessage;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.Order;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatusListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MqConstants.DELAY_ORDER_QUEUE, durable = "true"),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MqConstants.DELAY_EXCHANGE, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = MqConstants.DELAY_ORDER_ROUTING_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderCheckDelayMessage</span><span class="params">(MultiDelayMessage&lt;Long&gt; msg)</span> {</span><br><span class="line">        <span class="comment">// 1.获取消息中的订单id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getData();</span><br><span class="line">        <span class="comment">// 2.查询订单，判断状态：1是未支付，大于1则是已支付或已关闭</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span> || order.getStatus() &gt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 订单不存在或交易已经结束，放弃处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3.可能是未支付，查询支付服务</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="keyword">if</span> (payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>) {</span><br><span class="line">            <span class="comment">// 支付成功，更新订单状态</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.确定未支付，判断是否还有剩余延迟时间</span></span><br><span class="line">        <span class="keyword">if</span> (msg.hasNextDelay()) {</span><br><span class="line">            <span class="comment">// 4.1.有延迟时间，需要重发延迟消息，先获取延迟时间的int值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">delayVal</span> <span class="operator">=</span> msg.removeNextDelay().intValue();</span><br><span class="line">            <span class="comment">// 4.2.发送延迟消息</span></span><br><span class="line">            rabbitTemplate.convertAndSend(MqConstants.DELAY_EXCHANGE, MqConstants.DELAY_ORDER_ROUTING_KEY, msg,</span><br><span class="line">                    message -&gt; {</span><br><span class="line">                        message.getMessageProperties().setDelay(delayVal);</span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    });</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 5.没有剩余延迟时间了，说明订单超时未支付，需要取消订单</span></span><br><span class="line">        orderService.cancelOrder(orderId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，这里要在 OrderServiceImpl 中实现 cancelOrder 方法，留作作业大家自行实现。</p><h1 id="5-作业"><a href="#5-作业" class="headerlink" title="5.作业"></a>5.作业</h1><h2 id="5-1-取消订单"><a href="#5-1-取消订单" class="headerlink" title="5.1.取消订单"></a>5.1.取消订单</h2><p>在处理超时未支付订单时，如果发现订单确实超时未支付，最终需要关闭该订单。</p><p>关闭订单需要完成两件事情：</p><ul><li>将订单状态修改为已关闭</li><li>恢复订单中已经扣除的库存</li></ul><p>这部分功能尚未实现。</p><p>大家要在 <code>IOrderService</code> 接口中定义 <code>cancelOrder</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span>;</span><br></pre></td></tr></tbody></table></figure><p>并且在 <code>OrderServiceImpl</code> 中实现该方法。实现过程中要注意业务幂等性判断。</p><h2 id="5-2-抽取-MQ-工具"><a href="#5-2-抽取-MQ-工具" class="headerlink" title="5.2.抽取 MQ 工具"></a>5.2.抽取 MQ 工具</h2><p>MQ 在企业开发中的常见应用我们就学习完毕了，除了收发消息以外，消息可靠性的处理、生产者确认、消费者确认、延迟消息等等编码还是相对比较复杂的。</p><p>因此，我们需要将这些常用的操作封装为工具，方便在项目中使用。要求如下：</p><ul><li><p>在 <code>hm-commom</code> 模块下编写发送消息的工具类 <code>RabbitMqHelper</code></p></li><li><p>定义一个自动配置类 <code>MqConsumeErrorAutoConfiguration</code>，内容包括：</p><ul><li>声明一个交换机，名为 <code>error.direct</code>，类型为 <code>direct</code></li><li>声明一个队列，名为：<code>微服务名 + error.queue</code>，也就是说要动态获取</li><li>将队列与交换机绑定，绑定时的 <code>RoutingKey</code> 就是 <code>微服务名</code></li><li>声明 <code>RepublishMessageRecoverer</code>，消费失败消息投递到上述交换机</li><li>给配置类添加条件，当 <code>spring.rabbitmq.listener.simple.retry.enabled</code> 为 <code>true</code> 时触发</li></ul></li></ul><p>RabbitMqHelper 的结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqHelper</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object msg)</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> delay)</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-3-改造业务"><a href="#5-3-改造业务" class="headerlink" title="5.3.改造业务"></a>5.3.改造业务</h2><p>利用你编写的工具，改造支付服务、购物车服务、交易服务中消息发送功能，并且添加消息确认或消费者重试机制，确保消息的可靠性。</p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MQ/">MQ</a><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media=&quot;all&quot;"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2ef47cbd.html" title="RabbitMQ基础"><img class="cover" src="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ基础</div></div></a></div><div class="next-post pull-right"><a href="/post/d1dc93ff.html" title="抽取 MQ 工具的作业参考"><img class="cover" src="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">抽取 MQ 工具的作业参考</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2ef47cbd.html" title="RabbitMQ基础"><img class="cover" src="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-22</div><div class="title">RabbitMQ基础</div></div></a></div><div><a href="/post/d1dc93ff.html" title="抽取 MQ 工具的作业参考"><img class="cover" src="https://w.wallhaven.cc/full/x8/wallhaven-x83qy3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-22</div><div class="title">抽取 MQ 工具的作业参考</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/myPic.png" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" alt="avatar"></div><div class="author-info__name">三木</div><div class="author-info__description"><center>目前计算机研究生在读，一次偶然的机会建立了这个博客，希望能在这里记录自己的学习和生活。<br>生命不息，学习不止，大胆地向前冲吧！ (ง •̀_•́)ง<center></center></center></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/threewood1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/336738455" target="_blank" title="Bilibili"><i class="iconfont icon-bilibilia" style="color:#000"></i></a><a class="social-icon" href="/img/qq.png" target="_blank" title="QQ"><i class="iconfont icon-qq" style="color:#000"></i></a><a class="social-icon" href="/img/wechat.png" target="_blank" title="WeChat"><i class="iconfont icon-weixin" style="color:#000"></i></a><a class="social-icon" href="mailto:959335709@qq.com" target="_blank" title="有什么建议就给我发邮件吧"><i class="iconfont icon-envelope" style="color:#000"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>Welcome to my Blog.<br>由于博主囊中羞涩，租不起国内的服务器，因此访问速度可能有点慢，有条件的朋友可以使用科学上网。<br>备用地址：threewood.top<center></center></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ%E9%AB%98%E7%BA%A7"><span class="toc-text">MQ高级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%91%E9%80%81%E8%80%85%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">1.发送者的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">1.1.生产者重试机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2.生产者确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-text">1.3.实现生产者确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%BC%80%E5%90%AF%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-text">1.3.1.开启生产者确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%AE%9A%E4%B9%89-ReturnCallback"><span class="toc-text">1.3.2.定义 ReturnCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%AE%9A%E4%B9%89-ConfirmCallback"><span class="toc-text">1.3.3.定义 ConfirmCallback</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-MQ-%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">2.MQ 的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.1.交换机持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.2.队列持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.1.3.消息持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-LazyQueue"><span class="toc-text">2.2.LazyQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%85%8D%E7%BD%AE-Lazy-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.1.控制台配置 Lazy 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE-Lazy-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.2.代码配置 Lazy 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%9B%B4%E6%96%B0%E5%B7%B2%E6%9C%89%E9%98%9F%E5%88%97%E4%B8%BA-lazy-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.3.更新已有队列为 lazy 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">3.消费者的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">2.1.消费者确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">2.2.失败重试机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">2.3.失败处理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-text">2.4.业务幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%94%AF%E4%B8%80%E6%B6%88%E6%81%AF-ID"><span class="toc-text">2.4.1.唯一消息 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E4%B8%9A%E5%8A%A1%E5%88%A4%E6%96%AD"><span class="toc-text">2.4.2.业务判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%85%9C%E5%BA%95%E6%96%B9%E6%A1%88"><span class="toc-text">2.5.兜底方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.延迟消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.1.死信交换机和延迟消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">4.1.1.死信交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.1.2.延迟消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%80%BB%E7%BB%93"><span class="toc-text">4.1.3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-DelayExchange-%E6%8F%92%E4%BB%B6"><span class="toc-text">4.2.DelayExchange 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E4%B8%8B%E8%BD%BD"><span class="toc-text">4.2.1.下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%AE%89%E8%A3%85"><span class="toc-text">4.2.2.安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%A3%B0%E6%98%8E%E5%BB%B6%E8%BF%9F%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">4.2.3.声明延迟交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%8F%91%E9%80%81%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.2.4.发送延迟消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%B6%85%E6%97%B6%E8%AE%A2%E5%8D%95%E9%97%AE%E9%A2%98"><span class="toc-text">4.3.超时订单问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-text">4.3.1.定义常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E6%8A%BD%E5%8F%96%E5%85%B1%E4%BA%AB-mq-%E9%85%8D%E7%BD%AE"><span class="toc-text">4.3.2.抽取共享 mq 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E6%94%B9%E9%80%A0%E4%B8%8B%E5%8D%95%E4%B8%9A%E5%8A%A1"><span class="toc-text">4.3.3.改造下单业务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E7%BC%96%E5%86%99%E6%9F%A5%E8%AF%A2%E6%94%AF%E4%BB%98%E7%8A%B6%E6%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.3.4.编写查询支付状态接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-%E6%B6%88%E6%81%AF%E7%9B%91%E5%90%AC"><span class="toc-text">4.3.5.消息监听</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BD%9C%E4%B8%9A"><span class="toc-text">5.作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%8F%96%E6%B6%88%E8%AE%A2%E5%8D%95"><span class="toc-text">5.1.取消订单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%8A%BD%E5%8F%96-MQ-%E5%B7%A5%E5%85%B7"><span class="toc-text">5.2.抽取 MQ 工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%94%B9%E9%80%A0%E4%B8%9A%E5%8A%A1"><span class="toc-text">5.3.改造业务</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/fd7940ad.html" title="Kafka常见面试问题"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Kafka常见面试问题"></a><div class="content"><a class="title" href="/post/fd7940ad.html" title="Kafka常见面试问题">Kafka常见面试问题</a><time datetime="2024-11-05T09:20:17.000Z" title="发表于 2024-11-05 17:20:17">2024-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/51af033.html" title="Springboot项目登录拦截的三种方式"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Springboot项目登录拦截的三种方式"></a><div class="content"><a class="title" href="/post/51af033.html" title="Springboot项目登录拦截的三种方式">Springboot项目登录拦截的三种方式</a><time datetime="2024-09-16T12:01:00.000Z" title="发表于 2024-09-16 20:01:00">2024-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/dcc6e30d.html" title="Redis实现分布式锁的方法和常见问题"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Redis实现分布式锁的方法和常见问题"></a><div class="content"><a class="title" href="/post/dcc6e30d.html" title="Redis实现分布式锁的方法和常见问题">Redis实现分布式锁的方法和常见问题</a><time datetime="2024-09-13T02:07:00.000Z" title="发表于 2024-09-13 10:07:00">2024-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/729cb619.html" title="Redis常见面试问题"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Redis常见面试问题"></a><div class="content"><a class="title" href="/post/729cb619.html" title="Redis常见面试问题">Redis常见面试问题</a><time datetime="2024-08-22T07:38:17.000Z" title="发表于 2024-08-22 15:38:17">2024-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f4c4d599.html" title="面试八股"><img src="https://w.wallhaven.cc/full/2y/wallhaven-2y39jy.png" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="面试八股"></a><div class="content"><a class="title" href="/post/f4c4d599.html" title="面试八股">面试八股</a><time datetime="2024-07-09T05:18:17.000Z" title="发表于 2024-07-09 13:18:17">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By 三木</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://threewood1.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.threewood1.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.threewood1.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/sun_moon.js" async=""></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'NSRJN7YXG6',
    apiKey: '6a47300c2d5f7cd71bfe8c828ca4ec2f',
    indexName: 'threewood1',
    container: '#docsearch',
  }, null))


  const searchClickFn = () => {
    document.querySelector('#search-button > .search').addEventListener('click', () => {
      document.querySelector('.DocSearch-Button').click()
    })
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>